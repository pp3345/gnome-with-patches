diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index 1a622c8d2706ed43ccbb0126d80d5518ff18e333..1bd88bcd350fe7ad69833edddd45a73ac6193e6c 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -311,7 +311,7 @@
  * |[<!-- language="C" -->
  * ClutterTransition *transition;
  *
- * transition = clutter_property_transition_new ("opacity");
+ * transition = clutter_property_transition_new_for_actor (actor, "opacity");
  * clutter_timeline_set_duration (CLUTTER_TIMELINE (transition), 3000);
  * clutter_timeline_set_repeat_count (CLUTTER_TIMELINE (transition), 2);
  * clutter_timeline_set_auto_reverse (CLUTTER_TIMELINE (transition), TRUE);
@@ -344,7 +344,7 @@
  * ClutterTransition *transition;
  * ClutterInterval *interval;
  *
- * transition = clutter_property_transition_new ("opacity");
+ * transition = clutter_property_transition_new_for_actor (actor, "opacity");
  *
  * // we want to animate the opacity between 0 and 255
  * clutter_transition_set_from (transition, G_TYPE_UINT, 0);
@@ -505,7 +505,7 @@
  *   const char *prop = "@constraints.bind-x.offset";
  *
  *   // create a new transition for the given property
- *   transition = clutter_property_transition_new (prop);
+ *   transition = clutter_property_transition_new_for_actor (rect, prop);
  *
  *   // set the easing mode and duration
  *   clutter_timeline_set_progress_mode (CLUTTER_TIMELINE (transition),
@@ -652,6 +652,7 @@
 #include "clutter-scriptable.h"
 #include "clutter-script-private.h"
 #include "clutter-stage-private.h"
+#include "clutter-stage-view-private.h"
 #include "clutter-timeline.h"
 #include "clutter-transition.h"
 #include "clutter-units.h"
@@ -3027,7 +3028,7 @@ clutter_actor_get_abs_allocation_vertices (ClutterActor       *self,
       if (!stage)
         return;
 
-      _clutter_stage_maybe_relayout (stage);
+      clutter_stage_maybe_relayout (stage);
     }
 
   /* NB: _clutter_actor_transform_and_project_box expects a box in the actor's
@@ -9277,7 +9278,7 @@ clutter_actor_get_allocation_box (ClutterActor    *self,
 
       /* do not queue a relayout on an unparented actor */
       if (stage)
-        _clutter_stage_maybe_relayout (stage);
+        clutter_stage_maybe_relayout (stage);
     }
 
   /* commenting out the code above and just keeping this assigment
@@ -13588,12 +13589,19 @@ clutter_actor_set_final_state (ClutterAnimatable *animatable,
   g_free (p_name);
 }
 
+static ClutterActor *
+clutter_actor_get_actor (ClutterAnimatable *animatable)
+{
+  return CLUTTER_ACTOR (animatable);
+}
+
 static void
 clutter_animatable_iface_init (ClutterAnimatableInterface *iface)
 {
   iface->find_property = clutter_actor_find_property;
   iface->get_initial_state = clutter_actor_get_initial_state;
   iface->set_final_state = clutter_actor_set_final_state;
+  iface->get_actor = clutter_actor_get_actor;
 }
 
 /**
@@ -16250,6 +16258,83 @@ clutter_actor_peek_stage_views (ClutterActor *self)
   return self->priv->stage_views;
 }
 
+gboolean
+clutter_actor_is_effectively_on_stage_view (ClutterActor     *self,
+                                            ClutterStageView *view)
+{
+  ClutterActor *actor;
+
+  g_return_val_if_fail (CLUTTER_IS_ACTOR (self), FALSE);
+
+  if (g_list_find (self->priv->stage_views, view))
+    return TRUE;
+
+  for (actor = self; actor; actor = actor->priv->parent)
+    {
+      if (actor->priv->clones)
+        {
+          GHashTableIter iter;
+          gpointer key;
+
+          g_hash_table_iter_init (&iter, actor->priv->clones);
+          while (g_hash_table_iter_next (&iter, &key, NULL))
+            {
+              ClutterActor *clone = key;
+              GList *clone_views;
+
+              clone_views = clutter_actor_peek_stage_views (clone);
+              if (g_list_find (clone_views, view))
+                return TRUE;
+            }
+        }
+    }
+
+  return FALSE;
+}
+
+/**
+ * clutter_actor_pick_frame_clock:
+ * @self: a #ClutterActor
+ *
+ * Pick the most suitable frame clock for driving animations for this actor.
+ *
+ * Returns: (transfer none): a #ClutterFrameClock
+ */
+ClutterFrameClock *
+clutter_actor_pick_frame_clock (ClutterActor *self)
+{
+  ClutterActorPrivate *priv = self->priv;
+  float max_refresh_rate = 0.0;
+  ClutterStageView *best_view = NULL;
+  GList *l;
+
+  if (!priv->stage_views)
+    {
+     if (priv->parent)
+       return clutter_actor_pick_frame_clock (priv->parent);
+     else
+       return NULL;
+    }
+
+  for (l = priv->stage_views; l; l = l->next)
+    {
+      ClutterStageView *view = l->data;
+      float refresh_rate;
+
+      refresh_rate = clutter_stage_view_get_refresh_rate (view);
+      if (refresh_rate > max_refresh_rate)
+        {
+          best_view = view;
+          max_refresh_rate = refresh_rate;
+        }
+    }
+
+  if (best_view)
+    return clutter_stage_view_get_frame_clock (best_view);
+  else
+    return NULL;
+}
+
 /**
  * clutter_actor_has_overlaps:
  * @self: A #ClutterActor
diff --git a/clutter/clutter/clutter-actor.h b/clutter/clutter/clutter-actor.h
index 128acac1a32154dbfd2055540aeda2c40cd5b7e4..e5fa72baed75a025a3d41f56fa84e9680f9416a1 100644
--- a/clutter/clutter/clutter-actor.h
+++ b/clutter/clutter/clutter-actor.h
@@ -924,6 +924,9 @@ GList * clutter_actor_peek_stage_views (ClutterActor *self);
 CLUTTER_EXPORT
 void clutter_actor_invalidate_transform (ClutterActor *self);
 
+CLUTTER_EXPORT
+ClutterFrameClock * clutter_actor_pick_frame_clock (ClutterActor *self);
+
 G_END_DECLS
 
 #endif /* __CLUTTER_ACTOR_H__ */
diff --git a/clutter/clutter/clutter-animatable.c b/clutter/clutter/clutter-animatable.c
index e14012c5d8680fa837193082ebdfd8202623c00d..8ea28de7710c03f781108b92cc43098de4ffe45b 100644
--- a/clutter/clutter/clutter-animatable.c
+++ b/clutter/clutter/clutter-animatable.c
@@ -194,3 +194,25 @@ clutter_animatable_interpolate_value (ClutterAnimatable *animatable,
   else
     return clutter_interval_compute_value (interval, progress, value);
 }
+
+/**
+ * clutter_animatable_get_actor:
+ * @animatable: a #ClutterAnimatable
+ *
+ * Get animated actor.
+ *
+ * Return value: (transfer none): a #ClutterActor
+ */
+ClutterActor *
+clutter_animatable_get_actor (ClutterAnimatable *animatable)
+{
+  ClutterAnimatableInterface *iface;
+
+  g_return_val_if_fail (CLUTTER_IS_ANIMATABLE (animatable), NULL);
+
+  iface = CLUTTER_ANIMATABLE_GET_IFACE (animatable);
+
+  g_return_val_if_fail (iface->get_actor, NULL);
+
+  return iface->get_actor (animatable);
+}
diff --git a/clutter/clutter/clutter-animatable.h b/clutter/clutter/clutter-animatable.h
index d03e0589de2c32ddd1fcef3b7a15da82f485beb9..5b18f37959066c534febcb66f08a7565e546f327 100644
--- a/clutter/clutter/clutter-animatable.h
+++ b/clutter/clutter/clutter-animatable.h
@@ -50,6 +50,7 @@ G_DECLARE_INTERFACE (ClutterAnimatable, clutter_animatable,
  *   animatable property
  * @interpolate_value: virtual function for interpolating the progress
  *   of a property
+ * @get_actor: virtual function for getting associated actor
  *
  * Since: 1.0
  */
@@ -72,6 +73,7 @@ struct _ClutterAnimatableInterface
                                      ClutterInterval   *interval,
                                      gdouble            progress,
                                      GValue            *value);
+  ClutterActor * (* get_actor)      (ClutterAnimatable *animatable);
 };
 
 CLUTTER_EXPORT
@@ -92,6 +94,9 @@ gboolean    clutter_animatable_interpolate_value (ClutterAnimatable *animatable,
                                                   gdouble            progress,
                                                   GValue            *value);
 
+CLUTTER_EXPORT
+ClutterActor * clutter_animatable_get_actor      (ClutterAnimatable *animatable);
+
 G_END_DECLS
 
 #endif /* __CLUTTER_ANIMATABLE_H__ */
diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
new file mode 100644
index 0000000000000000000000000000000000000000..9c39ade38a13bbf6842aff3e770000f700b33148
--- /dev/null
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2019 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "clutter-build-config.h"
+
+#include "clutter/clutter-frame-clock.h"
+
+#include "clutter/clutter-main.h"
+#include "clutter/clutter-private.h"
+#include "clutter/clutter-timeline-private.h"
+#include "cogl/cogl-trace.h"
+
+enum
+{
+  DESTROY,
+
+  N_SIGNALS
+};
+
+static guint signals[N_SIGNALS];
+
+/* Wait 2ms after vblank before starting to draw next frame */
+#define SYNC_DELAY_US ms2us (2)
+
+typedef struct _ClutterFrameListener
+{
+  const ClutterFrameListenerIface *iface;
+  gpointer user_data;
+} ClutterFrameListener;
+
+typedef struct _ClutterClockSource
+{
+  GSource source;
+
+  ClutterFrameClock *frame_clock;
+} ClutterClockSource;
+
+typedef enum _ClutterFrameClockState
+{
+  CLUTTER_FRAME_CLOCK_STATE_INIT,
+  CLUTTER_FRAME_CLOCK_STATE_IDLE,
+  CLUTTER_FRAME_CLOCK_STATE_SCHEDULED,
+  CLUTTER_FRAME_CLOCK_STATE_DISPATCHING,
+  CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED,
+} ClutterFrameClockState;
+
+struct _ClutterFrameClock
+{
+  GObject parent;
+
+  float refresh_rate;
+  ClutterFrameListener listener;
+
+  GSource *source;
+
+  int64_t frame_count;
+
+  ClutterFrameClockState state;
+  int64_t last_presentation_time_us;
+
+  gboolean is_next_presentation_time_valid;
+  int64_t next_presentation_time_us;
+
+  gboolean pending_reschedule;
+  gboolean pending_reschedule_now;
+
+  int inhibit_count;
+
+  GList *timelines;
+};
+
+G_DEFINE_TYPE (ClutterFrameClock, clutter_frame_clock,
+               G_TYPE_OBJECT)
+
+float
+clutter_frame_clock_get_refresh_rate (ClutterFrameClock *frame_clock)
+{
+  return frame_clock->refresh_rate;
+}
+
+void
+clutter_frame_clock_add_timeline (ClutterFrameClock *frame_clock,
+                                  ClutterTimeline   *timeline)
+{
+  gboolean is_first;
+
+  if (g_list_find (frame_clock->timelines, timeline))
+    return;
+
+  is_first = !frame_clock->timelines;
+
+  frame_clock->timelines = g_list_prepend (frame_clock->timelines, timeline);
+
+  if (is_first)
+    clutter_frame_clock_schedule_update (frame_clock);
+}
+
+void
+clutter_frame_clock_remove_timeline (ClutterFrameClock *frame_clock,
+                                     ClutterTimeline   *timeline)
+{
+  frame_clock->timelines = g_list_remove (frame_clock->timelines, timeline);
+}
+
+static void
+advance_timelines (ClutterFrameClock *frame_clock,
+                   int64_t            time_us)
+{
+  GList *timelines;
+  GList *l;
+
+  /* we protect ourselves from timelines being removed during
+   * the advancement by other timelines by copying the list of
+   * timelines, taking a reference on them, iterating over the
+   * copied list and then releasing the reference.
+   *
+   * we cannot simply take a reference on the timelines and still
+   * use the list held by the master clock because the do_tick()
+   * might result in the creation of a new timeline, which gets
+   * added at the end of the list with no reference increase and
+   * thus gets disposed at the end of the iteration.
+   *
+   * this implies that a newly added timeline will not be advanced
+   * by this clock iteration, which is perfectly fine since we're
+   * in its first cycle.
+   *
+   * we also cannot steal the frame clock timelines list because
+   * a timeline might be removed as the direct result of do_tick()
+   * and remove_timeline() would not find the timeline, failing
+   * and leaving a dangling pointer behind.
+   */
+
+  timelines = g_list_copy (frame_clock->timelines);
+  g_list_foreach (timelines, (GFunc) g_object_ref, NULL);
+
+  for (l = timelines; l; l = l->next)
+    {
+      ClutterTimeline *timeline = l->data;
+
+      _clutter_timeline_do_tick (timeline, time_us / 1000);
+    }
+
+  g_list_free_full (timelines, g_object_unref);
+}
+
+static void
+maybe_reschedule_update (ClutterFrameClock *frame_clock)
+{
+  if (frame_clock->pending_reschedule ||
+      frame_clock->timelines)
+    {
+      frame_clock->pending_reschedule = FALSE;
+
+      if (frame_clock->pending_reschedule_now)
+        {
+          frame_clock->pending_reschedule_now = FALSE;
+          clutter_frame_clock_schedule_update_now (frame_clock);
+        }
+      else
+        {
+          clutter_frame_clock_schedule_update (frame_clock);
+        }
+    }
+}
+
+void
+clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
+                                      ClutterFrameInfo  *frame_info)
+{
+  int64_t presentation_time_us = frame_info->presentation_time;
+
+  if (presentation_time_us > frame_clock->last_presentation_time_us ||
+      ((presentation_time_us - frame_clock->last_presentation_time_us) >
+       INT64_MAX / 2))
+    {
+      frame_clock->last_presentation_time_us = presentation_time_us;
+    }
+  else
+    {
+      g_warning_once ("Bogus presentation time %" G_GINT64_FORMAT
+                      " travelled back in time, using current time.",
+                      presentation_time_us);
+      frame_clock->last_presentation_time_us = g_get_monotonic_time ();
+    }
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      g_warn_if_reached ();
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+      maybe_reschedule_update (frame_clock);
+      break;
+    }
+}
+
+static void
+calculate_next_update_time_us (ClutterFrameClock *frame_clock,
+                               int64_t           *out_next_update_time_us,
+                               int64_t           *out_next_presentation_time_us)
+{
+  int64_t last_presentation_time_us;
+  int64_t now_us;
+  float refresh_rate;
+  int64_t refresh_interval_us;
+  int64_t min_render_time_allowed_us;
+  int64_t max_render_time_allowed_us;
+  int64_t last_next_presentation_time_us;
+  int64_t time_since_last_next_presentation_time_us;
+  int64_t next_presentation_time_us;
+  int64_t next_update_time_us;
+
+  now_us = g_get_monotonic_time ();
+
+  refresh_rate = frame_clock->refresh_rate;
+  refresh_interval_us = (int64_t) (0.5 + G_USEC_PER_SEC / refresh_rate);
+
+  min_render_time_allowed_us = refresh_interval_us / 2;
+  max_render_time_allowed_us = refresh_interval_us - SYNC_DELAY_US;
+
+  if (min_render_time_allowed_us > max_render_time_allowed_us)
+    min_render_time_allowed_us = max_render_time_allowed_us;
+
+  last_presentation_time_us = frame_clock->last_presentation_time_us;
+  next_presentation_time_us = last_presentation_time_us + refresh_interval_us;
+
+  /* Skip ahead to get close to the actual next presentation time. */
+  if (next_presentation_time_us < now_us)
+    {
+      int64_t logical_clock_offset_us;
+      int64_t logical_clock_phase_us;
+      int64_t hw_clock_offset_us;
+
+      logical_clock_offset_us = now_us % refresh_interval_us;
+      logical_clock_phase_us = now_us - logical_clock_offset_us;
+      hw_clock_offset_us = last_presentation_time_us % refresh_interval_us;
+
+      next_presentation_time_us = logical_clock_phase_us + hw_clock_offset_us;
+    }
+
+  /* Skip one interval if we got an early presented event. */
+  last_next_presentation_time_us = frame_clock->next_presentation_time_us;
+  time_since_last_next_presentation_time_us =
+      next_presentation_time_us - last_next_presentation_time_us;
+  if (frame_clock->is_next_presentation_time_valid &&
+      time_since_last_next_presentation_time_us < (refresh_interval_us / 2))
+    {
+      next_presentation_time_us =
+        frame_clock->next_presentation_time_us + refresh_interval_us;
+    }
+
+  while (next_presentation_time_us < now_us + min_render_time_allowed_us)
+    next_presentation_time_us += refresh_interval_us;
+
+  next_update_time_us = next_presentation_time_us - max_render_time_allowed_us;
+
+  *out_next_update_time_us = next_update_time_us;
+  *out_next_presentation_time_us = next_presentation_time_us;
+}
+
+void
+clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
+{
+  frame_clock->inhibit_count++;
+
+  if (frame_clock->inhibit_count == 1)
+    {
+      switch (frame_clock->state)
+        {
+        case CLUTTER_FRAME_CLOCK_STATE_INIT:
+        case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+          break;
+        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+          frame_clock->pending_reschedule = TRUE;
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+          break;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+        case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+          break;
+        }
+
+      g_source_set_ready_time (frame_clock->source, -1);
+    }
+}
+
+void
+clutter_frame_clock_uninhibit (ClutterFrameClock *frame_clock)
+{
+  g_return_if_fail (frame_clock->inhibit_count > 0);
+
+  frame_clock->inhibit_count--;
+
+  if (frame_clock->inhibit_count == 0)
+    maybe_reschedule_update (frame_clock);
+}
+
+void
+clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
+{
+  int64_t next_update_time_us = -1;
+
+  if (frame_clock->inhibit_count > 0)
+    {
+      frame_clock->pending_reschedule = TRUE;
+      frame_clock->pending_reschedule_now = TRUE;
+      return;
+    }
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+      next_update_time_us = g_get_monotonic_time ();
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      return;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      frame_clock->pending_reschedule = TRUE;
+      frame_clock->pending_reschedule_now = TRUE;
+      return;
+    }
+
+  g_warn_if_fail (next_update_time_us != -1);
+
+  g_source_set_ready_time (frame_clock->source, next_update_time_us);
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+  frame_clock->is_next_presentation_time_valid = FALSE;
+}
+
+void
+clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
+{
+  int64_t next_update_time_us = -1;
+
+  if (frame_clock->inhibit_count > 0)
+    {
+      frame_clock->pending_reschedule = TRUE;
+      return;
+    }
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+      next_update_time_us = g_get_monotonic_time ();
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+      calculate_next_update_time_us (frame_clock,
+                                     &next_update_time_us,
+                                     &frame_clock->next_presentation_time_us);
+      frame_clock->is_next_presentation_time_valid = TRUE;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      return;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      frame_clock->pending_reschedule = TRUE;
+      return;
+    }
+
+  g_warn_if_fail (next_update_time_us != -1);
+
+  g_source_set_ready_time (frame_clock->source, next_update_time_us);
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+}
+
+static void
+clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
+                              int64_t            time_us)
+{
+  int64_t frame_count;
+  ClutterFrameResult result;
+
+  COGL_TRACE_BEGIN_SCOPED (ClutterFrameCLockDispatch, "Frame Clock (dispatch)");
+
+  g_source_set_ready_time (frame_clock->source, -1);
+
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHING;
+
+  frame_count = frame_clock->frame_count++;
+
+  COGL_TRACE_BEGIN (ClutterFrameClockEvents, "Frame Clock (before frame)");
+  if (frame_clock->listener.iface->before_frame)
+    {
+      frame_clock->listener.iface->before_frame (frame_clock,
+                                                 frame_count,
+                                                 frame_clock->listener.user_data);
+    }
+  COGL_TRACE_END (ClutterFrameClockEvents);
+
+  COGL_TRACE_BEGIN (ClutterFrameClockTimelines, "Frame Clock (timelines)");
+  advance_timelines (frame_clock, time_us);
+  COGL_TRACE_END (ClutterFrameClockTimelines);
+
+  COGL_TRACE_BEGIN (ClutterFrameClockFrame, "Frame Clock (frame)");
+  result = frame_clock->listener.iface->frame (frame_clock,
+                                               frame_count,
+                                               time_us,
+                                               frame_clock->listener.user_data);
+  COGL_TRACE_END (ClutterFrameClockFrame);
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      g_warn_if_reached ();
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+      switch (result)
+        {
+        case CLUTTER_FRAME_RESULT_PENDING_PRESENTED:
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED;
+          break;
+        case CLUTTER_FRAME_RESULT_IDLE:
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+          maybe_reschedule_update (frame_clock);
+          break;
+        }
+      break;
+    }
+}
+
+static gboolean
+frame_clock_source_dispatch (GSource     *source,
+                             GSourceFunc  callback,
+                             gpointer     user_data)
+{
+  ClutterClockSource *clock_source = (ClutterClockSource *) source;
+  ClutterFrameClock *frame_clock = clock_source->frame_clock;
+  int64_t dispatch_time_us;
+
+  dispatch_time_us = g_source_get_time (source);
+  clutter_frame_clock_dispatch (frame_clock, dispatch_time_us);
+
+  return G_SOURCE_CONTINUE;
+}
+
+static GSourceFuncs frame_clock_source_funcs = {
+  NULL,
+  NULL,
+  frame_clock_source_dispatch,
+  NULL
+};
+
+static void
+init_frame_clock_source (ClutterFrameClock *frame_clock)
+{
+  GSource *source;
+  ClutterClockSource *clock_source;
+  g_autofree char *name = NULL;
+
+  source = g_source_new (&frame_clock_source_funcs, sizeof (ClutterClockSource));
+  clock_source = (ClutterClockSource *) source;
+
+  name = g_strdup_printf ("Clutter frame clock (%p)", frame_clock);
+  g_source_set_name (source, name);
+  g_source_set_priority (source, CLUTTER_PRIORITY_REDRAW);
+  g_source_set_can_recurse (source, FALSE);
+  clock_source->frame_clock = frame_clock;
+
+  frame_clock->source = source;
+  g_source_attach (source, NULL);
+}
+
+ClutterFrameClock *
+clutter_frame_clock_new (float                            refresh_rate,
+                         const ClutterFrameListenerIface *iface,
+                         gpointer                         user_data)
+{
+  ClutterFrameClock *frame_clock;
+
+  g_assert_cmpfloat (refresh_rate, >, 0.0);
+
+  frame_clock = g_object_new (CLUTTER_TYPE_FRAME_CLOCK, NULL);
+
+  frame_clock->listener.iface = iface;
+  frame_clock->listener.user_data = user_data;
+
+  init_frame_clock_source (frame_clock);
+
+  frame_clock->refresh_rate = refresh_rate;
+
+  return frame_clock;
+}
+
+void
+clutter_frame_clock_destroy (ClutterFrameClock *frame_clock)
+{
+  g_object_run_dispose (G_OBJECT (frame_clock));
+  g_object_unref (frame_clock);
+}
+
+static void
+clutter_frame_clock_dispose (GObject *object)
+{
+ClutterFrameClock *frame_clock = CLUTTER_FRAME_CLOCK (object);
+
+  if (frame_clock->source)
+    {
+      g_signal_emit (frame_clock, signals[DESTROY], 0);
+      g_source_destroy (frame_clock->source);
+      g_clear_pointer (&frame_clock->source, g_source_unref);
+    }
+
+  G_OBJECT_CLASS (clutter_frame_clock_parent_class)->dispose (object);
+}
+
+static void
+clutter_frame_clock_init (ClutterFrameClock *frame_clock)
+{
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_INIT;
+}
+
+static void
+clutter_frame_clock_class_init (ClutterFrameClockClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = clutter_frame_clock_dispose;
+
+  signals[DESTROY] =
+    g_signal_new (I_("destroy"),
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE,
+                  0);
+}
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
new file mode 100644
index 0000000000000000000000000000000000000000..3c9ab7b5ad2ce7d77d248dbbb796eec0dc7df9c0
--- /dev/null
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2019 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CLUTTER_FRAME_CLOCK_H
+#define CLUTTER_FRAME_CLOCK_H
+
+#if !defined(__CLUTTER_H_INSIDE__) && !defined(CLUTTER_COMPILATION)
+#error "Only <clutter/clutter.h> can be included directly."
+#endif
+
+#include <glib.h>
+#include <glib-object.h>
+#include <stdint.h>
+
+#include "clutter/clutter-types.h"
+
+typedef enum _ClutterFrameResult
+{
+  CLUTTER_FRAME_RESULT_PENDING_PRESENTED,
+  CLUTTER_FRAME_RESULT_IDLE,
+} ClutterFrameResult;
+
+#define CLUTTER_TYPE_FRAME_CLOCK (clutter_frame_clock_get_type ())
+CLUTTER_EXPORT
+G_DECLARE_FINAL_TYPE (ClutterFrameClock, clutter_frame_clock,
+                      CLUTTER, FRAME_CLOCK,
+                      GObject)
+
+typedef struct _ClutterFrameListenerIface
+{
+  void (* before_frame) (ClutterFrameClock *frame_clock,
+                         int64_t            frame_count,
+                         gpointer           user_data);
+  ClutterFrameResult (* frame) (ClutterFrameClock *frame_clock,
+                                int64_t            frame_count,
+                                int64_t            time_us,
+                                gpointer           user_data);
+} ClutterFrameListenerIface;
+
+CLUTTER_EXPORT
+ClutterFrameClock * clutter_frame_clock_new (float                            refresh_rate,
+                                             const ClutterFrameListenerIface *iface,
+                                             gpointer                         user_data);
+
+CLUTTER_EXPORT
+void clutter_frame_clock_destroy (ClutterFrameClock *frame_clock);
+
+CLUTTER_EXPORT
+void clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
+                                           ClutterFrameInfo  *frame_info);
+
+CLUTTER_EXPORT
+void clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock);
+
+CLUTTER_EXPORT
+void clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock);
+
+CLUTTER_EXPORT
+void clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock);
+
+CLUTTER_EXPORT
+void clutter_frame_clock_uninhibit (ClutterFrameClock *frame_clock);
+
+void clutter_frame_clock_add_timeline (ClutterFrameClock *frame_clock,
+                                       ClutterTimeline   *timeline);
+
+void clutter_frame_clock_remove_timeline (ClutterFrameClock *frame_clock,
+                                          ClutterTimeline   *timeline);
+
+CLUTTER_EXPORT
+float clutter_frame_clock_get_refresh_rate (ClutterFrameClock *frame_clock);
+
+#endif /* CLUTTER_FRAME_CLOCK_H */
diff --git a/clutter/clutter/clutter-main.c b/clutter/clutter/clutter-main.c
index 0da859d60021825a356a27e0dbf5abc1f694cede..e78a33e2d4a3c70cea5a23286bcb8a0935bc4df9 100644
--- a/clutter/clutter/clutter-main.c
+++ b/clutter/clutter/clutter-main.c
@@ -61,7 +61,6 @@
 #include "clutter-input-pointer-a11y-private.h"
 #include "clutter-graphene.h"
 #include "clutter-main.h"
-#include "clutter-master-clock.h"
 #include "clutter-mutter.h"
 #include "clutter-paint-node-private.h"
 #include "clutter-private.h"
@@ -83,10 +82,6 @@
 
 /* main context */
 static ClutterMainContext *ClutterCntx       = NULL;
-G_LOCK_DEFINE_STATIC (ClutterCntx);
-
-/* main lock and locking/unlocking functions */
-static GMutex clutter_threads_mutex;
 
 /* command line options */
 static gboolean clutter_is_initialized       = FALSE;
@@ -145,12 +140,6 @@ static const GDebugKey clutter_paint_debug_keys[] = {
   { "damage-region", CLUTTER_DEBUG_PAINT_DAMAGE_REGION },
 };
 
-static inline void
-clutter_threads_init_default (void)
-{
-  g_mutex_init (&clutter_threads_mutex);
-}
-
 #define ENVIRONMENT_GROUP       "Environment"
 #define DEBUG_GROUP             "Debug"
 
@@ -519,11 +508,7 @@ clutter_main (void)
   main_loops = g_slist_prepend (main_loops, loop);
 
   if (g_main_loop_is_running (main_loops->data))
-    {
-      _clutter_threads_release_lock ();
-      g_main_loop_run (loop);
-      _clutter_threads_acquire_lock ();
-    }
+    g_main_loop_run (loop);
 
   main_loops = g_slist_remove (main_loops, loop);
 
@@ -540,13 +525,9 @@ _clutter_threads_dispatch (gpointer data)
   ClutterThreadsDispatch *dispatch = data;
   gboolean ret = FALSE;
 
-  _clutter_threads_acquire_lock ();
-
   if (!g_source_is_destroyed (g_main_current_source ()))
     ret = dispatch->func (dispatch->data);
 
-  _clutter_threads_release_lock ();
-
   return ret;
 }
 
@@ -771,40 +752,6 @@ clutter_threads_add_timeout (guint       interval,
                                            NULL);
 }
 
-void
-_clutter_threads_acquire_lock (void)
-{
-  g_mutex_lock (&clutter_threads_mutex);
-}
-
-void
-_clutter_threads_release_lock (void)
-{
-  /* we need to trylock here, in case the lock hasn't been acquired; on
-   * various systems trying to release a mutex that hasn't been acquired
-   * will cause a run-time error. trylock() will either fail, in which
-   * case we can release the lock we own; or it will succeeds, in which
-   * case we need to release the lock we just acquired. so we ignore the
-   * returned value.
-   *
-   * see: https://bugs.gnome.org/679439
-   */
-  g_mutex_trylock (&clutter_threads_mutex);
-  g_mutex_unlock (&clutter_threads_mutex);
-}
-
-void
-_clutter_context_lock (void)
-{
-  G_LOCK (ClutterCntx);
-}
-
-void
-_clutter_context_unlock (void)
-{
-  G_UNLOCK (ClutterCntx);
-}
-
 gboolean
 _clutter_context_is_initialized (void)
 {
@@ -814,8 +761,8 @@ _clutter_context_is_initialized (void)
   return ClutterCntx->is_initialized;
 }
 
-static ClutterMainContext *
-clutter_context_get_default_unlocked (void)
+ClutterMainContext *
+_clutter_context_get_default (void)
 {
   if (G_UNLIKELY (ClutterCntx == NULL))
     {
@@ -846,20 +793,6 @@ clutter_context_get_default_unlocked (void)
   return ClutterCntx;
 }
 
-ClutterMainContext *
-_clutter_context_get_default (void)
-{
-  ClutterMainContext *retval;
-
-  _clutter_context_lock ();
-
-  retval = clutter_context_get_default_unlocked ();
-
-  _clutter_context_unlock ();
-
-  return retval;
-}
-
 static gboolean
 clutter_arg_direction_cb (const char *key,
                           const char *value,
@@ -2170,9 +2103,6 @@ clutter_base_init (void)
       g_type_init ();
 #endif
 
-      /* initialise the Big Clutter Lock™ if necessary */
-      clutter_threads_init_default ();
-
       clutter_graphene_init ();
     }
 }
@@ -2240,9 +2170,7 @@ clutter_threads_remove_repaint_func (guint handle_id)
 
   g_return_if_fail (handle_id > 0);
 
-  _clutter_context_lock ();
-
-  context = clutter_context_get_default_unlocked ();
+  context = _clutter_context_get_default ();
   l = context->repaint_funcs;
   while (l != NULL)
     {
@@ -2265,8 +2193,6 @@ clutter_threads_remove_repaint_func (guint handle_id)
 
       l = l->next;
     }
-
-  _clutter_context_unlock ();
 }
 
 /**
@@ -2365,9 +2291,7 @@ clutter_threads_add_repaint_func_full (ClutterRepaintFlags flags,
 
   g_return_val_if_fail (func != NULL, 0);
 
-  _clutter_context_lock ();
-
-  context = clutter_context_get_default_unlocked ();
+  context = _clutter_context_get_default ();
 
   repaint_func = g_slice_new (ClutterRepaintFunction);
 
@@ -2381,8 +2305,6 @@ clutter_threads_add_repaint_func_full (ClutterRepaintFlags flags,
   context->repaint_funcs = g_list_prepend (context->repaint_funcs,
                                            repaint_func);
 
-  _clutter_context_unlock ();
-
   return repaint_func->id;
 }
 
diff --git a/clutter/clutter/clutter-master-clock-default.c b/clutter/clutter/clutter-master-clock-default.c
deleted file mode 100644
index a34454a3a015c330085036f181eba3f02c27dc53..0000000000000000000000000000000000000000
--- a/clutter/clutter/clutter-master-clock-default.c
+++ /dev/null
@@ -1,618 +0,0 @@
-/*
- * Clutter.
- *
- * An OpenGL based 'interactive canvas' library.
- *
- * Authored By: Emmanuele Bassi <ebassi@linux.intel.com>
- *
- * Copyright (C) 2009  Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
- * SECTION:clutter-master-clock-default
- * @short_description: The default master clock for all animations
- *
- * The #ClutterMasterClockDefault class is the default implementation
- * of #ClutterMasterClock.
- */
-
-#include "clutter-build-config.h"
-
-#include <cogl/cogl.h>
-
-#include "clutter-master-clock.h"
-#include "clutter-master-clock-default.h"
-#include "clutter-debug.h"
-#include "clutter-private.h"
-#include "clutter-stage-manager-private.h"
-#include "clutter-stage-private.h"
-
-#ifdef CLUTTER_ENABLE_DEBUG
-#define clutter_warn_if_over_budget(master_clock,start_time,section)    G_STMT_START  { \
-  gint64 __delta = g_get_monotonic_time () - start_time;                                \
-  gint64 __budget = master_clock->remaining_budget;                                     \
-  if (__budget > 0 && __delta >= __budget) {                                            \
-    _clutter_diagnostic_message ("%s took %" G_GINT64_FORMAT " microseconds "           \
-                                 "more than the remaining budget of %" G_GINT64_FORMAT  \
-                                 " microseconds",                                       \
-                                 section, __delta - __budget, __budget);                \
-  }                                                                     } G_STMT_END
-#else
-#define clutter_warn_if_over_budget(master_clock,start_time,section)
-#endif
-
-typedef struct _ClutterClockSource              ClutterClockSource;
-
-struct _ClutterMasterClockDefault
-{
-  GObject parent_instance;
-
-  /* the list of timelines handled by the clock */
-  GSList *timelines;
-
-  /* the current state of the clock, in usecs */
-  gint64 cur_tick;
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  gint64 frame_budget;
-  gint64 remaining_budget;
-#endif
-
-  /* an idle source, used by the Master Clock to queue
-   * a redraw on the stage and drive the animations
-   */
-  GSource *source;
-
-  guint ensure_next_iteration : 1;
-
-  guint paused : 1;
-};
-
-struct _ClutterClockSource
-{
-  GSource source;
-
-  ClutterMasterClockDefault *master_clock;
-};
-
-static gboolean clutter_clock_prepare  (GSource     *source,
-                                        gint        *timeout);
-static gboolean clutter_clock_check    (GSource     *source);
-static gboolean clutter_clock_dispatch (GSource     *source,
-                                        GSourceFunc  callback,
-                                        gpointer     user_data);
-
-static GSourceFuncs clock_funcs = {
-  clutter_clock_prepare,
-  clutter_clock_check,
-  clutter_clock_dispatch,
-  NULL
-};
-
-static void
-clutter_master_clock_iface_init (ClutterMasterClockInterface *iface);
-
-#define clutter_master_clock_default_get_type   _clutter_master_clock_default_get_type
-
-G_DEFINE_TYPE_WITH_CODE (ClutterMasterClockDefault,
-                         clutter_master_clock_default,
-                         G_TYPE_OBJECT,
-                         G_IMPLEMENT_INTERFACE (CLUTTER_TYPE_MASTER_CLOCK,
-                                                clutter_master_clock_iface_init));
-
-/*
- * master_clock_is_running:
- * @master_clock: a #ClutterMasterClock
- *
- * Checks if we should currently be advancing timelines or redrawing
- * stages.
- *
- * Return value: %TRUE if the #ClutterMasterClock has at least
- *   one running timeline
- */
-static gboolean
-master_clock_is_running (ClutterMasterClockDefault *master_clock)
-{
-  ClutterStageManager *stage_manager = clutter_stage_manager_get_default ();
-  const GSList *stages, *l;
-
-  stages = clutter_stage_manager_peek_stages (stage_manager);
-
-  if (master_clock->paused)
-    return FALSE;
-
-  if (master_clock->timelines)
-    return TRUE;
-
-  for (l = stages; l; l = l->next)
-    {
-      if (clutter_actor_is_mapped (l->data) &&
-          (_clutter_stage_has_queued_events (l->data) ||
-           _clutter_stage_needs_update (l->data)))
-        return TRUE;
-    }
-
-  if (master_clock->ensure_next_iteration)
-    {
-      master_clock->ensure_next_iteration = FALSE;
-      return TRUE;
-    }
-
-  return FALSE;
-}
-
-static gint
-master_clock_get_swap_wait_time (ClutterMasterClockDefault *master_clock)
-{
-  ClutterStageManager *stage_manager = clutter_stage_manager_get_default ();
-  const GSList *stages, *l;
-  gint64 min_update_time = -1;
-
-  stages = clutter_stage_manager_peek_stages (stage_manager);
-
-  for (l = stages; l != NULL; l = l->next)
-    {
-      gint64 update_time = _clutter_stage_get_update_time (l->data);
-      if (min_update_time == -1 ||
-          (update_time != -1 && update_time < min_update_time))
-        min_update_time = update_time;
-    }
-
-  if (min_update_time == -1)
-    {
-      return -1;
-    }
-  else
-    {
-      gint64 now = g_source_get_time (master_clock->source);
-      if (min_update_time < now)
-        {
-          return 0;
-        }
-      else
-        {
-          gint64 delay_us = min_update_time - now;
-          return (delay_us + 999) / 1000;
-        }
-    }
-}
-
-static void
-master_clock_schedule_stage_updates (ClutterMasterClockDefault *master_clock)
-{
-  ClutterStageManager *stage_manager = clutter_stage_manager_get_default ();
-  const GSList *stages, *l;
-
-  stages = clutter_stage_manager_peek_stages (stage_manager);
-
-  for (l = stages; l != NULL; l = l->next)
-    clutter_stage_schedule_update (l->data);
-}
-
-static GSList *
-master_clock_list_ready_stages (ClutterMasterClockDefault *master_clock)
-{
-  ClutterStageManager *stage_manager = clutter_stage_manager_get_default ();
-  const GSList *stages, *l;
-  GSList *result;
-
-  stages = clutter_stage_manager_peek_stages (stage_manager);
-
-  result = NULL;
-  for (l = stages; l != NULL; l = l->next)
-    {
-      gint64 update_time = _clutter_stage_get_update_time (l->data);
-      /* We carefully avoid to update stages that aren't mapped, because
-       * they have nothing to render and this could cause a deadlock with
-       * some of the SwapBuffers implementations (in particular
-       * GLX_INTEL_swap_event is not emitted if nothing was rendered).
-       *
-       * Also, if a stage has a swap-buffers pending we don't want to draw
-       * to it in case the driver may block the CPU while it waits for the
-       * next backbuffer to become available.
-       *
-       * TODO: We should be able to identify if we are running triple or N
-       * buffered and in these cases we can still draw if there is 1 swap
-       * pending so we can hopefully always be ready to swap for the next
-       * vblank and really match the vsync frequency.
-       */
-      if (clutter_actor_is_mapped (l->data) &&
-          update_time != -1 && update_time <= master_clock->cur_tick)
-        result = g_slist_prepend (result, g_object_ref (l->data));
-    }
-
-  return g_slist_reverse (result);
-}
-
-static void
-master_clock_reschedule_stage_updates (ClutterMasterClockDefault *master_clock,
-                                       GSList                    *stages)
-{
-  const GSList *l;
-
-  for (l = stages; l != NULL; l = l->next)
-    {
-      /* Clear the old update time */
-      _clutter_stage_clear_update_time (l->data);
-
-      /* And if there is still work to be done, schedule a new one */
-      if (master_clock->timelines ||
-          _clutter_stage_has_queued_events (l->data) ||
-          _clutter_stage_needs_update (l->data))
-        clutter_stage_schedule_update (l->data);
-    }
-}
-
-/*
- * master_clock_next_frame_delay:
- * @master_clock: a #ClutterMasterClock
- *
- * Computes the number of delay before we need to draw the next frame.
- *
- * Return value: -1 if there is no next frame pending, otherwise the
- *  number of millseconds before the we need to draw the next frame
- */
-static gint
-master_clock_next_frame_delay (ClutterMasterClockDefault *master_clock)
-{
-  if (!master_clock_is_running (master_clock))
-    return -1;
-
-  /* If all of the stages are busy waiting for a swap-buffers to complete
-   * then we wait for one to be ready.. */
-  return master_clock_get_swap_wait_time (master_clock);
-}
-
-static void
-master_clock_process_events (ClutterMasterClockDefault *master_clock,
-                             GSList                    *stages)
-{
-  GSList *l;
-#ifdef CLUTTER_ENABLE_DEBUG
-  gint64 start = g_get_monotonic_time ();
-#endif
-
-  /* Process queued events */
-  for (l = stages; l != NULL; l = l->next)
-    _clutter_stage_process_queued_events (l->data);
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  if (_clutter_diagnostic_enabled ())
-    clutter_warn_if_over_budget (master_clock, start, "Event processing");
-
-  master_clock->remaining_budget -= (g_get_monotonic_time () - start);
-#endif
-}
-
-/*
- * master_clock_advance_timelines:
- * @master_clock: a #ClutterMasterClock
- *
- * Advances all the timelines held by the master clock. This function
- * should be called before calling _clutter_stage_do_update() to
- * make sure that all the timelines are advanced and the scene is updated.
- */
-static void
-master_clock_advance_timelines (ClutterMasterClockDefault *master_clock)
-{
-  GSList *timelines, *l;
-#ifdef CLUTTER_ENABLE_DEBUG
-  gint64 start = g_get_monotonic_time ();
-#endif
-
-  /* we protect ourselves from timelines being removed during
-   * the advancement by other timelines by copying the list of
-   * timelines, taking a reference on them, iterating over the
-   * copied list and then releasing the reference.
-   *
-   * we cannot simply take a reference on the timelines and still
-   * use the list held by the master clock because the do_tick()
-   * might result in the creation of a new timeline, which gets
-   * added at the end of the list with no reference increase and
-   * thus gets disposed at the end of the iteration.
-   *
-   * this implies that a newly added timeline will not be advanced
-   * by this clock iteration, which is perfectly fine since we're
-   * in its first cycle.
-   *
-   * we also cannot steal the master clock timelines list because
-   * a timeline might be removed as the direct result of do_tick()
-   * and remove_timeline() would not find the timeline, failing
-   * and leaving a dangling pointer behind.
-   */
-  timelines = g_slist_copy (master_clock->timelines);
-  g_slist_foreach (timelines, (GFunc) g_object_ref, NULL);
-
-  for (l = timelines; l != NULL; l = l->next)
-    _clutter_timeline_do_tick (l->data, master_clock->cur_tick / 1000);
-
-  g_slist_free_full (timelines, g_object_unref);
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  if (_clutter_diagnostic_enabled ())
-    clutter_warn_if_over_budget (master_clock, start, "Animations");
-
-  master_clock->remaining_budget -= (g_get_monotonic_time () - start);
-#endif
-}
-
-static gboolean
-master_clock_update_stages (ClutterMasterClockDefault *master_clock,
-                            GSList                    *stages)
-{
-  gboolean stages_updated = FALSE;
-  GSList *l;
-#ifdef CLUTTER_ENABLE_DEBUG
-  gint64 start = g_get_monotonic_time ();
-#endif
-
-  _clutter_run_repaint_functions (CLUTTER_REPAINT_FLAGS_PRE_PAINT);
-
-  /* Update any stage that needs redraw/relayout after the clock
-   * is advanced.
-   */
-  for (l = stages; l != NULL; l = l->next)
-    stages_updated |= _clutter_stage_do_update (l->data);
-
-  _clutter_run_repaint_functions (CLUTTER_REPAINT_FLAGS_POST_PAINT);
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  if (_clutter_diagnostic_enabled ())
-    clutter_warn_if_over_budget (master_clock, start, "Updating the stage");
-
-  master_clock->remaining_budget -= (g_get_monotonic_time () - start);
-#endif
-
-  return stages_updated;
-}
-
-/*
- * clutter_clock_source_new:
- * @master_clock: a #ClutterMasterClock for the source
- *
- * The #ClutterClockSource is an idle GSource that will queue a redraw
- * if @master_clock has at least a running #ClutterTimeline. The redraw
- * will cause @master_clock to advance all timelines, thus advancing all
- * animations as well.
- *
- * Return value: the newly created #GSource
- */
-static GSource *
-clutter_clock_source_new (ClutterMasterClockDefault *master_clock)
-{
-  GSource *source = g_source_new (&clock_funcs, sizeof (ClutterClockSource));
-  ClutterClockSource *clock_source = (ClutterClockSource *) source;
-
-  g_source_set_name (source, "Clutter master clock");
-  g_source_set_priority (source, CLUTTER_PRIORITY_REDRAW);
-  g_source_set_can_recurse (source, FALSE);
-  clock_source->master_clock = master_clock;
-
-  return source;
-}
-
-static gboolean
-clutter_clock_prepare (GSource *source,
-                       gint    *timeout)
-{
-  ClutterClockSource *clock_source = (ClutterClockSource *) source;
-  ClutterMasterClockDefault *master_clock = clock_source->master_clock;
-  int delay;
-
-  _clutter_threads_acquire_lock ();
-
-  if (G_UNLIKELY (clutter_paint_debug_flags &
-                  CLUTTER_DEBUG_CONTINUOUS_REDRAW))
-    {
-      ClutterStageManager *stage_manager = clutter_stage_manager_get_default ();
-      const GSList *stages, *l;
-
-      stages = clutter_stage_manager_peek_stages (stage_manager);
-
-      /* Queue a full redraw on all of the stages */
-      for (l = stages; l != NULL; l = l->next)
-        clutter_actor_queue_redraw (l->data);
-    }
-
-  delay = master_clock_next_frame_delay (master_clock);
-
-  _clutter_threads_release_lock ();
-
-  *timeout = delay;
-
-  return delay == 0;
-}
-
-static gboolean
-clutter_clock_check (GSource *source)
-{
-  ClutterClockSource *clock_source = (ClutterClockSource *) source;
-  ClutterMasterClockDefault *master_clock = clock_source->master_clock;
-  int delay;
-
-  _clutter_threads_acquire_lock ();
-  delay = master_clock_next_frame_delay (master_clock);
-  _clutter_threads_release_lock ();
-
-  return delay == 0;
-}
-
-static gboolean
-clutter_clock_dispatch (GSource     *source,
-                        GSourceFunc  callback,
-                        gpointer     user_data)
-{
-  ClutterClockSource *clock_source = (ClutterClockSource *) source;
-  ClutterMasterClockDefault *master_clock = clock_source->master_clock;
-  GSList *stages;
-
-  CLUTTER_NOTE (SCHEDULER, "Master clock [tick]");
-
-  _clutter_threads_acquire_lock ();
-
-  COGL_TRACE_BEGIN (ClutterMasterClockTick, "Master Clock (tick)");
-
-  /* Get the time to use for this frame */
-  master_clock->cur_tick = g_source_get_time (source);
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  master_clock->remaining_budget = master_clock->frame_budget;
-#endif
-
-  /* We need to protect ourselves against stages being destroyed during
-   * event handling - master_clock_list_ready_stages() returns a
-   * list of referenced that we'll unref afterwards.
-   */
-  stages = master_clock_list_ready_stages (master_clock);
-
-  /* Each frame is split into three separate phases: */
-
-  /* 1. process all the events; each stage goes through its events queue
-   *    and processes each event according to its type, then emits the
-   *    various signals that are associated with the event
-   */
-  master_clock_process_events (master_clock, stages);
-
-  /* 2. advance the timelines */
-  master_clock_advance_timelines (master_clock);
-
-  /* 3. relayout and redraw the stages */
-  master_clock_update_stages (master_clock, stages);
-
-  master_clock_reschedule_stage_updates (master_clock, stages);
-
-  g_slist_free_full (stages, g_object_unref);
-
-  COGL_TRACE_END (ClutterMasterClockTick);
-
-  _clutter_threads_release_lock ();
-
-  return TRUE;
-}
-
-static void
-clutter_master_clock_default_finalize (GObject *gobject)
-{
-  ClutterMasterClockDefault *master_clock = CLUTTER_MASTER_CLOCK_DEFAULT (gobject);
-
-  g_slist_free (master_clock->timelines);
-
-  G_OBJECT_CLASS (clutter_master_clock_default_parent_class)->finalize (gobject);
-}
-
-static void
-clutter_master_clock_default_class_init (ClutterMasterClockDefaultClass *klass)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
-
-  gobject_class->finalize = clutter_master_clock_default_finalize;
-}
-
-static void
-clutter_master_clock_default_init (ClutterMasterClockDefault *self)
-{
-  GSource *source;
-
-  source = clutter_clock_source_new (self);
-  self->source = source;
-
-  self->ensure_next_iteration = FALSE;
-  self->paused = FALSE;
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  self->frame_budget = G_USEC_PER_SEC / 60;
-#endif
-
-  g_source_attach (source, NULL);
-}
-
-static void
-clutter_master_clock_default_add_timeline (ClutterMasterClock *clock,
-                                           ClutterTimeline    *timeline)
-{
-  ClutterMasterClockDefault *master_clock = (ClutterMasterClockDefault *) clock;
-  gboolean is_first;
-
-  if (g_slist_find (master_clock->timelines, timeline))
-    return;
-
-  is_first = master_clock->timelines == NULL;
-
-  master_clock->timelines = g_slist_prepend (master_clock->timelines,
-                                             timeline);
-
-  if (is_first)
-    {
-      master_clock_schedule_stage_updates (master_clock);
-      _clutter_master_clock_start_running (clock);
-    }
-}
-
-static void
-clutter_master_clock_default_remove_timeline (ClutterMasterClock *clock,
-                                              ClutterTimeline    *timeline)
-{
-  ClutterMasterClockDefault *master_clock = (ClutterMasterClockDefault *) clock;
-
-  master_clock->timelines = g_slist_remove (master_clock->timelines,
-                                            timeline);
-}
-
-static void
-clutter_master_clock_default_start_running (ClutterMasterClock *master_clock)
-{
-  /* If called from a different thread, we need to wake up the
-   * main loop to start running the timelines
-   */
-  g_main_context_wakeup (NULL);
-}
-
-static void
-clutter_master_clock_default_ensure_next_iteration (ClutterMasterClock *clock)
-{
-  ClutterMasterClockDefault *master_clock = (ClutterMasterClockDefault *) clock;
-
-  master_clock->ensure_next_iteration = TRUE;
-}
-
-static void
-clutter_master_clock_default_set_paused (ClutterMasterClock *clock,
-                                         gboolean            paused)
-{
-  ClutterMasterClockDefault *master_clock = (ClutterMasterClockDefault *) clock;
-
-  if (paused && !master_clock->paused)
-    {
-      g_clear_pointer (&master_clock->source, g_source_destroy);
-    }
-  else if (!paused && master_clock->paused)
-    {
-      master_clock->source = clutter_clock_source_new (master_clock);
-      g_source_attach (master_clock->source, NULL);
-    }
-
-  master_clock->paused = !!paused;
-}
-
-static void
-clutter_master_clock_iface_init (ClutterMasterClockInterface *iface)
-{
-  iface->add_timeline = clutter_master_clock_default_add_timeline;
-  iface->remove_timeline = clutter_master_clock_default_remove_timeline;
-  iface->start_running = clutter_master_clock_default_start_running;
-  iface->ensure_next_iteration = clutter_master_clock_default_ensure_next_iteration;
-  iface->set_paused = clutter_master_clock_default_set_paused;
-}
diff --git a/clutter/clutter/clutter-master-clock-default.h b/clutter/clutter/clutter-master-clock-default.h
deleted file mode 100644
index 87dcf6c68fea6a51070a7f5a85be87e7b1850e97..0000000000000000000000000000000000000000
--- a/clutter/clutter/clutter-master-clock-default.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Clutter.
- *
- * An OpenGL based 'interactive canvas' library.
- *
- * Authored By: Lionel Landwerlin <lionel.g.landwerlin@linux.intel.com>
- *
- * Copyright (C) 2015  Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __CLUTTER_MASTER_CLOCK_DEFAULT_H__
-#define __CLUTTER_MASTER_CLOCK_DEFAULT_H__
-
-#include <clutter/clutter-timeline.h>
-
-G_BEGIN_DECLS
-
-#define CLUTTER_TYPE_MASTER_CLOCK_DEFAULT            (_clutter_master_clock_default_get_type ())
-#define CLUTTER_MASTER_CLOCK_DEFAULT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLUTTER_TYPE_MASTER_CLOCK_DEFAULT, ClutterMasterClockDefault))
-#define CLUTTER_IS_MASTER_CLOCK_DEFAULT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLUTTER_TYPE_MASTER_CLOCK_DEFAULT))
-#define CLUTTER_MASTER_CLOCK_DEFAULT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), CLUTTER_TYPE_MASTER_CLOCK_DEFAULT, ClutterMasterClockDefaultClass))
-
-typedef struct _ClutterMasterClockDefault      ClutterMasterClockDefault;
-typedef struct _ClutterMasterClockDefaultClass ClutterMasterClockDefaultClass;
-
-struct _ClutterMasterClockDefaultClass
-{
-  GObjectClass parent_class;
-};
-
-GType _clutter_master_clock_default_get_type (void) G_GNUC_CONST;
-
-G_END_DECLS
-
-#endif /* __CLUTTER_MASTER_CLOCK_DEFAULT_H__ */
diff --git a/clutter/clutter/clutter-master-clock.c b/clutter/clutter/clutter-master-clock.c
deleted file mode 100644
index c4dff9676cfe8da23a13fbebcdd597f8280d64e2..0000000000000000000000000000000000000000
--- a/clutter/clutter/clutter-master-clock.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Clutter.
- *
- * An OpenGL based 'interactive canvas' library.
- *
- * Authored By: Emmanuele Bassi <ebassi@linux.intel.com>
- *
- * Copyright (C) 2009  Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
- * SECTION:clutter-master-clock
- * @short_description: The master clock for all animations
- *
- * The #ClutterMasterClock class is responsible for advancing all
- * #ClutterTimelines when a stage is being redrawn. The master clock
- * makes sure that the scenegraph is always integrally updated before
- * painting it.
- */
-
-#include "clutter-build-config.h"
-
-#include "clutter-master-clock.h"
-#include "clutter-master-clock-default.h"
-#include "clutter-private.h"
-
-G_DEFINE_INTERFACE (ClutterMasterClock, clutter_master_clock, G_TYPE_OBJECT)
-
-static void
-clutter_master_clock_default_init (ClutterMasterClockInterface *iface)
-{
-}
-
-ClutterMasterClock *
-_clutter_master_clock_get_default (void)
-{
-  ClutterMainContext *context = _clutter_context_get_default ();
-
-  if (G_UNLIKELY (context->master_clock == NULL))
-    context->master_clock = g_object_new (CLUTTER_TYPE_MASTER_CLOCK_DEFAULT, NULL);
-
-  return context->master_clock;
-
-}
-
-/*
- * _clutter_master_clock_add_timeline:
- * @master_clock: a #ClutterMasterClock
- * @timeline: a #ClutterTimeline
- *
- * Adds @timeline to the list of playing timelines held by the master
- * clock.
- */
-void
-_clutter_master_clock_add_timeline (ClutterMasterClock *master_clock,
-                                    ClutterTimeline    *timeline)
-{
-  g_return_if_fail (CLUTTER_IS_MASTER_CLOCK (master_clock));
-
-  CLUTTER_MASTER_CLOCK_GET_IFACE (master_clock)->add_timeline (master_clock,
-                                                               timeline);
-}
-
-/*
- * _clutter_master_clock_remove_timeline:
- * @master_clock: a #ClutterMasterClock
- * @timeline: a #ClutterTimeline
- *
- * Removes @timeline from the list of playing timelines held by the
- * master clock.
- */
-void
-_clutter_master_clock_remove_timeline (ClutterMasterClock *master_clock,
-                                       ClutterTimeline    *timeline)
-{
-  g_return_if_fail (CLUTTER_IS_MASTER_CLOCK (master_clock));
-
-  CLUTTER_MASTER_CLOCK_GET_IFACE (master_clock)->remove_timeline (master_clock,
-                                                                  timeline);
-}
-
-/*
- * _clutter_master_clock_start_running:
- * @master_clock: a #ClutterMasterClock
- *
- * Called when we have events or redraws to process; if the clock
- * is stopped, does the processing necessary to wake it up again.
- */
-void
-_clutter_master_clock_start_running (ClutterMasterClock *master_clock)
-{
-  g_return_if_fail (CLUTTER_IS_MASTER_CLOCK (master_clock));
-
-  CLUTTER_MASTER_CLOCK_GET_IFACE (master_clock)->start_running (master_clock);
-}
-
-/**
- * _clutter_master_clock_ensure_next_iteration:
- * @master_clock: a #ClutterMasterClock
- *
- * Ensures that the master clock will run at least one iteration
- */
-void
-_clutter_master_clock_ensure_next_iteration (ClutterMasterClock *master_clock)
-{
-  g_return_if_fail (CLUTTER_IS_MASTER_CLOCK (master_clock));
-
-  CLUTTER_MASTER_CLOCK_GET_IFACE (master_clock)->ensure_next_iteration (master_clock);
-}
-
-void
-_clutter_master_clock_set_paused (ClutterMasterClock *master_clock,
-                                  gboolean            paused)
-{
-  g_return_if_fail (CLUTTER_IS_MASTER_CLOCK (master_clock));
-
-  CLUTTER_MASTER_CLOCK_GET_IFACE (master_clock)->set_paused (master_clock,
-                                                             !!paused);
-}
diff --git a/clutter/clutter/clutter-master-clock.h b/clutter/clutter/clutter-master-clock.h
deleted file mode 100644
index 36e974f5385767b41637ee8a7223b41ef2da5b82..0000000000000000000000000000000000000000
--- a/clutter/clutter/clutter-master-clock.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Clutter.
- *
- * An OpenGL based 'interactive canvas' library.
- *
- * Authored By: Emmanuele Bassi <ebassi@linux.intel.com>
- *
- * Copyright (C) 2009  Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __CLUTTER_MASTER_CLOCK_H__
-#define __CLUTTER_MASTER_CLOCK_H__
-
-#include <clutter/clutter-timeline.h>
-
-G_BEGIN_DECLS
-
-#define CLUTTER_TYPE_MASTER_CLOCK (clutter_master_clock_get_type ())
-G_DECLARE_INTERFACE (ClutterMasterClock, clutter_master_clock,
-                     CLUTTER, MASTER_CLOCK,
-                     GObject)
-
-struct _ClutterMasterClockInterface
-{
-  /*< private >*/
-  GTypeInterface parent_iface;
-
-  void (* add_timeline)           (ClutterMasterClock *master_clock,
-                                   ClutterTimeline    *timeline);
-  void (* remove_timeline)        (ClutterMasterClock *master_clock,
-                                   ClutterTimeline    *timeline);
-  void (* start_running)          (ClutterMasterClock *master_clock);
-  void (* ensure_next_iteration)  (ClutterMasterClock *master_clock);
-  void (* set_paused)             (ClutterMasterClock *master_clock,
-                                   gboolean            paused);
-};
-
-ClutterMasterClock *    _clutter_master_clock_get_default               (void);
-void                    _clutter_master_clock_add_timeline              (ClutterMasterClock *master_clock,
-                                                                         ClutterTimeline    *timeline);
-void                    _clutter_master_clock_remove_timeline           (ClutterMasterClock *master_clock,
-                                                                         ClutterTimeline    *timeline);
-void                    _clutter_master_clock_start_running             (ClutterMasterClock *master_clock);
-void                    _clutter_master_clock_ensure_next_iteration     (ClutterMasterClock *master_clock);
-void                    _clutter_master_clock_set_paused                (ClutterMasterClock *master_clock,
-                                                                         gboolean            paused);
-
-void                    _clutter_timeline_advance                       (ClutterTimeline    *timeline,
-                                                                         gint64              tick_time);
-gint64                  _clutter_timeline_get_delta                     (ClutterTimeline    *timeline);
-void                    _clutter_timeline_do_tick                       (ClutterTimeline    *timeline,
-                                                                         gint64              tick_time);
-
-G_END_DECLS
-
-#endif /* __CLUTTER_MASTER_CLOCK_H__ */
diff --git a/clutter/clutter/clutter-mutter.h b/clutter/clutter/clutter-mutter.h
index cc1ba9a97251dc7393b29a1fc1ceb779bb725ed8..6ca7904b24f1271bc9b08054d10323072960f311 100644
--- a/clutter/clutter/clutter-mutter.h
+++ b/clutter/clutter/clutter-mutter.h
@@ -39,6 +39,10 @@
 CLUTTER_EXPORT
 GList * clutter_stage_peek_stage_views (ClutterStage *stage);
 
+CLUTTER_EXPORT
+gboolean clutter_actor_is_effectively_on_stage_view (ClutterActor     *self,
+                                                     ClutterStageView *view);
+
 CLUTTER_EXPORT
 void clutter_set_custom_backend_func (ClutterBackend *(* func) (void));
 
@@ -68,12 +72,6 @@ gboolean clutter_stage_paint_to_buffer (ClutterStage                 *stage,
                                         ClutterPaintFlag              paint_flags,
                                         GError                      **error);
 
-CLUTTER_EXPORT
-void clutter_stage_freeze_updates (ClutterStage *stage);
-
-CLUTTER_EXPORT
-void clutter_stage_thaw_updates (ClutterStage *stage);
-
 CLUTTER_EXPORT
 void clutter_stage_clear_stage_views (ClutterStage *stage);
 
diff --git a/clutter/clutter/clutter-paint-nodes.c b/clutter/clutter/clutter-paint-nodes.c
index d6827f66bed77ab986c5fc7465a63072a1f14075..6301661da14530ca0ee6baaae8767d2694acfff4 100644
--- a/clutter/clutter/clutter-paint-nodes.c
+++ b/clutter/clutter/clutter-paint-nodes.c
@@ -1412,6 +1412,7 @@ clutter_layer_node_new (const CoglMatrix        *projection,
 {
   ClutterLayerNode *res;
   CoglContext *context;
+  CoglTexture2D *tex_2d;
   CoglTexture *texture;
   CoglColor color;
 
@@ -1426,9 +1427,10 @@ clutter_layer_node_new (const CoglMatrix        *projection,
   /* the texture backing the FBO */
   context = clutter_backend_get_cogl_context (clutter_get_default_backend ());
 
-  texture = cogl_texture_2d_new_with_size (context,
-                                           MAX (res->fbo_width, 1),
-                                           MAX (res->fbo_height, 1));
+  tex_2d = cogl_texture_2d_new_with_size (context,
+                                          MAX (res->fbo_width, 1),
+                                          MAX (res->fbo_height, 1));
+  texture = COGL_TEXTURE (tex_2d);
   cogl_texture_set_premultiplied (texture, TRUE);
 
   res->offscreen = COGL_FRAMEBUFFER (cogl_offscreen_new_to_texture (texture));
diff --git a/clutter/clutter/clutter-pan-action.c b/clutter/clutter/clutter-pan-action.c
index 22fdc2743b35d219250b7ed752dbe082682d1802..6a42627e49b47fa77783eaef34cb46f70bb87327 100644
--- a/clutter/clutter/clutter-pan-action.c
+++ b/clutter/clutter/clutter-pan-action.c
@@ -62,6 +62,7 @@
 #include "clutter-gesture-action-private.h"
 #include "clutter-marshal.h"
 #include "clutter-private.h"
+#include "clutter-timeline.h"
 #include <math.h>
 
 #define FLOAT_EPSILON   (1e-15)
@@ -326,8 +327,12 @@ gesture_end (ClutterGestureAction *gesture,
   if (ABS (velocity) * priv->acceleration_factor > min_velocity &&
       duration > FLOAT_EPSILON)
     {
+      ClutterActor *pan_actor =
+        clutter_actor_meta_get_actor (CLUTTER_ACTOR_META (gesture));
+
       priv->interpolated_x = priv->interpolated_y = 0.0f;
-      priv->deceleration_timeline = clutter_timeline_new (duration);
+      priv->deceleration_timeline = clutter_timeline_new_for_actor (pan_actor,
+                                                                    duration);
       clutter_timeline_set_progress_mode (priv->deceleration_timeline,
                                           CLUTTER_EASE_OUT_EXPO);
 
@@ -458,6 +463,8 @@ clutter_pan_action_set_actor (ClutterActorMeta *meta,
       /* make sure we reset the state */
       if (priv->state == PAN_STATE_INTERPOLATING)
         g_clear_object (&priv->deceleration_timeline);
+      else if (priv->deceleration_timeline)
+        clutter_timeline_set_actor (priv->deceleration_timeline, actor);
     }
 
   CLUTTER_ACTOR_META_CLASS (clutter_pan_action_parent_class)->set_actor (meta,
diff --git a/clutter/clutter/clutter-private.h b/clutter/clutter/clutter-private.h
index 196725fd9500635904a4e18d2e7dbe4f6a3a7623..e3f89ed09c60d90e113a43233078df3eb1a9e48b 100644
--- a/clutter/clutter/clutter-private.h
+++ b/clutter/clutter/clutter-private.h
@@ -37,7 +37,6 @@
 #include "clutter-feature.h"
 #include "clutter-id-pool.h"
 #include "clutter-layout-manager.h"
-#include "clutter-master-clock.h"
 #include "clutter-settings.h"
 #include "clutter-stage-manager.h"
 #include "clutter-stage.h"
@@ -122,9 +121,6 @@ struct _ClutterMainContext
   /* the object holding all the stage instances */
   ClutterStageManager *stage_manager;
 
-  /* the clock driving all the frame operations */
-  ClutterMasterClock *master_clock;
-
   /* the main event queue */
   GQueue *events_queue;
 
@@ -177,11 +173,6 @@ typedef struct
 gboolean _clutter_threads_dispatch      (gpointer data);
 void     _clutter_threads_dispatch_free (gpointer data);
 
-CLUTTER_EXPORT
-void                    _clutter_threads_acquire_lock                   (void);
-CLUTTER_EXPORT
-void                    _clutter_threads_release_lock                   (void);
-
 ClutterMainContext *    _clutter_context_get_default                    (void);
 void                    _clutter_context_lock                           (void);
 void                    _clutter_context_unlock                         (void);
@@ -316,6 +307,30 @@ gboolean        _clutter_run_progress_function  (GType gtype,
 
 void            clutter_timeline_cancel_delay (ClutterTimeline *timeline);
 
+static inline uint64_t
+us (uint64_t us)
+{
+  return us;
+}
+
+static inline uint64_t
+ms2us (uint64_t ms)
+{
+  return us (ms * 1000);
+}
+
+static inline uint32_t
+us2ms (uint64_t us)
+{
+  return (uint32_t) (us / 1000);
+}
+
+static inline uint64_t
+ns2us (uint64_t ns)
+{
+  return us (ns / 1000);
+}
+
 G_END_DECLS
 
 #endif /* __CLUTTER_PRIVATE_H__ */
diff --git a/clutter/clutter/clutter-property-transition.c b/clutter/clutter/clutter-property-transition.c
index d18acf39edc8704c5e09f7a977724a359bc6153f..f8c96761d82fa2743115d570bc8cd4a4f89d52e5 100644
--- a/clutter/clutter/clutter-property-transition.c
+++ b/clutter/clutter/clutter-property-transition.c
@@ -278,6 +278,26 @@ clutter_property_transition_init (ClutterPropertyTransition *self)
   self->priv = clutter_property_transition_get_instance_private (self);
 }
 
+/**
+ * clutter_property_transition_new_for_actor:
+ * @actor: a #ClutterActor
+ * @property_name: (allow-none): a property of @animatable, or %NULL
+ *
+ * Creates a new #ClutterPropertyTransition.
+ *
+ * Return value: (transfer full): the newly created #ClutterPropertyTransition.
+ *   Use g_object_unref() when done
+ */
+ClutterTransition *
+clutter_property_transition_new_for_actor (ClutterActor *actor,
+                                           const char   *property_name)
+{
+  return g_object_new (CLUTTER_TYPE_PROPERTY_TRANSITION,
+                       "actor", actor,
+                       "property-name", property_name,
+                       NULL);
+}
+
 /**
  * clutter_property_transition_new:
  * @property_name: (allow-none): a property of @animatable, or %NULL
diff --git a/clutter/clutter/clutter-property-transition.h b/clutter/clutter/clutter-property-transition.h
index 0a376687665833ff5ca120dc55663c0a2a815f23..5670746fac0184da423da29fed930bb9c53b9adb 100644
--- a/clutter/clutter/clutter-property-transition.h
+++ b/clutter/clutter/clutter-property-transition.h
@@ -78,8 +78,13 @@ struct _ClutterPropertyTransitionClass
 CLUTTER_EXPORT
 GType clutter_property_transition_get_type (void) G_GNUC_CONST;
 
+CLUTTER_EXPORT
+ClutterTransition *     clutter_property_transition_new_for_actor       (ClutterActor              *actor,
+                                                                         const char                *property_name);
+
 CLUTTER_EXPORT
 ClutterTransition *     clutter_property_transition_new                 (const char                *property_name);
+
 CLUTTER_EXPORT
 void                    clutter_property_transition_set_property_name   (ClutterPropertyTransition *transition,
                                                                          const char                *property_name);
diff --git a/clutter/clutter/clutter-stage-private.h b/clutter/clutter/clutter-stage-private.h
index 2ce0cd05b5932d74897816a9c97f5577bc5dca00..7297d56a6db8ce071a83cdbb280bec542fa3a820 100644
--- a/clutter/clutter/clutter-stage-private.h
+++ b/clutter/clutter/clutter-stage-private.h
@@ -40,7 +40,14 @@ void                clutter_stage_paint_view             (ClutterStage
                                                           ClutterStageView      *view,
                                                           const cairo_region_t  *redraw_clip);
 
-void                _clutter_stage_emit_after_paint      (ClutterStage          *stage);
+void                clutter_stage_emit_before_update     (ClutterStage          *stage,
+                                                          ClutterStageView      *view);
+void                clutter_stage_emit_before_paint      (ClutterStage          *stage,
+                                                          ClutterStageView      *view);
+void                clutter_stage_emit_after_paint       (ClutterStage          *stage,
+                                                          ClutterStageView      *view);
+void                clutter_stage_emit_after_update      (ClutterStage          *stage,
+                                                          ClutterStageView      *view);
 
 CLUTTER_EXPORT
 void                _clutter_stage_set_window            (ClutterStage          *stage,
@@ -58,9 +65,12 @@ void                _clutter_stage_get_viewport          (ClutterStage
 void                _clutter_stage_dirty_viewport        (ClutterStage          *stage);
 void                _clutter_stage_maybe_setup_viewport  (ClutterStage          *stage,
                                                           ClutterStageView      *view);
-void                _clutter_stage_maybe_relayout        (ClutterActor          *stage);
-gboolean            _clutter_stage_needs_update          (ClutterStage          *stage);
-gboolean            _clutter_stage_do_update             (ClutterStage          *stage);
+void                clutter_stage_maybe_relayout         (ClutterActor          *stage);
+void                clutter_stage_maybe_finish_queue_redraws (ClutterStage      *stage);
+GSList *            clutter_stage_find_updated_devices   (ClutterStage          *stage);
+void                clutter_stage_update_devices         (ClutterStage          *stage,
+                                                          GSList                *devices);
+void                clutter_stage_update_actor_stage_views (ClutterStage        *stage);
 
 CLUTTER_EXPORT
 void     _clutter_stage_queue_event                       (ClutterStage *stage,
@@ -69,8 +79,6 @@ void     _clutter_stage_queue_event                       (ClutterStage *stage,
 gboolean _clutter_stage_has_queued_events                 (ClutterStage *stage);
 void     _clutter_stage_process_queued_events             (ClutterStage *stage);
 void     _clutter_stage_update_input_devices              (ClutterStage *stage);
-gint64    _clutter_stage_get_update_time                  (ClutterStage *stage);
-void     _clutter_stage_clear_update_time                 (ClutterStage *stage);
 gboolean _clutter_stage_has_full_redraw_queued            (ClutterStage *stage);
 
 void clutter_stage_log_pick (ClutterStage           *stage,
@@ -126,8 +134,8 @@ gboolean                _clutter_stage_update_state     (ClutterStage      *stag
 void                    _clutter_stage_set_scale_factor (ClutterStage      *stage,
                                                          int                factor);
 
-void            _clutter_stage_presented                (ClutterStage      *stage,
-                                                         CoglFrameEvent     frame_event,
+void            clutter_stage_presented                 (ClutterStage      *stage,
+                                                         ClutterStageView  *view,
                                                          ClutterFrameInfo  *frame_info);
 
 void            clutter_stage_queue_actor_relayout      (ClutterStage *stage,
diff --git a/clutter/clutter/clutter-stage-view-private.h b/clutter/clutter/clutter-stage-view-private.h
index 36c52e8ad61ab956d83addfcc6fd1d53b36b6d90..e4132202e41e24e28ee4353c3d60ec50a6f740b9 100644
--- a/clutter/clutter/clutter-stage-view-private.h
+++ b/clutter/clutter/clutter-stage-view-private.h
@@ -19,6 +19,7 @@
 #define __CLUTTER_STAGE_VIEW_PRIVATE_H__
 
 #include "clutter/clutter-stage-view.h"
+#include "clutter/clutter-types.h"
 
 void clutter_stage_view_after_paint (ClutterStageView *view,
                                      cairo_region_t   *redraw_clip);
@@ -62,4 +63,12 @@ void clutter_stage_view_transform_rect_to_onscreen (ClutterStageView
                                                     int                          dst_height,
                                                     cairo_rectangle_int_t       *dst_rect);
 
+void clutter_stage_view_schedule_update (ClutterStageView *view);
+
+CLUTTER_EXPORT
+float clutter_stage_view_get_refresh_rate (ClutterStageView *view);
+
+void clutter_stage_view_notify_presented (ClutterStageView *view,
+                                          ClutterFrameInfo *frame_info);
+
 #endif /* __CLUTTER_STAGE_VIEW_PRIVATE_H__ */
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index efc9d67a8544b663fc22ba3b4234eccd54fbd419..9e19055d651c4c0ba73eef3cddabffb25c4b39af 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -24,8 +24,10 @@
 #include <math.h>
 
 #include "clutter/clutter-damage-history.h"
+#include "clutter/clutter-frame-clock.h"
 #include "clutter/clutter-private.h"
 #include "clutter/clutter-mutter.h"
+#include "clutter/clutter-stage-private.h"
 #include "cogl/cogl.h"
 
 enum
@@ -33,11 +35,13 @@ enum
   PROP_0,
 
   PROP_NAME,
+  PROP_STAGE,
   PROP_LAYOUT,
   PROP_FRAMEBUFFER,
   PROP_OFFSCREEN,
   PROP_USE_SHADOWFB,
   PROP_SCALE,
+  PROP_REFRESH_RATE,
 
   PROP_LAST
 };
@@ -48,6 +52,8 @@ typedef struct _ClutterStageViewPrivate
 {
   char *name;
 
+  ClutterStage *stage;
+
   cairo_rectangle_int_t layout;
   float scale;
   CoglFramebuffer *framebuffer;
@@ -71,6 +77,9 @@ typedef struct _ClutterStageViewPrivate
   gboolean has_redraw_clip;
   cairo_region_t *redraw_clip;
 
+  float refresh_rate;
+  ClutterFrameClock *frame_clock;
+
   guint dirty_viewport   : 1;
   guint dirty_projection : 1;
 } ClutterStageViewPrivate;
@@ -102,9 +111,9 @@ clutter_stage_view_get_framebuffer (ClutterStageView *view)
     clutter_stage_view_get_instance_private (view);
 
   if (priv->offscreen)
-    return priv->offscreen;
+    return COGL_FRAMEBUFFER (priv->offscreen);
   else if (priv->shadow.framebuffer)
-    return priv->shadow.framebuffer;
+    return COGL_FRAMEBUFFER (priv->shadow.framebuffer);
   else
     return priv->framebuffer;
 }
@@ -127,8 +136,9 @@ clutter_stage_view_get_onscreen (ClutterStageView *view)
 }
 
 static CoglPipeline *
-clutter_stage_view_create_framebuffer_pipeline (CoglFramebuffer *framebuffer)
+clutter_stage_view_create_offscreen_pipeline (CoglOffscreen *offscreen)
 {
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (offscreen);
   CoglPipeline *pipeline;
 
   pipeline = cogl_pipeline_new (cogl_framebuffer_get_context (framebuffer));
@@ -137,7 +147,7 @@ clutter_stage_view_create_framebuffer_pipeline (CoglFramebuffer *framebuffer)
                                    COGL_PIPELINE_FILTER_NEAREST,
                                    COGL_PIPELINE_FILTER_NEAREST);
   cogl_pipeline_set_layer_texture (pipeline, 0,
-                                   cogl_offscreen_get_texture (framebuffer));
+                                   cogl_offscreen_get_texture (offscreen));
   cogl_pipeline_set_layer_wrap_mode (pipeline, 0,
                                      COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE);
 
@@ -158,7 +168,7 @@ clutter_stage_view_ensure_offscreen_blit_pipeline (ClutterStageView *view)
     return;
 
   priv->offscreen_pipeline =
-    clutter_stage_view_create_framebuffer_pipeline (priv->offscreen);
+    clutter_stage_view_create_offscreen_pipeline (priv->offscreen);
 
   if (view_class->setup_offscreen_blit_pipeline)
     view_class->setup_offscreen_blit_pipeline (view, priv->offscreen_pipeline);
@@ -192,7 +202,7 @@ clutter_stage_view_transform_rect_to_onscreen (ClutterStageView            *view
 static void
 paint_transformed_framebuffer (ClutterStageView     *view,
                                CoglPipeline         *pipeline,
-                               CoglFramebuffer      *src_framebuffer,
+                               CoglOffscreen        *src_framebuffer,
                                CoglFramebuffer      *dst_framebuffer,
                                const cairo_region_t *redraw_clip)
 {
@@ -432,10 +442,13 @@ clutter_stage_view_after_paint (ClutterStageView *view,
 
       if (priv->shadow.framebuffer)
         {
+          CoglFramebuffer *shadowfb =
+            COGL_FRAMEBUFFER (priv->shadow.framebuffer);
+
           paint_transformed_framebuffer (view,
                                          priv->offscreen_pipeline,
                                          priv->offscreen,
-                                         priv->shadow.framebuffer,
+                                         shadowfb,
                                          redraw_clip);
         }
       else
@@ -508,7 +521,7 @@ find_damaged_tiles (ClutterStageView      *view,
   stride = cogl_dma_buf_handle_get_stride (current_dma_buf_handle);
   bpp = cogl_dma_buf_handle_get_bpp (current_dma_buf_handle);
 
-  cogl_framebuffer_finish (priv->shadow.framebuffer);
+  cogl_framebuffer_finish (COGL_FRAMEBUFFER (priv->shadow.framebuffer));
 
   if (!cogl_dma_buf_handle_sync_read_start (prev_dma_buf_handle, error))
     return NULL;
@@ -601,7 +614,7 @@ swap_dma_buf_framebuffer (ClutterStageView *view)
     clutter_stage_view_get_instance_private (view);
   int next_idx;
   CoglDmaBufHandle *next_dma_buf_handle;
-  CoglOffscreen *next_framebuffer;
+  CoglFramebuffer *next_framebuffer;
 
   next_idx = ((priv->shadow.dma_buf.current_idx + 1) %
               G_N_ELEMENTS (priv->shadow.dma_buf.handles));
@@ -697,12 +710,13 @@ copy_shadowfb_to_onscreen (ClutterStageView     *view,
 
   for (i = 0; i < cairo_region_num_rectangles (damage_region); i++)
     {
+      CoglFramebuffer *shadowfb = COGL_FRAMEBUFFER (priv->shadow.framebuffer);
       g_autoptr (GError) error = NULL;
       cairo_rectangle_int_t rect;
 
       cairo_region_get_rectangle (damage_region, i, &rect);
 
-      if (!cogl_blit_framebuffer (priv->shadow.framebuffer,
+      if (!cogl_blit_framebuffer (shadowfb,
                                   priv->framebuffer,
                                   rect.x, rect.y,
                                   rect.x, rect.y,
@@ -754,7 +768,7 @@ clutter_stage_view_foreach_front_buffer (ClutterStageView    *view,
 
   if (priv->offscreen)
     {
-      callback (priv->offscreen, user_data);
+      callback (COGL_FRAMEBUFFER (priv->offscreen), user_data);
     }
   else if (priv->shadow.framebuffer)
     {
@@ -773,7 +787,7 @@ clutter_stage_view_foreach_front_buffer (ClutterStageView    *view,
         }
       else
         {
-          callback (priv->shadow.framebuffer, user_data);
+          callback (COGL_FRAMEBUFFER (priv->shadow.framebuffer), user_data);
         }
     }
   else
@@ -988,6 +1002,154 @@ clutter_stage_view_take_scanout (ClutterStageView *view)
   return g_steal_pointer (&priv->next_scanout);
 }
 
+void
+clutter_stage_view_schedule_update (ClutterStageView *view)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  clutter_frame_clock_schedule_update (priv->frame_clock);
+}
+
+float
+clutter_stage_view_get_refresh_rate (ClutterStageView *view)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  return priv->refresh_rate;
+}
+
+/**
+ * clutter_stage_view_get_frame_clock: (skip)
+ */
+ClutterFrameClock *
+clutter_stage_view_get_frame_clock (ClutterStageView *view)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  return priv->frame_clock;
+}
+
+static void
+handle_frame_clock_before_frame (ClutterFrameClock *frame_clock,
+                                 int64_t            frame_count,
+                                 gpointer           user_data)
+{
+  ClutterStageView *view = user_data;
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  _clutter_stage_process_queued_events (priv->stage);
+}
+
+static ClutterFrameResult
+handle_frame_clock_frame (ClutterFrameClock *frame_clock,
+                          int64_t            frame_count,
+                          int64_t            time_us,
+                          gpointer           user_data)
+{
+  ClutterStageView *view = user_data;
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+  ClutterStage *stage = priv->stage;
+  g_autoptr (GSList) devices = NULL;
+  ClutterFrameResult result;
+
+  if (CLUTTER_ACTOR_IN_DESTRUCTION (stage))
+    return CLUTTER_FRAME_RESULT_IDLE;
+
+  if (!clutter_actor_is_realized (CLUTTER_ACTOR (stage)))
+    return CLUTTER_FRAME_RESULT_IDLE;
+
+  if (!clutter_actor_is_mapped (CLUTTER_ACTOR (stage)))
+    return CLUTTER_FRAME_RESULT_IDLE;
+
+  _clutter_run_repaint_functions (CLUTTER_REPAINT_FLAGS_PRE_PAINT);
+  clutter_stage_emit_before_update (stage, view);
+
+  clutter_stage_maybe_relayout (CLUTTER_ACTOR (stage));
+  clutter_stage_update_actor_stage_views (stage);
+  clutter_stage_maybe_finish_queue_redraws (stage);
+
+  devices = clutter_stage_find_updated_devices (stage);
+
+  if (clutter_stage_view_has_redraw_clip (view))
+    {
+      ClutterStageWindow *stage_window;
+
+      clutter_stage_emit_before_paint (stage, view);
+
+      stage_window = _clutter_stage_get_window (stage);
+      _clutter_stage_window_redraw_view (stage_window, view);
+
+      clutter_stage_emit_after_paint (stage, view);
+
+      _clutter_stage_window_finish_frame (stage_window);
+
+      result = CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+    }
+  else
+    {
+      result = CLUTTER_FRAME_RESULT_IDLE;
+    }
+
+  clutter_stage_update_devices (stage, devices);
+
+  _clutter_run_repaint_functions (CLUTTER_REPAINT_FLAGS_POST_PAINT);
+  clutter_stage_emit_after_update (stage, view);
+
+  return result;
+}
+
+static const ClutterFrameListenerIface frame_clock_listener_iface = {
+  .before_frame = handle_frame_clock_before_frame,
+  .frame = handle_frame_clock_frame,
+};
+
+void
+clutter_stage_view_notify_presented (ClutterStageView *view,
+                                     ClutterFrameInfo *frame_info)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  clutter_stage_presented (priv->stage, view, frame_info);
+  clutter_frame_clock_notify_presented (priv->frame_clock, frame_info);
+}
+
+static void
+sanity_check_framebuffer (ClutterStageView *view)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+  G_GNUC_UNUSED int fb_width, fb_height;
+
+  fb_width = cogl_framebuffer_get_width (priv->framebuffer);
+  fb_height = cogl_framebuffer_get_height (priv->framebuffer);
+
+  g_warn_if_fail (fabsf (roundf (fb_width / priv->scale) -
+                         fb_width / priv->scale) < FLT_EPSILON);
+  g_warn_if_fail (fabsf (roundf (fb_height / priv->scale) -
+                         fb_height / priv->scale) < FLT_EPSILON);
+}
+
+static void
+clutter_stage_view_set_framebuffer (ClutterStageView *view,
+                                    CoglFramebuffer  *framebuffer)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  g_warn_if_fail (!priv->framebuffer);
+  if (framebuffer)
+    {
+      priv->framebuffer = cogl_object_ref (framebuffer);
+      sanity_check_framebuffer (view);
+    }
+}
+
 static void
 clutter_stage_view_get_property (GObject    *object,
                                  guint       prop_id,
@@ -1003,6 +1165,9 @@ clutter_stage_view_get_property (GObject    *object,
     case PROP_NAME:
       g_value_set_string (value, priv->name);
       break;
+    case PROP_STAGE:
+      g_value_set_boxed (value, &priv->stage);
+      break;
     case PROP_LAYOUT:
       g_value_set_boxed (value, &priv->layout);
       break;
@@ -1018,6 +1183,9 @@ clutter_stage_view_get_property (GObject    *object,
     case PROP_SCALE:
       g_value_set_float (value, priv->scale);
       break;
+    case PROP_REFRESH_RATE:
+      g_value_set_float (value, priv->refresh_rate);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
     }
@@ -1039,26 +1207,15 @@ clutter_stage_view_set_property (GObject      *object,
     case PROP_NAME:
       priv->name = g_value_dup_string (value);
       break;
+    case PROP_STAGE:
+      priv->stage = g_value_get_object (value);
+      break;
     case PROP_LAYOUT:
       layout = g_value_get_boxed (value);
       priv->layout = *layout;
       break;
     case PROP_FRAMEBUFFER:
-      priv->framebuffer = g_value_dup_boxed (value);
-#ifndef G_DISABLE_CHECKS
-      if (priv->framebuffer)
-        {
-          int fb_width, fb_height;
-
-          fb_width = cogl_framebuffer_get_width (priv->framebuffer);
-          fb_height = cogl_framebuffer_get_height (priv->framebuffer);
-
-          g_warn_if_fail (fabsf (roundf (fb_width / priv->scale) -
-                                 fb_width / priv->scale) < FLT_EPSILON);
-          g_warn_if_fail (fabsf (roundf (fb_height / priv->scale) -
-                                 fb_height / priv->scale) < FLT_EPSILON);
-        }
-#endif
+      clutter_stage_view_set_framebuffer (view, g_value_get_boxed (value));
       break;
     case PROP_OFFSCREEN:
       priv->offscreen = g_value_dup_boxed (value);
@@ -1069,6 +1226,9 @@ clutter_stage_view_set_property (GObject      *object,
     case PROP_SCALE:
       priv->scale = g_value_get_float (value);
       break;
+    case PROP_REFRESH_RATE:
+      priv->refresh_rate = g_value_get_float (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
     }
@@ -1084,6 +1244,10 @@ clutter_stage_view_constructed (GObject *object)
   if (priv->use_shadowfb)
     init_shadowfb (view);
 
+  priv->frame_clock = clutter_frame_clock_new (priv->refresh_rate,
+                                               &frame_clock_listener_iface,
+                                               view);
+
   G_OBJECT_CLASS (clutter_stage_view_parent_class)->constructed (object);
 }
 
@@ -1110,6 +1274,7 @@ clutter_stage_view_dispose (GObject *object)
   g_clear_pointer (&priv->offscreen, cogl_object_unref);
   g_clear_pointer (&priv->offscreen_pipeline, cogl_object_unref);
   g_clear_pointer (&priv->redraw_clip, cairo_region_destroy);
+  g_clear_pointer (&priv->frame_clock, clutter_frame_clock_destroy);
 
   G_OBJECT_CLASS (clutter_stage_view_parent_class)->dispose (object);
 }
@@ -1123,6 +1288,7 @@ clutter_stage_view_init (ClutterStageView *view)
   priv->dirty_viewport = TRUE;
   priv->dirty_projection = TRUE;
   priv->scale = 1.0;
+  priv->refresh_rate = 60.0;
 }
 
 static void
@@ -1146,6 +1312,16 @@ clutter_stage_view_class_init (ClutterStageViewClass *klass)
                          G_PARAM_READWRITE |
                          G_PARAM_CONSTRUCT_ONLY |
                          G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_STAGE] =
+    g_param_spec_object ("stage",
+                         "The stage",
+                         "The ClutterStage",
+                         CLUTTER_TYPE_STAGE,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
   obj_props[PROP_LAYOUT] =
     g_param_spec_boxed ("layout",
                         "View layout",
@@ -1191,5 +1367,14 @@ clutter_stage_view_class_init (ClutterStageViewClass *klass)
                         G_PARAM_CONSTRUCT |
                         G_PARAM_STATIC_STRINGS);
 
+  obj_props[PROP_REFRESH_RATE] =
+    g_param_spec_float ("refresh-rate",
+                        "Refresh rate",
+                        "Update refresh rate",
+                        1.0, G_MAXFLOAT, 60.0,
+                        G_PARAM_READWRITE |
+                        G_PARAM_CONSTRUCT |
+                        G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
diff --git a/clutter/clutter/clutter-stage-view.h b/clutter/clutter/clutter-stage-view.h
index eb0184e9ab2f35f77847f3e065cf2c619b9c3382..ff1963c5d46dac04c823210a73a47654769cb7cd 100644
--- a/clutter/clutter/clutter-stage-view.h
+++ b/clutter/clutter/clutter-stage-view.h
@@ -27,6 +27,7 @@
 #include <cogl/cogl.h>
 
 #include "clutter-macros.h"
+#include "clutter-frame-clock.h"
 
 #define CLUTTER_TYPE_STAGE_VIEW (clutter_stage_view_get_type ())
 CLUTTER_EXPORT
@@ -69,4 +70,7 @@ CLUTTER_EXPORT
 void clutter_stage_view_get_offscreen_transformation_matrix (ClutterStageView *view,
                                                              CoglMatrix       *matrix);
 
+CLUTTER_EXPORT
+ClutterFrameClock * clutter_stage_view_get_frame_clock (ClutterStageView *view);
+
 #endif /* __CLUTTER_STAGE_VIEW_H__ */
diff --git a/clutter/clutter/clutter-stage-window.c b/clutter/clutter/clutter-stage-window.c
index fe09aa1dba11481142e21d23ba6451db28f1362d..e4e358e6fe1bc2b4f38d5b855e71107599ac1bf6 100644
--- a/clutter/clutter/clutter-stage-window.c
+++ b/clutter/clutter/clutter-stage-window.c
@@ -103,81 +103,12 @@ _clutter_stage_window_get_geometry (ClutterStageWindow    *window,
 }
 
 void
-_clutter_stage_window_schedule_update  (ClutterStageWindow *window,
-                                        int                 sync_delay)
+_clutter_stage_window_redraw_view (ClutterStageWindow *window,
+                                   ClutterStageView   *view)
 {
-  ClutterStageWindowInterface *iface;
-
-  g_return_if_fail (CLUTTER_IS_STAGE_WINDOW (window));
-
-  iface = CLUTTER_STAGE_WINDOW_GET_IFACE (window);
-  if (iface->schedule_update == NULL)
-    {
-      g_assert (!clutter_feature_available (CLUTTER_FEATURE_SWAP_EVENTS));
-      return;
-    }
-
-  iface->schedule_update (window, sync_delay);
-}
-
-/**
- * _clutter_stage_window_get_update_time:
- * @window: a #ClutterStageWindow object
- *
- * See _clutter_stage_get_update_time() for more info.
- *
- * Returns: The timestamp of the update time
- */
-gint64
-_clutter_stage_window_get_update_time (ClutterStageWindow *window)
-{
-  ClutterStageWindowInterface *iface;
-
-  g_return_val_if_fail (CLUTTER_IS_STAGE_WINDOW (window), 0);
-
-  iface = CLUTTER_STAGE_WINDOW_GET_IFACE (window);
-  if (iface->get_update_time == NULL)
-    {
-      g_assert (!clutter_feature_available (CLUTTER_FEATURE_SWAP_EVENTS));
-      return 0;
-    }
-
-  return iface->get_update_time (window);
-}
-
-/**
- * _clutter_stage_window_clear_update_time:
- * @window: a #ClutterStageWindow object
- *
- * Clears the update time. See _clutter_stage_clear_update_time() for more info.
- */
-void
-_clutter_stage_window_clear_update_time (ClutterStageWindow *window)
-{
-  ClutterStageWindowInterface *iface;
-
-  g_return_if_fail (CLUTTER_IS_STAGE_WINDOW (window));
-
-  iface = CLUTTER_STAGE_WINDOW_GET_IFACE (window);
-  if (iface->clear_update_time == NULL)
-    {
-      g_assert (!clutter_feature_available (CLUTTER_FEATURE_SWAP_EVENTS));
-      return;
-    }
-
-  iface->clear_update_time (window);
-}
-
-void
-_clutter_stage_window_redraw (ClutterStageWindow *window)
-{
-  ClutterStageWindowInterface *iface;
-
   g_return_if_fail (CLUTTER_IS_STAGE_WINDOW (window));
 
-  iface = CLUTTER_STAGE_WINDOW_GET_IFACE (window);
-  if (iface->redraw)
-    iface->redraw (window);
+  CLUTTER_STAGE_WINDOW_GET_IFACE (window)->redraw_view (window, view);
 }
 
 gboolean
diff --git a/clutter/clutter/clutter-stage-window.h b/clutter/clutter/clutter-stage-window.h
index 9f78ed25c2f56cf885d6a8a019839286ccbccac6..b4bb1a1bd04d656c36716a7f93a92a39599c0b7e 100644
--- a/clutter/clutter/clutter-stage-window.h
+++ b/clutter/clutter/clutter-stage-window.h
@@ -44,12 +44,8 @@ struct _ClutterStageWindowInterface
   void              (* get_geometry)            (ClutterStageWindow *stage_window,
                                                  cairo_rectangle_int_t *geometry);
 
-  void              (* schedule_update)         (ClutterStageWindow *stage_window,
-                                                 int                 sync_delay);
-  gint64            (* get_update_time)         (ClutterStageWindow *stage_window);
-  void              (* clear_update_time)       (ClutterStageWindow *stage_window);
-
-  void              (* redraw)                  (ClutterStageWindow *stage_window);
+  void              (* redraw_view)             (ClutterStageWindow *stage_window,
+                                                 ClutterStageView   *view);
 
   gboolean          (* can_clip_redraws)        (ClutterStageWindow *stage_window);
 
@@ -78,15 +74,12 @@ void              _clutter_stage_window_resize                  (ClutterStageWin
 CLUTTER_EXPORT
 void              _clutter_stage_window_get_geometry            (ClutterStageWindow *window,
                                                                  cairo_rectangle_int_t *geometry);
-void              _clutter_stage_window_schedule_update         (ClutterStageWindow *window,
-                                                                 int                 sync_delay);
-gint64            _clutter_stage_window_get_update_time         (ClutterStageWindow *window);
-void              _clutter_stage_window_clear_update_time       (ClutterStageWindow *window);
 
 void              _clutter_stage_window_set_accept_focus        (ClutterStageWindow *window,
                                                                  gboolean            accept_focus);
 
-void              _clutter_stage_window_redraw                  (ClutterStageWindow *window);
+void               _clutter_stage_window_redraw_view            (ClutterStageWindow *window,
+                                                                 ClutterStageView   *view);
 
 gboolean          _clutter_stage_window_can_clip_redraws        (ClutterStageWindow *window);
 
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index df3a4c3c3392a6d664062578e100a5ed7b380c7a..e9368fe444685f0b32aace8a1824987c6dd877db 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -60,11 +60,11 @@
 #include "clutter-debug.h"
 #include "clutter-enum-types.h"
 #include "clutter-event-private.h"
+#include "clutter-frame-clock.h"
 #include "clutter-id-pool.h"
 #include "clutter-input-device-private.h"
 #include "clutter-main.h"
 #include "clutter-marshal.h"
-#include "clutter-master-clock.h"
 #include "clutter-mutter.h"
 #include "clutter-paint-context-private.h"
 #include "clutter-paint-volume-private.h"
@@ -139,13 +139,13 @@ struct _ClutterStagePrivate
 
   int update_freeze_count;
 
-  gboolean needs_update;
+  gboolean needs_update_devices;
+  gboolean pending_finish_queue_redraws;
 
   guint redraw_pending         : 1;
   guint throttle_motion_events : 1;
   guint min_size_changed       : 1;
   guint motion_events_enabled  : 1;
-  guint stage_was_relayout     : 1;
   guint actor_needs_immediate_relayout : 1;
 };
 
@@ -166,7 +166,10 @@ enum
   ACTIVATE,
   DEACTIVATE,
   DELETE_EVENT,
+  BEFORE_UPDATE,
+  BEFORE_PAINT,
   AFTER_PAINT,
+  AFTER_UPDATE,
   PAINT_VIEW,
   PRESENTED,
 
@@ -177,7 +180,6 @@ static guint stage_signals[LAST_SIGNAL] = { 0, };
 
 static const ClutterColor default_stage_color = { 255, 255, 255, 255 };
 
-static void clutter_stage_maybe_finish_queue_redraws (ClutterStage *stage);
 static void free_queue_redraw_entry (ClutterStageQueueRedrawEntry *entry);
 static void capture_view_into (ClutterStage          *stage,
                                gboolean               paint,
@@ -890,9 +892,31 @@ clutter_stage_paint_view (ClutterStage         *stage,
 }
 
 void
-_clutter_stage_emit_after_paint (ClutterStage *stage)
+clutter_stage_emit_before_update (ClutterStage     *stage,
+                                  ClutterStageView *view)
 {
-  g_signal_emit (stage, stage_signals[AFTER_PAINT], 0);
+  g_signal_emit (stage, stage_signals[BEFORE_UPDATE], 0, view);
+}
+
+void
+clutter_stage_emit_before_paint (ClutterStage     *stage,
+                                 ClutterStageView *view)
+{
+  g_signal_emit (stage, stage_signals[BEFORE_PAINT], 0, view);
+}
+
+void
+clutter_stage_emit_after_paint (ClutterStage     *stage,
+                                ClutterStageView *view)
+{
+  g_signal_emit (stage, stage_signals[AFTER_PAINT], 0, view);
+}
+
+void
+clutter_stage_emit_after_update (ClutterStage     *stage,
+                                 ClutterStageView *view)
+{
+  g_signal_emit (stage, stage_signals[AFTER_UPDATE], 0, view);
 }
 
 static gboolean
@@ -938,7 +962,7 @@ clutter_stage_show (ClutterActor *self)
 
   /* Possibly do an allocation run so that the stage will have the
      right size before we map it */
-  _clutter_stage_maybe_relayout (self);
+  clutter_stage_maybe_relayout (self);
 
   g_assert (priv->impl != NULL);
   _clutter_stage_window_show (priv->impl, TRUE);
@@ -1051,11 +1075,7 @@ _clutter_stage_queue_event (ClutterStage *stage,
   g_queue_push_tail (priv->event_queue, event);
 
   if (first_event)
-    {
-      ClutterMasterClock *master_clock = _clutter_master_clock_get_default ();
-      _clutter_master_clock_start_running (master_clock);
-      clutter_stage_schedule_update (stage);
-    }
+    clutter_stage_schedule_update (stage);
 }
 
 gboolean
@@ -1169,28 +1189,6 @@ _clutter_stage_process_queued_events (ClutterStage *stage)
   g_object_unref (stage);
 }
 
-/**
- * _clutter_stage_needs_update:
- * @stage: A #ClutterStage
- *
- * Determines if _clutter_stage_do_update() needs to be called.
- *
- * Return value: %TRUE if the stage need layout or painting
- */
-gboolean
-_clutter_stage_needs_update (ClutterStage *stage)
-{
-  ClutterStagePrivate *priv;
-
-  g_return_val_if_fail (CLUTTER_IS_STAGE (stage), FALSE);
-
-  priv = stage->priv;
-
-  return (priv->redraw_pending ||
-          priv->needs_update ||
-          priv->pending_relayouts != NULL);
-}
-
 void
 clutter_stage_queue_actor_relayout (ClutterStage *stage,
                                     ClutterActor *actor)
@@ -1205,7 +1203,7 @@ clutter_stage_queue_actor_relayout (ClutterStage *stage,
 }
 
 void
-_clutter_stage_maybe_relayout (ClutterActor *actor)
+clutter_stage_maybe_relayout (ClutterActor *actor)
 {
   ClutterStage *stage = CLUTTER_STAGE (actor);
   ClutterStagePrivate *priv = stage->priv;
@@ -1217,6 +1215,8 @@ _clutter_stage_maybe_relayout (ClutterActor *actor)
   if (priv->pending_relayouts == NULL)
     return;
 
+  COGL_TRACE_BEGIN_SCOPED (ClutterStageRelayout, "Layout");
+
   CLUTTER_NOTE (ACTOR, ">>> Recomputing layout");
 
   stolen_list = g_steal_pointer (&priv->pending_relayouts);
@@ -1250,62 +1250,24 @@ _clutter_stage_maybe_relayout (ClutterActor *actor)
   CLUTTER_NOTE (ACTOR, "<<< Completed recomputing layout of %d subtrees", count);
 
   if (count)
-    priv->stage_was_relayout = TRUE;
+    priv->needs_update_devices = TRUE;
 }
 
-static void
-clutter_stage_do_redraw (ClutterStage *stage)
+GSList *
+clutter_stage_find_updated_devices (ClutterStage *stage)
 {
-  ClutterActor *actor = CLUTTER_ACTOR (stage);
   ClutterStagePrivate *priv = stage->priv;
-
-  if (CLUTTER_ACTOR_IN_DESTRUCTION (stage))
-    return;
-
-  if (priv->impl == NULL)
-    return;
-
-  CLUTTER_NOTE (PAINT, "Redraw started for stage '%s'[%p]",
-                _clutter_actor_get_debug_name (actor),
-                stage);
-
-  if (_clutter_context_get_show_fps ())
-    {
-      if (priv->fps_timer == NULL)
-        priv->fps_timer = g_timer_new ();
-    }
-
-  _clutter_stage_window_redraw (priv->impl);
-
-  if (_clutter_context_get_show_fps ())
-    {
-      priv->timer_n_frames += 1;
-
-      if (g_timer_elapsed (priv->fps_timer, NULL) >= 1.0)
-        {
-          g_print ("*** FPS for %s: %i ***\n",
-                   _clutter_actor_get_debug_name (actor),
-                   priv->timer_n_frames);
-
-          priv->timer_n_frames = 0;
-          g_timer_start (priv->fps_timer);
-        }
-    }
-
-  CLUTTER_NOTE (PAINT, "Redraw finished for stage '%s'[%p]",
-                _clutter_actor_get_debug_name (actor),
-                stage);
-}
-
-static GSList *
-_clutter_stage_check_updated_pointers (ClutterStage *stage)
-{
   ClutterBackend *backend;
   ClutterSeat *seat;
   GSList *updating = NULL;
   const GList *l, *devices;
   graphene_point_t point;
 
+  if (!priv->needs_update_devices)
+    return NULL;
+
+  priv->needs_update_devices = FALSE;
+
   backend = clutter_get_default_backend ();
   seat = clutter_backend_get_default_seat (backend);
   devices = clutter_seat_peek_devices (seat);
@@ -1351,8 +1313,8 @@ _clutter_stage_check_updated_pointers (ClutterStage *stage)
   return updating;
 }
 
-static void
-update_actor_stage_views (ClutterStage *stage)
+void
+clutter_stage_update_actor_stage_views (ClutterStage *stage)
 {
   ClutterActor *actor = CLUTTER_ACTOR (stage);
   ClutterStagePrivate *priv = stage->priv;
@@ -1379,92 +1341,25 @@ update_actor_stage_views (ClutterStage *stage)
         break;
 
       priv->actor_needs_immediate_relayout = FALSE;
-      _clutter_stage_maybe_relayout (actor);
+      clutter_stage_maybe_relayout (actor);
     }
 
   g_warn_if_fail (!priv->actor_needs_immediate_relayout);
 }
 
-/**
- * _clutter_stage_do_update:
- * @stage: A #ClutterStage
- *
- * Handles per-frame layout and repaint for the stage.
- *
- * Return value: %TRUE if the stage was updated
- */
-gboolean
-_clutter_stage_do_update (ClutterStage *stage)
+void
+clutter_stage_update_devices (ClutterStage *stage,
+                              GSList       *devices)
 {
-  ClutterStagePrivate *priv = stage->priv;
-  gboolean stage_was_relayout = priv->stage_was_relayout;
-  GSList *pointers = NULL;
-
-  priv->stage_was_relayout = FALSE;
-
-  priv->needs_update = FALSE;
-
-  /* if the stage is being destroyed, or if the destruction already
-   * happened and we don't have an StageWindow any more, then we
-   * should bail out
-   */
-  if (CLUTTER_ACTOR_IN_DESTRUCTION (stage) || priv->impl == NULL)
-    return FALSE;
-
-  if (!CLUTTER_ACTOR_IS_REALIZED (stage))
-    return FALSE;
-
-  COGL_TRACE_BEGIN_SCOPED (ClutterStageDoUpdate, "Update");
-
-  /* NB: We need to ensure we have an up to date layout *before* we
-   * check or clear the pending redraws flag since a relayout may
-   * queue a redraw.
-   */
-  COGL_TRACE_BEGIN (ClutterStageRelayout, "Layout");
-
-  _clutter_stage_maybe_relayout (CLUTTER_ACTOR (stage));
-
-  COGL_TRACE_END (ClutterStageRelayout);
-
-  if (!priv->redraw_pending)
-    return FALSE;
-
-  if (stage_was_relayout)
-    pointers = _clutter_stage_check_updated_pointers (stage);
-
-  update_actor_stage_views (stage);
-
-  COGL_TRACE_BEGIN (ClutterStagePaint, "Paint");
-
-  clutter_stage_maybe_finish_queue_redraws (stage);
-  clutter_stage_do_redraw (stage);
-
-  COGL_TRACE_END (ClutterStagePaint);
-
-  /* reset the guard, so that new redraws are possible */
-  priv->redraw_pending = FALSE;
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  if (priv->redraw_count > 0)
-    {
-      CLUTTER_NOTE (SCHEDULER, "Queued %lu redraws during the last cycle",
-                    priv->redraw_count);
-
-      priv->redraw_count = 0;
-    }
-#endif /* CLUTTER_ENABLE_DEBUG */
+  GSList *l;
 
-  COGL_TRACE_BEGIN (ClutterStagePick, "Pick");
+  COGL_TRACE_BEGIN (ClutterStageUpdateDevices, "UpdateDevices");
 
-  while (pointers)
+  for (l = devices; l; l = l->next)
     {
-      clutter_input_device_update (pointers->data, NULL, TRUE);
-      pointers = g_slist_delete_link (pointers, pointers);
+      ClutterInputDevice *device = l->data;
+      clutter_input_device_update (device, NULL, TRUE);
     }
-
-  COGL_TRACE_END (ClutterStagePick);
-
-  return TRUE;
 }
 
 static void
@@ -1564,9 +1459,6 @@ _clutter_stage_has_full_redraw_queued (ClutterStage *stage)
   if (CLUTTER_ACTOR_IN_DESTRUCTION (stage))
     return FALSE;
 
-  if (!stage->priv->redraw_pending)
-    return FALSE;
-
   return is_full_stage_redraw_queued (stage);
 }
 
@@ -1995,10 +1887,39 @@ clutter_stage_class_init (ClutterStageClass *klass)
                   G_TYPE_BOOLEAN, 1,
                   CLUTTER_TYPE_EVENT | G_SIGNAL_TYPE_STATIC_SCOPE);
 
+  /**
+   * ClutterStage::before-update:
+   * @stage: the #ClutterStage
+   * @view: a #ClutterStageView
+   */
+  stage_signals[BEFORE_UPDATE] =
+    g_signal_new (I_("before-update"),
+                  G_TYPE_FROM_CLASS (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  CLUTTER_TYPE_STAGE_VIEW);
+
+  /**
+   * ClutterStage::before-paint:
+   * @stage: the stage that received the event
+   * @view: a #ClutterStageView
+   *
+   * The ::before-paint signal is emitted before the stage is painted.
+   */
+  stage_signals[BEFORE_PAINT] =
+    g_signal_new (I_("before-paint"),
+                  G_TYPE_FROM_CLASS (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  CLUTTER_TYPE_STAGE_VIEW);
   /**
    * ClutterStage::after-paint:
    * @stage: the stage that received the event
-   * @paint_Context: the paint context
+   * @view: a #ClutterStageView
    *
    * The ::after-paint signal is emitted after the stage is painted,
    * but before the results are displayed on the screen.
@@ -2011,7 +1932,22 @@ clutter_stage_class_init (ClutterStageClass *klass)
                   G_SIGNAL_RUN_LAST,
                   0, /* no corresponding vfunc */
                   NULL, NULL, NULL,
-                  G_TYPE_NONE, 0);
+                  G_TYPE_NONE, 1,
+                  CLUTTER_TYPE_STAGE_VIEW);
+
+  /**
+   * ClutterStage::after-update:
+   * @stage: the #ClutterStage
+   * @view: a #ClutterStageView
+   */
+  stage_signals[AFTER_UPDATE] =
+    g_signal_new (I_("after-update"),
+                  G_TYPE_FROM_CLASS (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  CLUTTER_TYPE_STAGE_VIEW);
 
   /**
    * ClutterStage::paint-view:
@@ -2039,7 +1975,7 @@ clutter_stage_class_init (ClutterStageClass *klass)
   /**
    * ClutterStage::presented: (skip)
    * @stage: the stage that received the event
-   * @frame_event: a #CoglFrameEvent
+   * @view: the #ClutterStageView presented
    * @frame_info: a #ClutterFrameInfo
    *
    * Signals that the #ClutterStage was presented on the screen to the user.
@@ -2048,10 +1984,11 @@ clutter_stage_class_init (ClutterStageClass *klass)
     g_signal_new (I_("presented"),
                   G_TYPE_FROM_CLASS (gobject_class),
                   G_SIGNAL_RUN_LAST,
-                  0, NULL, NULL,
-                  _clutter_marshal_VOID__INT_POINTER,
+                  0,
+                  NULL, NULL, NULL,
                   G_TYPE_NONE, 2,
-                  G_TYPE_INT, G_TYPE_POINTER);
+                  CLUTTER_TYPE_STAGE_VIEW,
+                  G_TYPE_POINTER);
 
   klass->activate = clutter_stage_real_activate;
   klass->deactivate = clutter_stage_real_deactivate;
@@ -2953,14 +2890,15 @@ _clutter_stage_maybe_setup_viewport (ClutterStage     *stage,
 #undef _DEG_TO_RAD
 
 /**
- * clutter_stage_is_redraw_queued: (skip)
+ * clutter_stage_is_redraw_queued_on_view: (skip)
  */
 gboolean
-clutter_stage_is_redraw_queued (ClutterStage *stage)
+clutter_stage_is_redraw_queued_on_view (ClutterStage     *stage,
+                                        ClutterStageView *view)
 {
-  ClutterStagePrivate *priv = stage->priv;
+  clutter_stage_maybe_finish_queue_redraws (stage);
 
-  return priv->redraw_pending;
+  return clutter_stage_view_has_redraw_clip (view);
 }
 
 void
@@ -3137,6 +3075,7 @@ void
 clutter_stage_schedule_update (ClutterStage *stage)
 {
   ClutterStageWindow *stage_window;
+  GList *l;
 
   if (CLUTTER_ACTOR_IN_DESTRUCTION (stage))
     return;
@@ -3145,54 +3084,12 @@ clutter_stage_schedule_update (ClutterStage *stage)
   if (stage_window == NULL)
     return;
 
-  stage->priv->needs_update = TRUE;
-
-  return _clutter_stage_window_schedule_update (stage_window,
-                                                stage->priv->sync_delay);
-}
-
-/**
- * _clutter_stage_get_update_time:
- * @stage: a #ClutterStage actor
- *
- * Returns the earliest time in which the stage is ready to update. The update
- * time is set when clutter_stage_schedule_update() is called. This can then
- * be used by e.g. the #ClutterMasterClock to know when the stage needs to be
- * redrawn.
- *
- * Returns: -1 if no redraw is needed; 0 if the backend doesn't know, or the
- * timestamp (in microseconds) otherwise.
- */
-gint64
-_clutter_stage_get_update_time (ClutterStage *stage)
-{
-  ClutterStageWindow *stage_window;
-
-  if (CLUTTER_ACTOR_IN_DESTRUCTION (stage))
-    return 0;
-
-  stage_window = _clutter_stage_get_window (stage);
-  if (stage_window == NULL)
-    return 0;
-
-  return _clutter_stage_window_get_update_time (stage_window);
-}
-
-/**
- * _clutter_stage_clear_update_time:
- * @stage: a #ClutterStage actor
- *
- * Resets the update time. Call this after a redraw, so that the update time
- * can again be updated.
- */
-void
-_clutter_stage_clear_update_time (ClutterStage *stage)
-{
-  ClutterStageWindow *stage_window;
+  for (l = clutter_stage_peek_stage_views (stage); l; l = l->next)
+    {
+      ClutterStageView *view = l->data;
 
-  stage_window = _clutter_stage_get_window (stage);
-  if (stage_window)
-    _clutter_stage_window_clear_update_time (stage_window);
+      clutter_stage_view_schedule_update (view);
+    }
 }
 
 ClutterPaintVolume *
@@ -3260,17 +3157,26 @@ _clutter_stage_queue_actor_redraw (ClutterStage                 *stage,
    */
   priv->cached_pick_mode = CLUTTER_PICK_NONE;
 
-  if (!priv->redraw_pending)
+  if (!priv->pending_finish_queue_redraws)
     {
-      ClutterMasterClock *master_clock;
+      GList *l;
+
+      for (l = clutter_stage_peek_stage_views (stage); l; l = l->next)
+        {
+          ClutterStageView *view = l->data;
 
+          clutter_stage_view_schedule_update (view);
+        }
+
+      priv->pending_finish_queue_redraws = TRUE;
+    }
+
+  if (!priv->redraw_pending)
+    {
       CLUTTER_NOTE (PAINT, "First redraw request");
 
       clutter_stage_schedule_update (stage);
       priv->redraw_pending = TRUE;
-
-      master_clock = _clutter_master_clock_get_default ();
-      _clutter_master_clock_start_running (master_clock);
     }
 #ifdef CLUTTER_ENABLE_DEBUG
   else
@@ -3356,9 +3262,18 @@ _clutter_stage_queue_redraw_entry_invalidate (ClutterStageQueueRedrawEntry *entr
     }
 }
 
-static void
+void
 clutter_stage_maybe_finish_queue_redraws (ClutterStage *stage)
 {
+  ClutterStagePrivate *priv = stage->priv;
+
+  COGL_TRACE_BEGIN_SCOPED (ClutterStageFinishQueueRedraws, "FinishQueueRedraws");
+
+  if (!priv->pending_finish_queue_redraws)
+    return;
+
+  priv->pending_finish_queue_redraws = FALSE;
+
   /* Note: we have to repeat until the pending_queue_redraws list is
    * empty because actors are allowed to queue redraws in response to
    * the queue-redraw signal. For example Clone actors or
@@ -3671,27 +3586,6 @@ clutter_stage_set_sync_delay (ClutterStage *stage,
   stage->priv->sync_delay = sync_delay;
 }
 
-/**
- * clutter_stage_skip_sync_delay:
- * @stage: a #ClutterStage
- *
- * Causes the next frame for the stage to be drawn as quickly as
- * possible, ignoring any delay that clutter_stage_set_sync_delay()
- * would normally cause.
- *
- * Since: 1.14
- * Stability: unstable
- */
-void
-clutter_stage_skip_sync_delay (ClutterStage *stage)
-{
-  ClutterStageWindow *stage_window;
-
-  stage_window = _clutter_stage_get_window (stage);
-  if (stage_window)
-    _clutter_stage_window_schedule_update (stage_window, -1);
-}
-
 int64_t
 clutter_stage_get_frame_counter (ClutterStage          *stage)
 {
@@ -3702,12 +3596,11 @@ clutter_stage_get_frame_counter (ClutterStage          *stage)
 }
 
 void
-_clutter_stage_presented (ClutterStage     *stage,
-                          CoglFrameEvent    frame_event,
-                          ClutterFrameInfo *frame_info)
+clutter_stage_presented (ClutterStage     *stage,
+                         ClutterStageView *view,
+                         ClutterFrameInfo *frame_info)
 {
-  g_signal_emit (stage, stage_signals[PRESENTED], 0,
-                 (int) frame_event, frame_info);
+  g_signal_emit (stage, stage_signals[PRESENTED], 0, view, frame_info);
 }
 
 static void
@@ -4047,61 +3940,6 @@ clutter_stage_capture_into (ClutterStage          *stage,
     }
 }
 
-/**
- * clutter_stage_freeze_updates:
- *
- * Freezing updates makes Clutter stop processing events,
- * redrawing, and advancing timelines, by pausing the master clock. This is
- * necessary when implementing a display server, to ensure that Clutter doesn't
- * keep trying to page flip when DRM master has been dropped, e.g. when VT
- * switched away.
- *
- * The master clock starts out running, so if you are VT switched away on
- * startup, you need to call this immediately.
- *
- * To thaw updates, use clutter_stage_thaw_updates().
- */
-void
-clutter_stage_freeze_updates (ClutterStage *stage)
-{
-  ClutterStagePrivate *priv = stage->priv;
-
-  priv->update_freeze_count++;
-  if (priv->update_freeze_count == 1)
-    {
-      ClutterMasterClock *master_clock;
-
-      master_clock = _clutter_master_clock_get_default ();
-      _clutter_master_clock_set_paused (master_clock, TRUE);
-    }
-}
-
-/**
- * clutter_stage_thaw_updates:
- *
- * Resumes a master clock that has previously been frozen with
- * clutter_stage_freeze_updates(), and start pumping the master clock
- * again at the next iteration. Note that if you're switching back to your
- * own VT, you should probably also queue a stage redraw with
- * clutter_stage_ensure_redraw().
- */
-void
-clutter_stage_thaw_updates (ClutterStage *stage)
-{
-  ClutterStagePrivate *priv = stage->priv;
-
-  g_assert (priv->update_freeze_count > 0);
-
-  priv->update_freeze_count--;
-  if (priv->update_freeze_count == 0)
-    {
-      ClutterMasterClock *master_clock;
-
-      master_clock = _clutter_master_clock_get_default ();
-      _clutter_master_clock_set_paused (master_clock, FALSE);
-    }
-}
-
 /**
  * clutter_stage_peek_stage_views: (skip)
  */
diff --git a/clutter/clutter/clutter-stage.h b/clutter/clutter/clutter-stage.h
index f3006f093b126a83158305d00237f4b666f15cdd..a7ba0ceddb310441c78eafa305b2033052576654 100644
--- a/clutter/clutter/clutter-stage.h
+++ b/clutter/clutter/clutter-stage.h
@@ -197,7 +197,8 @@ CLUTTER_EXPORT
 void            clutter_stage_ensure_viewport                   (ClutterStage          *stage);
 
 CLUTTER_EXPORT
-gboolean        clutter_stage_is_redraw_queued                  (ClutterStage          *stage);
+gboolean        clutter_stage_is_redraw_queued_on_view          (ClutterStage          *stage,
+                                                                 ClutterStageView      *view);
 
 #ifdef CLUTTER_ENABLE_EXPERIMENTAL_API
 CLUTTER_EXPORT
diff --git a/clutter/clutter/clutter-timeline-private.h b/clutter/clutter/clutter-timeline-private.h
new file mode 100644
index 0000000000000000000000000000000000000000..38e712bfda05ca90e3941a91d1ee21884666f8fb
--- /dev/null
+++ b/clutter/clutter/clutter-timeline-private.h
@@ -0,0 +1,33 @@
+/*
+ * Clutter.
+ *
+ * An OpenGL based 'interactive canvas' library.
+ *
+ * Authored By: Emmanuele Bassi <ebassi@linux.intel.com>
+ *
+ * Copyright (C) 2009  Intel Corporation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CLUTTER_TIMELINE_PRIVATE_H
+#define CLUTTER_TIMELINE_PRIVATE_H
+
+void                    _clutter_timeline_advance                       (ClutterTimeline    *timeline,
+                                                                         int64_t             tick_time);
+int64_t                 _clutter_timeline_get_delta                     (ClutterTimeline    *timeline);
+void                    _clutter_timeline_do_tick                       (ClutterTimeline    *timeline,
+                                                                         int64_t             tick_time);
+
+#endif /* CLUTTER_TIMELINE_PRIVATE_H */
diff --git a/clutter/clutter/clutter-timeline.c b/clutter/clutter/clutter-timeline.c
index aff878c3132b751283acb26ee37ebae1d1d271b1..265a09b5be81de715fa99fc1baccad131aa57ad5 100644
--- a/clutter/clutter/clutter-timeline.c
+++ b/clutter/clutter/clutter-timeline.c
@@ -95,20 +95,31 @@
 #include "clutter-build-config.h"
 
 #include "clutter-timeline.h"
+#include "deprecated/clutter-timeline.h"
 
 #include "clutter-debug.h"
 #include "clutter-easing.h"
 #include "clutter-enum-types.h"
+#include "clutter-frame-clock.h"
 #include "clutter-main.h"
 #include "clutter-marshal.h"
-#include "clutter-master-clock.h"
 #include "clutter-private.h"
 #include "clutter-scriptable.h"
+#include "clutter-timeline-private.h"
 
 struct _ClutterTimelinePrivate
 {
   ClutterTimelineDirection direction;
 
+  ClutterFrameClock *custom_frame_clock;
+  ClutterFrameClock *frame_clock;
+
+  ClutterActor *actor;
+  gulong actor_destroy_handler_id;
+  gulong actor_stage_views_handler_id;
+  gulong stage_stage_views_handler_id;
+  ClutterActor *stage;
+
   guint delay_id;
 
   /* The total length in milliseconds of this timeline */
@@ -170,12 +181,14 @@ enum
 {
   PROP_0,
 
+  PROP_ACTOR,
   PROP_DELAY,
   PROP_DURATION,
   PROP_DIRECTION,
   PROP_AUTO_REVERSE,
   PROP_REPEAT_COUNT,
   PROP_PROGRESS_MODE,
+  PROP_FRAME_CLOCK,
 
   PROP_LAST
 };
@@ -196,6 +209,8 @@ enum
 
 static guint timeline_signals[LAST_SIGNAL] = { 0, };
 
+static void update_frame_clock (ClutterTimeline *timeline);
+
 static void clutter_scriptable_iface_init (ClutterScriptableIface *iface);
 
 G_DEFINE_TYPE_WITH_CODE (ClutterTimeline, clutter_timeline, G_TYPE_OBJECT,
@@ -287,6 +302,177 @@ clutter_timeline_add_marker_internal (ClutterTimeline *timeline,
   g_hash_table_insert (priv->markers_by_name, marker->name, marker);
 }
 
+static void
+on_actor_destroyed (ClutterActor    *actor,
+                    ClutterTimeline *timeline)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+
+  priv->actor = NULL;
+}
+
+/**
+ * clutter_timeline_get_actor:
+ * @timeline: a #ClutterTimeline
+ *
+ * Get the actor the timeline is associated with.
+ *
+ * Returns: (transfer none): the associated #ClutterActor
+ */
+ClutterActor *
+clutter_timeline_get_actor (ClutterTimeline *timeline)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+
+  return priv->actor;
+}
+
+static void
+maybe_add_timeline (ClutterTimeline *timeline)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+
+  if (!priv->frame_clock)
+    return;
+
+  clutter_frame_clock_add_timeline (priv->frame_clock, timeline);
+}
+
+static void
+maybe_remove_timeline (ClutterTimeline *timeline)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+
+  if (!priv->frame_clock)
+    return;
+
+  clutter_frame_clock_remove_timeline (priv->frame_clock, timeline);
+}
+
+static void
+set_frame_clock_internal (ClutterTimeline   *timeline,
+                          ClutterFrameClock *frame_clock)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+
+  if (priv->frame_clock == frame_clock)
+    return;
+
+  if (priv->frame_clock && priv->is_playing)
+    maybe_remove_timeline (timeline);
+
+  g_set_object (&priv->frame_clock, frame_clock);
+
+  g_object_notify_by_pspec (G_OBJECT (timeline),
+                            obj_props[PROP_FRAME_CLOCK]);
+
+  if (priv->is_playing)
+    maybe_add_timeline (timeline);
+}
+
+static void
+on_stage_stage_views_changed (ClutterActor    *stage,
+                              ClutterTimeline *timeline)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+
+  g_clear_signal_handler (&priv->stage_stage_views_handler_id, priv->stage);
+  priv->stage = NULL;
+
+  update_frame_clock (timeline);
+}
+
+static void
+update_frame_clock (ClutterTimeline *timeline)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+  ClutterFrameClock *frame_clock = NULL;
+  ClutterActor *stage;
+
+  if (!priv->actor)
+    goto out;
+
+  frame_clock = clutter_actor_pick_frame_clock (priv->actor);
+  if (frame_clock)
+    {
+      g_clear_signal_handler (&priv->stage_stage_views_handler_id, priv->stage);
+      goto out;
+    }
+
+  stage = clutter_actor_get_stage (priv->actor);
+  if (!stage)
+    {
+      if (priv->is_playing)
+        g_warning ("Timelines with detached actors are not supported");
+      goto out;
+    }
+
+  if (priv->stage_stage_views_handler_id > 0)
+    goto out;
+
+  priv->stage_stage_views_handler_id =
+    g_signal_connect (stage, "stage-views-changed",
+                      G_CALLBACK (on_stage_stage_views_changed),
+                      timeline);
+  priv->stage = stage;
+
+out:
+  set_frame_clock_internal (timeline, frame_clock);
+}
+
+static void
+on_actor_stage_views_changed (ClutterActor    *actor,
+                              ClutterTimeline *timeline)
+{
+  update_frame_clock (timeline);
+}
+
+/**
+ * clutter_timeline_set_actor:
+ * @timeline: a #ClutterTimeline
+ * @actor: (nullable): a #ClutterActor
+ *
+ * Set the actor the timeline is associated with.
+ */
+void
+clutter_timeline_set_actor (ClutterTimeline *timeline,
+                            ClutterActor    *actor)
+{
+  ClutterTimelinePrivate *priv = timeline->priv;
+
+  g_return_if_fail (!actor || (actor && !priv->custom_frame_clock));
+
+  if (priv->actor)
+    {
+      g_clear_signal_handler (&priv->actor_destroy_handler_id, priv->actor);
+      g_clear_signal_handler (&priv->actor_stage_views_handler_id, priv->actor);
+      g_clear_signal_handler (&priv->stage_stage_views_handler_id, priv->stage);
+      priv->stage = NULL;
+      priv->actor = NULL;
+
+      if (priv->is_playing)
+        maybe_remove_timeline (timeline);
+
+      priv->frame_clock = NULL;
+    }
+
+  priv->actor = actor;
+
+  if (priv->actor)
+    {
+      priv->actor_destroy_handler_id =
+        g_signal_connect (priv->actor, "destroy",
+                          G_CALLBACK (on_actor_destroyed),
+                          timeline);
+      priv->actor_stage_views_handler_id =
+        g_signal_connect (priv->actor, "stage-views-changed",
+                          G_CALLBACK (on_actor_stage_views_changed),
+                          timeline);
+    }
+
+  update_frame_clock (timeline);
+}
+
 /* Scriptable */
 typedef struct _ParseClosure {
   ClutterTimeline *timeline;
@@ -428,6 +614,10 @@ clutter_timeline_set_property (GObject      *object,
 
   switch (prop_id)
     {
+    case PROP_ACTOR:
+      clutter_timeline_set_actor (timeline, g_value_get_object (value));
+      break;
+
     case PROP_DELAY:
       clutter_timeline_set_delay (timeline, g_value_get_uint (value));
       break;
@@ -452,6 +642,10 @@ clutter_timeline_set_property (GObject      *object,
       clutter_timeline_set_progress_mode (timeline, g_value_get_enum (value));
       break;
 
+    case PROP_FRAME_CLOCK:
+      clutter_timeline_set_frame_clock (timeline, g_value_get_object (value));
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -469,6 +663,10 @@ clutter_timeline_get_property (GObject    *object,
 
   switch (prop_id)
     {
+    case PROP_ACTOR:
+      g_value_set_object (value, priv->actor);
+      break;
+
     case PROP_DELAY:
       g_value_set_uint (value, priv->delay);
       break;
@@ -493,6 +691,10 @@ clutter_timeline_get_property (GObject    *object,
       g_value_set_enum (value, priv->progress_mode);
       break;
 
+    case PROP_FRAME_CLOCK:
+      g_value_set_object (value, priv->frame_clock);
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -504,16 +706,14 @@ clutter_timeline_finalize (GObject *object)
 {
   ClutterTimeline *self = CLUTTER_TIMELINE (object);
   ClutterTimelinePrivate *priv = self->priv;
-  ClutterMasterClock *master_clock;
 
   if (priv->markers_by_name)
     g_hash_table_destroy (priv->markers_by_name);
 
   if (priv->is_playing)
-    {
-      master_clock = _clutter_master_clock_get_default ();
-      _clutter_master_clock_remove_timeline (master_clock, self);
-    }
+    maybe_remove_timeline (self);
+
+  g_clear_object (&priv->frame_clock);
 
   G_OBJECT_CLASS (clutter_timeline_parent_class)->finalize (object);
 }
@@ -528,6 +728,14 @@ clutter_timeline_dispose (GObject *object)
 
   clutter_timeline_cancel_delay (self);
 
+  if (priv->actor)
+    {
+      g_clear_signal_handler (&priv->actor_destroy_handler_id, priv->actor);
+      g_clear_signal_handler (&priv->actor_stage_views_handler_id, priv->actor);
+      g_clear_signal_handler (&priv->stage_stage_views_handler_id, priv->stage);
+      priv->actor = NULL;
+    }
+
   if (priv->progress_notify != NULL)
     {
       priv->progress_notify (priv->progress_data);
@@ -544,6 +752,18 @@ clutter_timeline_class_init (ClutterTimelineClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
+  /**
+   * ClutterTimeline::actor:
+   *
+   * The actor the timeline is associated with. This will determine what frame
+   * clock will drive it.
+   */
+  obj_props[PROP_ACTOR] =
+    g_param_spec_object ("actor",
+                         P_("Actor"),
+                         P_("Associated ClutterActor"),
+                         CLUTTER_TYPE_ACTOR,
+                         G_PARAM_CONSTRUCT | CLUTTER_PARAM_READWRITE);
   /**
    * ClutterTimeline:delay:
    *
@@ -642,6 +862,18 @@ clutter_timeline_class_init (ClutterTimelineClass *klass)
                        CLUTTER_LINEAR,
                        CLUTTER_PARAM_READWRITE);
 
+  /**
+   * ClutterTimeline:frame-clock:
+   *
+   * The frame clock driving the timeline.
+   */
+  obj_props[PROP_FRAME_CLOCK] =
+    g_param_spec_object ("frame-clock",
+                         "Frame clock",
+                         "Frame clock driving the timeline",
+                         CLUTTER_TYPE_FRAME_CLOCK,
+                         G_PARAM_CONSTRUCT | CLUTTER_PARAM_READWRITE);
+
   object_class->dispose = clutter_timeline_dispose;
   object_class->finalize = clutter_timeline_finalize;
   object_class->set_property = clutter_timeline_set_property;
@@ -924,7 +1156,6 @@ set_is_playing (ClutterTimeline *timeline,
                 gboolean         is_playing)
 {
   ClutterTimelinePrivate *priv = timeline->priv;
-  ClutterMasterClock *master_clock;
 
   is_playing = !!is_playing;
 
@@ -933,15 +1164,17 @@ set_is_playing (ClutterTimeline *timeline,
 
   priv->is_playing = is_playing;
 
-  master_clock = _clutter_master_clock_get_default ();
   if (priv->is_playing)
     {
       priv->waiting_first_tick = TRUE;
       priv->current_repeat = 0;
-      _clutter_master_clock_add_timeline (master_clock, timeline);
+
+      maybe_add_timeline (timeline);
     }
   else
-    _clutter_master_clock_remove_timeline (master_clock, timeline);
+    {
+      maybe_remove_timeline (timeline);
+    }
 }
 
 static gboolean
@@ -1138,6 +1371,9 @@ clutter_timeline_start (ClutterTimeline *timeline)
   if (priv->duration == 0)
     return;
 
+  g_warn_if_fail ((priv->actor && clutter_actor_get_stage (priv->actor)) ||
+                  priv->frame_clock);
+
   if (priv->delay)
     priv->delay_id = clutter_threads_add_timeout (priv->delay,
                                                   delay_timeout_func,
@@ -1338,6 +1574,46 @@ clutter_timeline_new (guint duration_ms)
                        NULL);
 }
 
+/**
+ * clutter_timeline_new_for_actor:
+ * @actor: The #ClutterActor the timeline is associated with
+ * @duration_ms: Duration of the timeline in milliseconds
+ *
+ * Creates a new #ClutterTimeline with a duration of @duration milli seconds.
+ *
+ * Return value: the newly created #ClutterTimeline instance. Use
+ *   g_object_unref() when done using it
+ */
+ClutterTimeline *
+clutter_timeline_new_for_actor (ClutterActor *actor,
+                                unsigned int  duration_ms)
+{
+  return g_object_new (CLUTTER_TYPE_TIMELINE,
+                       "duration", duration_ms,
+                       "actor", actor,
+                       NULL);
+}
+
+/**
+ * clutter_timeline_new_for_frame_clock:
+ * @frame_clock: The #ClutterFrameClock the timeline is driven by
+ * @duration_ms: Duration of the timeline in milliseconds
+ *
+ * Creates a new #ClutterTimeline with a duration of @duration_ms milli seconds.
+ *
+ * Return value: the newly created #ClutterTimeline instance. Use
+ *   g_object_unref() when done using it
+ */
+ClutterTimeline *
+clutter_timeline_new_for_frame_clock (ClutterFrameClock *frame_clock,
+                                      unsigned int       duration_ms)
+{
+  return g_object_new (CLUTTER_TYPE_TIMELINE,
+                       "duration", duration_ms,
+                       "frame-clock", frame_clock,
+                       NULL);
+}
+
 /**
  * clutter_timeline_get_delay:
  * @timeline: a #ClutterTimeline
@@ -1600,7 +1876,7 @@ _clutter_timeline_do_tick (ClutterTimeline *timeline,
 
   /* Check the is_playing variable before performing the timeline tick.
    * This is necessary, as if a timeline is stopped in response to a
-   * master-clock generated signal of a different timeline, this code can
+   * frame clock generated signal of a different timeline, this code can
    * still be reached.
    */
   if (!priv->is_playing)
@@ -2418,3 +2694,32 @@ clutter_timeline_get_cubic_bezier_progress (ClutterTimeline  *timeline,
 
   return TRUE;
 }
+
+/**
+ * clutter_timeline_get_frame_clock: (skip)
+ */
+ClutterFrameClock *
+clutter_timeline_get_frame_clock (ClutterTimeline *timeline)
+{
+  g_return_val_if_fail (CLUTTER_IS_TIMELINE (timeline), NULL);
+
+  return timeline->priv->frame_clock;
+}
+
+void
+clutter_timeline_set_frame_clock (ClutterTimeline   *timeline,
+                                  ClutterFrameClock *frame_clock)
+{
+  ClutterTimelinePrivate *priv;
+
+  g_return_if_fail (CLUTTER_IS_TIMELINE (timeline));
+
+  priv = timeline->priv;
+
+  g_assert (!frame_clock || (frame_clock && !priv->actor));
+  g_return_if_fail (!frame_clock || (frame_clock && !priv->actor));
+
+  priv->custom_frame_clock = frame_clock;
+  if (!priv->actor)
+    set_frame_clock_internal (timeline, frame_clock);
+}
diff --git a/clutter/clutter/clutter-timeline.h b/clutter/clutter/clutter-timeline.h
index d6a5dde7b2cdd5ca3a0e8bf44d56f9e229a5344f..022a927ce23f4ea832dc291bae34c1e6a6a116ac 100644
--- a/clutter/clutter/clutter-timeline.h
+++ b/clutter/clutter/clutter-timeline.h
@@ -119,7 +119,19 @@ CLUTTER_EXPORT
 GType clutter_timeline_get_type (void) G_GNUC_CONST;
 
 CLUTTER_EXPORT
-ClutterTimeline *               clutter_timeline_new                            (guint                     duration_ms);
+ClutterTimeline *               clutter_timeline_new_for_actor                  (ClutterActor             *actor,
+                                                                                 unsigned int              duration_ms);
+
+CLUTTER_EXPORT
+ClutterTimeline *               clutter_timeline_new_for_frame_clock            (ClutterFrameClock        *frame_clock,
+                                                                                 unsigned int              duration_ms);
+
+CLUTTER_EXPORT
+ClutterActor *                  clutter_timeline_get_actor                      (ClutterTimeline          *timeline);
+
+CLUTTER_EXPORT
+void                            clutter_timeline_set_actor                      (ClutterTimeline          *timeline,
+                                                                                 ClutterActor             *actor);
 
 CLUTTER_EXPORT
 guint                           clutter_timeline_get_duration                   (ClutterTimeline          *timeline);
@@ -221,6 +233,13 @@ gint64                          clutter_timeline_get_duration_hint
 CLUTTER_EXPORT
 gint                            clutter_timeline_get_current_repeat             (ClutterTimeline          *timeline);
 
+CLUTTER_EXPORT
+ClutterFrameClock *             clutter_timeline_get_frame_clock                (ClutterTimeline           *timeline);
+
+CLUTTER_EXPORT
+void                            clutter_timeline_set_frame_clock                (ClutterTimeline           *timeline,
+                                                                                 ClutterFrameClock         *frame_clock);
+
 G_END_DECLS
 
 #endif /* _CLUTTER_TIMELINE_H__ */
diff --git a/clutter/clutter/clutter-transition-group.c b/clutter/clutter/clutter-transition-group.c
index 59801af4416ca9cf896aff6bb19c80803e9eda61..3d8c5a53b927932763d2d36a7f1bdf89b44b32e3 100644
--- a/clutter/clutter/clutter-transition-group.c
+++ b/clutter/clutter/clutter-transition-group.c
@@ -43,6 +43,7 @@
 
 #include "clutter-debug.h"
 #include "clutter-private.h"
+#include "clutter-timeline-private.h"
 
 struct _ClutterTransitionGroupPrivate
 {
diff --git a/clutter/clutter/clutter-transition.c b/clutter/clutter/clutter-transition.c
index 34f357c48f16d383920f458e5416f24f0bd92458..146c525460e1dc4829c97e2264ff2e8a07a374c9 100644
--- a/clutter/clutter/clutter-transition.c
+++ b/clutter/clutter/clutter-transition.c
@@ -364,6 +364,7 @@ clutter_transition_set_animatable (ClutterTransition *transition,
                                    ClutterAnimatable *animatable)
 {
   ClutterTransitionPrivate *priv;
+  ClutterActor *actor;
 
   g_return_if_fail (CLUTTER_IS_TRANSITION (transition));
   g_return_if_fail (animatable == NULL || CLUTTER_IS_ANIMATABLE (animatable));
@@ -383,6 +384,9 @@ clutter_transition_set_animatable (ClutterTransition *transition,
       priv->animatable = g_object_ref (animatable);
       clutter_transition_attach (transition, priv->animatable);
     }
+
+  actor = clutter_animatable_get_actor (animatable);
+  clutter_timeline_set_actor (CLUTTER_TIMELINE (transition), actor);
 }
 
 /**
diff --git a/clutter/clutter/clutter-types.h b/clutter/clutter/clutter-types.h
index 0c6400d93e11cd247c4059e54545c8bcc110d6ff..b9825327558d1ef2caa15c13b8fa816d4fce1628 100644
--- a/clutter/clutter/clutter-types.h
+++ b/clutter/clutter/clutter-types.h
@@ -57,6 +57,7 @@ typedef struct _ClutterActorIter                ClutterActorIter;
 typedef struct _ClutterPaintNode                ClutterPaintNode;
 typedef struct _ClutterContent                  ClutterContent; /* dummy */
 typedef struct _ClutterScrollActor	        ClutterScrollActor;
+typedef struct _ClutterFrameClock               ClutterFrameClock;
 
 typedef struct _ClutterInterval         	ClutterInterval;
 typedef struct _ClutterAnimatable       	ClutterAnimatable; /* dummy */
diff --git a/clutter/clutter/clutter.h b/clutter/clutter/clutter.h
index efa52fa4984b3e21442b60330218fd824a57fa8a..d09f8afed40348180eae47aabdffc9022933c668 100644
--- a/clutter/clutter/clutter.h
+++ b/clutter/clutter/clutter.h
@@ -63,6 +63,7 @@
 #include "clutter-feature.h"
 #include "clutter-fixed-layout.h"
 #include "clutter-flow-layout.h"
+#include "clutter-frame-clock.h"
 #include "clutter-gesture-action.h"
 #include "clutter-grid-layout.h"
 #include "clutter-image.h"
diff --git a/clutter/clutter/cogl/clutter-stage-cogl.c b/clutter/clutter/cogl/clutter-stage-cogl.c
index f7f71e6e169b0c41e5bd6d4d8176083bd1daa938..695c594bb404612ae54e4ad852f1186996e603ba 100644
--- a/clutter/clutter/cogl/clutter-stage-cogl.c
+++ b/clutter/clutter/cogl/clutter-stage-cogl.c
@@ -47,6 +47,7 @@
 #include "clutter-private.h"
 #include "clutter-stage-private.h"
 #include "clutter-stage-view-private.h"
+#include "cogl.h"
 
 #define MAX_STACK_RECTS 256
 
@@ -55,17 +56,25 @@ typedef struct _ClutterStageViewCoglPrivate
   /* Damage history, in stage view render target framebuffer coordinate space.
    */
   ClutterDamageHistory *damage_history;
+
+  guint notify_presented_handle_id;
 } ClutterStageViewCoglPrivate;
 
 G_DEFINE_TYPE_WITH_PRIVATE (ClutterStageViewCogl, clutter_stage_view_cogl,
                             CLUTTER_TYPE_STAGE_VIEW)
 
+typedef struct _ClutterStageCoglPrivate
+{
+  int64_t global_frame_counter;
+} ClutterStageCoglPrivate;
+
 static void
 clutter_stage_window_iface_init (ClutterStageWindowInterface *iface);
 
 G_DEFINE_TYPE_WITH_CODE (ClutterStageCogl,
                          _clutter_stage_cogl,
                          G_TYPE_OBJECT,
+                         G_ADD_PRIVATE (ClutterStageCogl)
                          G_IMPLEMENT_INTERFACE (CLUTTER_TYPE_STAGE_WINDOW,
                                                 clutter_stage_window_iface_init));
 
@@ -77,67 +86,12 @@ enum
   PROP_LAST
 };
 
-static void
-clutter_stage_cogl_schedule_update (ClutterStageWindow *stage_window,
-                                    gint                sync_delay);
-
 static void
 clutter_stage_cogl_unrealize (ClutterStageWindow *stage_window)
 {
   CLUTTER_NOTE (BACKEND, "Unrealizing Cogl stage [%p]", stage_window);
 }
 
-void
-_clutter_stage_cogl_presented (ClutterStageCogl *stage_cogl,
-                               CoglFrameEvent    frame_event,
-                               ClutterFrameInfo *frame_info)
-{
-
-  if (frame_event == COGL_FRAME_EVENT_SYNC)
-    {
-      /* Early versions of the swap_event implementation in Mesa
-       * deliver BufferSwapComplete event when not selected for,
-       * so if we get a swap event we aren't expecting, just ignore it.
-       *
-       * https://bugs.freedesktop.org/show_bug.cgi?id=27962
-       *
-       * FIXME: This issue can be hidden inside Cogl so we shouldn't
-       * need to care about this bug here.
-       */
-      if (stage_cogl->pending_swaps > 0)
-        stage_cogl->pending_swaps--;
-    }
-  else if (frame_event == COGL_FRAME_EVENT_COMPLETE)
-    {
-      gint64 presentation_time_cogl = frame_info->presentation_time;
-
-      if (presentation_time_cogl != 0)
-        {
-          ClutterBackend *backend = stage_cogl->backend;
-          CoglContext *context = clutter_backend_get_cogl_context (backend);
-          gint64 current_time_cogl = cogl_get_clock_time (context);
-          gint64 now = g_get_monotonic_time ();
-
-          stage_cogl->last_presentation_time =
-            now + (presentation_time_cogl - current_time_cogl) / 1000;
-        }
-
-      stage_cogl->refresh_rate = frame_info->refresh_rate;
-    }
-
-  _clutter_stage_presented (stage_cogl->wrapper, frame_event, frame_info);
-
-  if (frame_event == COGL_FRAME_EVENT_COMPLETE &&
-      stage_cogl->update_time != -1)
-    {
-      ClutterStageWindow *stage_window = CLUTTER_STAGE_WINDOW (stage_cogl);
-
-      stage_cogl->update_time = -1;
-      clutter_stage_cogl_schedule_update (stage_window,
-                                          stage_cogl->last_sync_delay);
-    }
-}
-
 static gboolean
 clutter_stage_cogl_realize (ClutterStageWindow *stage_window)
 {
@@ -158,101 +112,14 @@ clutter_stage_cogl_realize (ClutterStageWindow *stage_window)
   return TRUE;
 }
 
-static void
-clutter_stage_cogl_schedule_update (ClutterStageWindow *stage_window,
-                                    gint                sync_delay)
-{
-  ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_window);
-  gint64 now;
-  float refresh_rate;
-  gint64 refresh_interval;
-  int64_t min_render_time_allowed;
-  int64_t max_render_time_allowed;
-  int64_t next_presentation_time;
-
-  if (stage_cogl->update_time != -1)
-    return;
-
-  stage_cogl->last_sync_delay = sync_delay;
-
-  now = g_get_monotonic_time ();
-
-  if (sync_delay < 0)
-    {
-      stage_cogl->update_time = now;
-      return;
-    }
-
-  refresh_rate = stage_cogl->refresh_rate;
-  if (refresh_rate <= 0.0)
-    refresh_rate = clutter_get_default_frame_rate ();
-
-  refresh_interval = (gint64) (0.5 + G_USEC_PER_SEC / refresh_rate);
-  if (refresh_interval == 0)
-    {
-      stage_cogl->update_time = now;
-      return;
-    }
-
-  min_render_time_allowed = refresh_interval / 2;
-  max_render_time_allowed = refresh_interval - 1000 * sync_delay;
-
-  /* Be robust in the case of incredibly bogus refresh rate */
-  if (max_render_time_allowed <= 0)
-    {
-      g_warning ("Unsupported monitor refresh rate detected. "
-                 "(Refresh rate: %.3f, refresh interval: %" G_GINT64_FORMAT ")",
-                 refresh_rate,
-                 refresh_interval);
-      stage_cogl->update_time = now;
-      return;
-    }
-
-  if (min_render_time_allowed > max_render_time_allowed)
-    min_render_time_allowed = max_render_time_allowed;
-
-  next_presentation_time = stage_cogl->last_presentation_time + refresh_interval;
-
-  /* Get next_presentation_time closer to its final value, to reduce
-   * the number of while iterations below.
-   */
-  if (next_presentation_time < now)
-    {
-      int64_t last_virtual_presentation_time = now - now % refresh_interval;
-      int64_t hardware_clock_phase =
-        stage_cogl->last_presentation_time % refresh_interval;
-
-      next_presentation_time =
-        last_virtual_presentation_time + hardware_clock_phase;
-    }
-
-  while (next_presentation_time < now + min_render_time_allowed)
-    next_presentation_time += refresh_interval;
-
-  stage_cogl->update_time = next_presentation_time - max_render_time_allowed;
-
-  if (stage_cogl->update_time == stage_cogl->last_update_time)
-    stage_cogl->update_time = stage_cogl->last_update_time + refresh_interval;
-}
-
-static gint64
-clutter_stage_cogl_get_update_time (ClutterStageWindow *stage_window)
+static int64_t
+clutter_stage_cogl_get_frame_counter (ClutterStageWindow *stage_window)
 {
   ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_window);
+  ClutterStageCoglPrivate *priv =
+    _clutter_stage_cogl_get_instance_private (stage_cogl);
 
-  if (stage_cogl->pending_swaps)
-    return -1; /* in the future, indefinite */
-
-  return stage_cogl->update_time;
-}
-
-static void
-clutter_stage_cogl_clear_update_time (ClutterStageWindow *stage_window)
-{
-  ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_window);
-
-  stage_cogl->last_update_time = stage_cogl->update_time;
-  stage_cogl->update_time = -1;
+  return priv->global_frame_counter;
 }
 
 static ClutterActor *
@@ -355,12 +222,35 @@ paint_damage_region (ClutterStageWindow *stage_window,
   cogl_framebuffer_pop_matrix (framebuffer);
 }
 
+typedef struct _NotifyPresentedClosure
+{
+  ClutterStageView *view;
+  ClutterFrameInfo frame_info;
+} NotifyPresentedClosure;
+
 static gboolean
+notify_presented_idle (gpointer user_data)
+{
+  NotifyPresentedClosure *closure = user_data;
+  ClutterStageViewCogl *view_cogl = CLUTTER_STAGE_VIEW_COGL (closure->view);
+  ClutterStageViewCoglPrivate *view_priv =
+    clutter_stage_view_cogl_get_instance_private (view_cogl);
+
+  view_priv->notify_presented_handle_id = 0;
+  clutter_stage_view_notify_presented (closure->view, &closure->frame_info);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
 swap_framebuffer (ClutterStageWindow *stage_window,
                   ClutterStageView   *view,
                   cairo_region_t     *swap_region,
                   gboolean            swap_with_damage)
 {
+  ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_window);
+  ClutterStageCoglPrivate *priv =
+    _clutter_stage_cogl_get_instance_private (stage_cogl);
   CoglFramebuffer *framebuffer = clutter_stage_view_get_onscreen (view);
 
   clutter_stage_view_before_swap_buffer (view, swap_region);
@@ -369,6 +259,7 @@ swap_framebuffer (ClutterStageWindow *stage_window,
     {
       CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
       int *damage, n_rects, i;
+      CoglFrameInfo *frame_info;
 
       n_rects = cairo_region_num_rectangles (swap_region);
       damage = g_newa (int, n_rects * 4);
@@ -383,6 +274,9 @@ swap_framebuffer (ClutterStageWindow *stage_window,
           damage[i * 4 + 3] = rect.height;
         }
 
+      frame_info = cogl_frame_info_new (priv->global_frame_counter);
+      priv->global_frame_counter++;
+
       /* push on the screen */
       if (n_rects > 0 && !swap_with_damage)
         {
@@ -391,9 +285,8 @@ swap_framebuffer (ClutterStageWindow *stage_window,
                         onscreen);
 
           cogl_onscreen_swap_region (onscreen,
-                                     damage, n_rects);
-
-          return FALSE;
+                                     damage, n_rects,
+                                     frame_info);
         }
       else
         {
@@ -401,18 +294,35 @@ swap_framebuffer (ClutterStageWindow *stage_window,
                         onscreen);
 
           cogl_onscreen_swap_buffers_with_damage (onscreen,
-                                                  damage, n_rects);
-
-          return TRUE;
+                                                  damage, n_rects,
+                                                  frame_info);
         }
     }
   else
     {
+      ClutterStageViewCogl *view_cogl = CLUTTER_STAGE_VIEW_COGL (view);
+      ClutterStageViewCoglPrivate *view_priv =
+        clutter_stage_view_cogl_get_instance_private (view_cogl);
+      NotifyPresentedClosure *closure;
+
       CLUTTER_NOTE (BACKEND, "cogl_framebuffer_finish (framebuffer: %p)",
                     framebuffer);
       cogl_framebuffer_finish (framebuffer);
 
-      return FALSE;
+      closure = g_new0 (NotifyPresentedClosure, 1);
+      closure->view = view;
+      closure->frame_info = (ClutterFrameInfo) {
+        .frame_counter = priv->global_frame_counter,
+        .refresh_rate = clutter_stage_view_get_refresh_rate (view),
+        .presentation_time = g_get_monotonic_time (),
+      };
+      priv->global_frame_counter++;
+
+      g_warn_if_fail (view_priv->notify_presented_handle_id == 0);
+      view_priv->notify_presented_handle_id =
+        g_idle_add_full (G_PRIORITY_DEFAULT,
+                         notify_presented_idle,
+                         closure, g_free);
     }
 }
 
@@ -539,11 +449,11 @@ is_buffer_age_enabled (void)
          cogl_clutter_winsys_has_feature (COGL_WINSYS_FEATURE_BUFFER_AGE);
 }
 
-static gboolean
-clutter_stage_cogl_redraw_view (ClutterStageWindow *stage_window,
-                                ClutterStageView   *view)
+static void
+clutter_stage_cogl_redraw_view_primary (ClutterStageCogl *stage_cogl,
+                                        ClutterStageView *view)
 {
-  ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_window);
+  ClutterStageWindow *stage_window = CLUTTER_STAGE_WINDOW (stage_cogl);
   ClutterStageViewCogl *view_cogl = CLUTTER_STAGE_VIEW_COGL (view);
   ClutterStageViewCoglPrivate *view_priv =
     clutter_stage_view_cogl_get_instance_private (view_cogl);
@@ -562,7 +472,6 @@ clutter_stage_cogl_redraw_view (ClutterStageWindow *stage_window,
   float fb_scale;
   int fb_width, fb_height;
   int buffer_age = 0;
-  gboolean res;
 
   clutter_stage_view_get_layout (view, &view_rect);
   fb_scale = clutter_stage_view_get_scale (view);
@@ -629,7 +538,7 @@ clutter_stage_cogl_redraw_view (ClutterStageWindow *stage_window,
       redraw_clip = cairo_region_create_rectangle (&view_rect);
     }
 
-  g_return_val_if_fail (!cairo_region_is_empty (fb_clip_region), FALSE);
+  g_return_if_fail (!cairo_region_is_empty (fb_clip_region));
 
   swap_with_damage = FALSE;
   if (has_buffer_age)
@@ -730,14 +639,12 @@ clutter_stage_cogl_redraw_view (ClutterStageWindow *stage_window,
       cairo_region_destroy (queued_redraw_clip);
     }
 
-  res = swap_framebuffer (stage_window,
-                          view,
-                          swap_region,
-                          swap_with_damage);
+  swap_framebuffer (stage_window,
+                    view,
+                    swap_region,
+                    swap_with_damage);
 
   cairo_region_destroy (swap_region);
-
-  return res;
 }
 
 static void
@@ -745,62 +652,34 @@ clutter_stage_cogl_scanout_view (ClutterStageCogl *stage_cogl,
                                  ClutterStageView *view,
                                  CoglScanout      *scanout)
 {
+  ClutterStageCoglPrivate *priv =
+    _clutter_stage_cogl_get_instance_private (stage_cogl);
   CoglFramebuffer *framebuffer = clutter_stage_view_get_framebuffer (view);
   CoglOnscreen *onscreen;
+  CoglFrameInfo *frame_info;
 
   g_return_if_fail (cogl_is_onscreen (framebuffer));
 
   onscreen = COGL_ONSCREEN (framebuffer);
-  cogl_onscreen_direct_scanout (onscreen, scanout);
+
+  frame_info = cogl_frame_info_new (priv->global_frame_counter);
+  priv->global_frame_counter++;
+
+  cogl_onscreen_direct_scanout (onscreen, scanout, frame_info);
 }
 
 static void
-clutter_stage_cogl_redraw (ClutterStageWindow *stage_window)
+clutter_stage_cogl_redraw_view (ClutterStageWindow *stage_window,
+                                ClutterStageView   *view)
 {
   ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_window);
-  gboolean swap_event = FALSE;
-  GList *l;
+  g_autoptr (CoglScanout) scanout = NULL;
 
-  COGL_TRACE_BEGIN (ClutterStageCoglRedraw, "Paint (Cogl Redraw)");
-
-  for (l = _clutter_stage_window_get_views (stage_window); l; l = l->next)
-    {
-      ClutterStageView *view = l->data;
-      g_autoptr (CoglScanout) scanout = NULL;
-
-      if (!clutter_stage_view_has_redraw_clip (view))
-        continue;
-
-      scanout = clutter_stage_view_take_scanout (view);
-      if (scanout)
-        {
-          clutter_stage_cogl_scanout_view (stage_cogl,
-                                           view,
-                                           scanout);
-          swap_event = TRUE;
-        }
-      else
-        {
-          swap_event |= clutter_stage_cogl_redraw_view (stage_window, view);
-        }
-    }
-
-  _clutter_stage_emit_after_paint (stage_cogl->wrapper);
-
-  _clutter_stage_window_finish_frame (stage_window);
-
-  if (swap_event)
-    {
-      /* If we have swap buffer events then cogl_onscreen_swap_buffers
-       * will return immediately and we need to track that there is a
-       * swap in progress... */
-      if (clutter_feature_available (CLUTTER_FEATURE_SWAP_EVENTS))
-        stage_cogl->pending_swaps++;
-    }
-
-  stage_cogl->frame_count++;
-
-  COGL_TRACE_END (ClutterStageCoglRedraw);
+  scanout = clutter_stage_view_take_scanout (view);
+  if (scanout)
+    clutter_stage_cogl_scanout_view (stage_cogl, view, scanout);
+  else
+    clutter_stage_cogl_redraw_view_primary (stage_cogl, view);
 }
 
 static void
@@ -812,10 +691,8 @@ clutter_stage_window_iface_init (ClutterStageWindowInterface *iface)
   iface->resize = clutter_stage_cogl_resize;
   iface->show = clutter_stage_cogl_show;
   iface->hide = clutter_stage_cogl_hide;
-  iface->schedule_update = clutter_stage_cogl_schedule_update;
-  iface->get_update_time = clutter_stage_cogl_get_update_time;
-  iface->clear_update_time = clutter_stage_cogl_clear_update_time;
-  iface->redraw = clutter_stage_cogl_redraw;
+  iface->get_frame_counter = clutter_stage_cogl_get_frame_counter;
+  iface->redraw_view = clutter_stage_cogl_redraw_view;
 }
 
 static void
@@ -856,10 +733,43 @@ _clutter_stage_cogl_class_init (ClutterStageCoglClass *klass)
 static void
 _clutter_stage_cogl_init (ClutterStageCogl *stage)
 {
-  stage->last_presentation_time = 0;
-  stage->refresh_rate = 0.0;
+}
+
+static void
+frame_cb (CoglOnscreen  *onscreen,
+          CoglFrameEvent frame_event,
+          CoglFrameInfo *frame_info,
+          void          *user_data)
+{
+  ClutterStageView *view = user_data;
+  ClutterFrameInfo clutter_frame_info;
+
+  if (frame_event == COGL_FRAME_EVENT_SYNC)
+    return;
+
+  clutter_frame_info = (ClutterFrameInfo) {
+    .frame_counter = cogl_frame_info_get_global_frame_counter (frame_info),
+    .refresh_rate = cogl_frame_info_get_refresh_rate (frame_info),
+    .presentation_time = ns2us (cogl_frame_info_get_presentation_time (frame_info)),
+  };
 
-  stage->update_time = -1;
+  clutter_stage_view_notify_presented (view, &clutter_frame_info);
+}
+
+static void
+on_framebuffer_set (ClutterStageView *view)
+{
+  CoglFramebuffer *framebuffer;
+
+  framebuffer = clutter_stage_view_get_onscreen (view);
+
+  if (framebuffer && cogl_is_onscreen (framebuffer))
+    {
+      cogl_onscreen_add_frame_callback (COGL_ONSCREEN (framebuffer),
+                                        frame_cb,
+                                        view,
+                                        NULL);
+    }
 }
 
 static void
@@ -869,6 +779,7 @@ clutter_stage_view_cogl_finalize (GObject *object)
   ClutterStageViewCoglPrivate *view_priv =
     clutter_stage_view_cogl_get_instance_private (view_cogl);
 
+  g_clear_handle_id (&view_priv->notify_presented_handle_id, g_source_remove);
   clutter_damage_history_free (view_priv->damage_history);
 
   G_OBJECT_CLASS (clutter_stage_view_cogl_parent_class)->finalize (object);
@@ -881,6 +792,9 @@ clutter_stage_view_cogl_init (ClutterStageViewCogl *view_cogl)
     clutter_stage_view_cogl_get_instance_private (view_cogl);
 
   view_priv->damage_history = clutter_damage_history_new ();
+
+  g_signal_connect (view_cogl, "notify::framebuffer",
+                    G_CALLBACK (on_framebuffer_set), NULL);
 }
 
 static void
diff --git a/clutter/clutter/cogl/clutter-stage-cogl.h b/clutter/clutter/cogl/clutter-stage-cogl.h
index 1eaa02e8fe3923a3aa8a65b38a7271732dcb3f48..a67ba961522862b28c910f0bad0df9db3c5abee2 100644
--- a/clutter/clutter/cogl/clutter-stage-cogl.h
+++ b/clutter/clutter/cogl/clutter-stage-cogl.h
@@ -41,20 +41,6 @@ struct _ClutterStageCogl
 
   /* back pointer to the backend */
   ClutterBackend *backend;
-
-  float refresh_rate;
-  int pending_swaps;
-
-  gint64 last_presentation_time;
-  gint64 update_time;
-  int64_t last_update_time;
-
-  /* We only enable clipped redraws after 2 frames, since we've seen
-   * a lot of drivers can struggle to get going and may output some
-   * junk frames to start with. */
-  unsigned int frame_count;
-
-  gint last_sync_delay;
 };
 
 struct _ClutterStageCoglClass
diff --git a/clutter/clutter/deprecated/clutter-timeline.h b/clutter/clutter/deprecated/clutter-timeline.h
new file mode 100644
index 0000000000000000000000000000000000000000..169bd7c76fe6392eea3740c34511b0b07aceff01
--- /dev/null
+++ b/clutter/clutter/deprecated/clutter-timeline.h
@@ -0,0 +1,34 @@
+/*
+ * Clutter.
+ *
+ * An OpenGL based 'interactive canvas' library.
+ *
+ * Copyright (C) 2012 Intel Corp
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __CLUTTER_TIMELINE_PRIVATE_H__
+#define __CLUTTER_TIMELINE_PRIVATE_H__
+
+#include <clutter/clutter-timeline.h>
+
+G_BEGIN_DECLS
+
+CLUTTER_DEPRECATED_FOR(clutter_timeline_new_for_actor)
+ClutterTimeline * clutter_timeline_new (guint duration_ms);
+
+G_END_DECLS
+
+#endif /* __CLUTTER_TIMELINE_PRIVATE_H__ */
diff --git a/clutter/clutter/meson.build b/clutter/clutter/meson.build
index 23636c11c82e2ddac2cb055ea9d35933c66978d5..fa556905e32feeb8a6167035de74bf4d209801a6 100644
--- a/clutter/clutter/meson.build
+++ b/clutter/clutter/meson.build
@@ -36,6 +36,7 @@ clutter_headers = [
   'clutter-feature.h',
   'clutter-fixed-layout.h',
   'clutter-flow-layout.h',
+  'clutter-frame-clock.h',
   'clutter-gesture-action.h',
   'clutter-grid-layout.h',
   'clutter-image.h',
@@ -122,6 +123,7 @@ clutter_sources = [
   'clutter-fixed-layout.c',
   'clutter-flatten-effect.c',
   'clutter-flow-layout.c',
+  'clutter-frame-clock.c',
   'clutter-gesture-action.c',
   'clutter-graphene.c',
   'clutter-grid-layout.c',
@@ -139,8 +141,6 @@ clutter_sources = [
   'clutter-layout-manager.c',
   'clutter-layout-meta.c',
   'clutter-main.c',
-  'clutter-master-clock.c',
-  'clutter-master-clock-default.c',
   'clutter-offscreen-effect.c',
   'clutter-page-turn-effect.c',
   'clutter-paint-context.c',
@@ -198,8 +198,6 @@ clutter_private_headers = [
   'clutter-input-focus-private.h',
   'clutter-input-method-private.h',
   'clutter-input-pointer-a11y-private.h',
-  'clutter-master-clock.h',
-  'clutter-master-clock-default.h',
   'clutter-offscreen-effect-private.h',
   'clutter-paint-context-private.h',
   'clutter-paint-node-private.h',
@@ -211,6 +209,7 @@ clutter_private_headers = [
   'clutter-stage-private.h',
   'clutter-stage-view-private.h',
   'clutter-stage-window.h',
+  'clutter-timeline-private.h',
 ]
 
 clutter_nonintrospected_sources = [
@@ -220,6 +219,7 @@ clutter_nonintrospected_sources = [
 
 clutter_deprecated_headers = [
   'deprecated/clutter-container.h',
+  'deprecated/clutter-timeline.h',
 ]
 
 clutter_backend_sources = []
diff --git a/clutter/meson.build b/clutter/meson.build
index 298d6f177b3bc0a9d0c3de0be47a20dd90c1b7a5..defa73f1c60ffca0e88ce3e4c2124e0ad76af0d9 100644
--- a/clutter/meson.build
+++ b/clutter/meson.build
@@ -8,6 +8,7 @@ clutter_c_args = [
   '-DCLUTTER_SYSCONFDIR="@0@"'.format(join_paths(prefix, sysconfdir)),
   '-DCLUTTER_COMPILATION=1',
   '-DCOGL_DISABLE_DEPRECATION_WARNINGS',
+  '-DCOGL_ENABLE_MUTTER_API',
   '-DG_LOG_DOMAIN="Clutter"',
 ]
 
diff --git a/cogl/cogl/cogl-frame-info-private.h b/cogl/cogl/cogl-frame-info-private.h
index f0324f2517c6c8632528393f0afde4b1d59319b9..13d856175090bd9114d54a8a75eafa084c962607 100644
--- a/cogl/cogl/cogl-frame-info-private.h
+++ b/cogl/cogl/cogl-frame-info-private.h
@@ -45,6 +45,7 @@ struct _CoglFrameInfo
   int64_t global_frame_counter;
 };
 
-CoglFrameInfo *_cogl_frame_info_new (void);
+COGL_EXPORT
+CoglFrameInfo *cogl_frame_info_new (int64_t global_frame_counter);
 
 #endif /* __COGL_FRAME_INFO_PRIVATE_H */
diff --git a/cogl/cogl/cogl-frame-info.c b/cogl/cogl/cogl-frame-info.c
index 1071495a04a960a70f5d50eefac89ca0537aba84..b5da21110f331745dab2cef0c40be8733dbca555 100644
--- a/cogl/cogl/cogl-frame-info.c
+++ b/cogl/cogl/cogl-frame-info.c
@@ -39,11 +39,12 @@ COGL_OBJECT_DEFINE (FrameInfo, frame_info);
 COGL_GTYPE_DEFINE_CLASS (FrameInfo, frame_info);
 
 CoglFrameInfo *
-_cogl_frame_info_new (void)
+cogl_frame_info_new (int64_t global_frame_counter)
 {
   CoglFrameInfo *info;
 
   info = g_slice_new0 (CoglFrameInfo);
+  info->global_frame_counter = global_frame_counter;
 
   return _cogl_frame_info_object_new (info);
 }
diff --git a/cogl/cogl/cogl-frame-info.h b/cogl/cogl/cogl-frame-info.h
index 8acbb34bd194d6098be8912b00bd4972cdde6cb2..2204bafdb0e6da42bef55deef37845692a84aee4 100644
--- a/cogl/cogl/cogl-frame-info.h
+++ b/cogl/cogl/cogl-frame-info.h
@@ -45,6 +45,11 @@
 
 G_BEGIN_DECLS
 
+/**
+ * CoglFrameInfo:
+ *
+ * Frame information.
+ */
 typedef struct _CoglFrameInfo CoglFrameInfo;
 #define COGL_FRAME_INFO(X) ((CoglFrameInfo *)(X))
 
diff --git a/cogl/cogl/cogl-onscreen.c b/cogl/cogl/cogl-onscreen.c
index 892a0af3b46cd38fc61cd3df3a3f5211595da3c9..a3c1514a5e44cbfcc2ff4b118b8850941a301c02 100644
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -293,15 +293,14 @@ _cogl_onscreen_queue_event (CoglOnscreen *onscreen,
 void
 cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                         const int *rectangles,
-                                        int n_rectangles)
+                                        int n_rectangles,
+                                        CoglFrameInfo *info)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
-  CoglFrameInfo *info;
 
   g_return_if_fail  (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN);
 
-  info = _cogl_frame_info_new ();
   info->frame_counter = onscreen->frame_counter;
   g_queue_push_tail (&onscreen->pending_frame_infos, info);
 
@@ -310,7 +309,8 @@ cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
 
   winsys = _cogl_framebuffer_get_winsys (framebuffer);
   winsys->onscreen_swap_buffers_with_damage (onscreen,
-                                             rectangles, n_rectangles);
+                                             rectangles, n_rectangles,
+                                             info);
   cogl_framebuffer_discard_buffers (framebuffer,
                                     COGL_BUFFER_BIT_COLOR |
                                     COGL_BUFFER_BIT_DEPTH |
@@ -334,23 +334,23 @@ cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
 }
 
 void
-cogl_onscreen_swap_buffers (CoglOnscreen *onscreen)
+cogl_onscreen_swap_buffers (CoglOnscreen  *onscreen,
+                            CoglFrameInfo *info)
 {
-  cogl_onscreen_swap_buffers_with_damage (onscreen, NULL, 0);
+  cogl_onscreen_swap_buffers_with_damage (onscreen, NULL, 0, info);
 }
 
 void
 cogl_onscreen_swap_region (CoglOnscreen *onscreen,
                            const int *rectangles,
-                           int n_rectangles)
+                           int n_rectangles,
+                           CoglFrameInfo *info)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
-  CoglFrameInfo *info;
 
   g_return_if_fail  (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN);
 
-  info = _cogl_frame_info_new ();
   info->frame_counter = onscreen->frame_counter;
   g_queue_push_tail (&onscreen->pending_frame_infos, info);
 
@@ -365,7 +365,8 @@ cogl_onscreen_swap_region (CoglOnscreen *onscreen,
 
   winsys->onscreen_swap_region (COGL_ONSCREEN (framebuffer),
                                 rectangles,
-                                n_rectangles);
+                                n_rectangles,
+                                info);
 
   cogl_framebuffer_discard_buffers (framebuffer,
                                     COGL_BUFFER_BIT_COLOR |
@@ -406,22 +407,21 @@ cogl_onscreen_get_buffer_age (CoglOnscreen *onscreen)
 }
 
 void
-cogl_onscreen_direct_scanout (CoglOnscreen *onscreen,
-                              CoglScanout  *scanout)
+cogl_onscreen_direct_scanout (CoglOnscreen  *onscreen,
+                              CoglScanout   *scanout,
+                              CoglFrameInfo *info)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
-  CoglFrameInfo *info;
 
   g_return_if_fail (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN);
   g_return_if_fail (_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT));
 
-  info = _cogl_frame_info_new ();
   info->frame_counter = onscreen->frame_counter;
   g_queue_push_tail (&onscreen->pending_frame_infos, info);
 
   winsys = _cogl_framebuffer_get_winsys (framebuffer);
-  winsys->onscreen_direct_scanout (onscreen, scanout);
+  winsys->onscreen_direct_scanout (onscreen, scanout, info);
 
   onscreen->frame_counter++;
 }
diff --git a/cogl/cogl/cogl-onscreen.h b/cogl/cogl/cogl-onscreen.h
index 8454703501730c9667d54c2af0e9603a610b4777..e70d3f806421002fa5c41f18422f4a238e04957d 100644
--- a/cogl/cogl/cogl-onscreen.h
+++ b/cogl/cogl/cogl-onscreen.h
@@ -178,7 +178,8 @@ cogl_onscreen_hide (CoglOnscreen *onscreen);
  * Stability: unstable
  */
 COGL_EXPORT void
-cogl_onscreen_swap_buffers (CoglOnscreen *onscreen);
+cogl_onscreen_swap_buffers (CoglOnscreen  *onscreen,
+                            CoglFrameInfo *frame_info);
 
 
 /**
@@ -284,14 +285,16 @@ cogl_onscreen_get_buffer_age (CoglOnscreen *onscreen);
 COGL_EXPORT void
 cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                         const int *rectangles,
-                                        int n_rectangles);
+                                        int n_rectangles,
+                                        CoglFrameInfo *info);
 
 /**
  * cogl_onscreen_direct_scanout: (skip)
  */
 COGL_EXPORT void
-cogl_onscreen_direct_scanout (CoglOnscreen *onscreen,
-                              CoglScanout  *scanout);
+cogl_onscreen_direct_scanout (CoglOnscreen  *onscreen,
+                              CoglScanout   *scanout,
+                              CoglFrameInfo *info);
 
 /**
  * cogl_onscreen_swap_region:
@@ -316,7 +319,8 @@ cogl_onscreen_direct_scanout (CoglOnscreen *onscreen,
 COGL_EXPORT void
 cogl_onscreen_swap_region (CoglOnscreen *onscreen,
                            const int *rectangles,
-                           int n_rectangles);
+                           int n_rectangles,
+                           CoglFrameInfo *info);
 
 /**
  * CoglFrameEvent:
diff --git a/cogl/cogl/meson.build b/cogl/cogl/meson.build
index edcac793e3629fc2edcdcade02210ccb50a3d9cf..2947b46c9e216fb875ac3456d84872faf0559160 100644
--- a/cogl/cogl/meson.build
+++ b/cogl/cogl/meson.build
@@ -77,6 +77,7 @@ cogl_headers = [
   'cogl-bitmap.h',
   'cogl-color.h',
   'cogl-context.h',
+  'cogl-frame-info.h',
   'cogl-framebuffer.h',
   'cogl-matrix.h',
   'cogl-object.h',
@@ -106,7 +107,6 @@ cogl_nonintrospected_headers = [
   'cogl-indices.h',
   'cogl-attribute.h',
   'cogl-primitive.h',
-  'cogl-frame-info.h',
   'cogl-output.h',
   'cogl-matrix-stack.h',
   'cogl-poll.h',
diff --git a/cogl/cogl/winsys/cogl-winsys-egl.c b/cogl/cogl/winsys/cogl-winsys-egl.c
index 5dd106d1b0aaba090fecb215cba0e316a33ac9c4..8c999c52bb325cf9fb02e4862d18ef85dd606d3e 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl.c
+++ b/cogl/cogl/winsys/cogl-winsys-egl.c
@@ -726,7 +726,8 @@ _cogl_winsys_onscreen_get_buffer_age (CoglOnscreen *onscreen)
 static void
 _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
                                    const int *user_rectangles,
-                                   int n_rectangles)
+                                   int n_rectangles,
+                                   CoglFrameInfo *info)
 {
   CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
   CoglRenderer *renderer = context->display->renderer;
@@ -765,7 +766,8 @@ _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
 static void
 _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                                 const int *rectangles,
-                                                int n_rectangles)
+                                                int n_rectangles,
+                                                CoglFrameInfo *info)
 {
   CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
   CoglRenderer *renderer = context->display->renderer;
diff --git a/cogl/cogl/winsys/cogl-winsys-glx.c b/cogl/cogl/winsys/cogl-winsys-glx.c
index 86d5acd05f6eabd4af4b89959f4fc4bbb8f86156..0b1c1eac2259bed4d12c28bbe5bf11c8186a2be4 100644
--- a/cogl/cogl/winsys/cogl-winsys-glx.c
+++ b/cogl/cogl/winsys/cogl-winsys-glx.c
@@ -1673,7 +1673,8 @@ set_frame_info_output (CoglOnscreen *onscreen,
 static void
 _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
                                    const int *user_rectangles,
-                                   int n_rectangles)
+                                   int n_rectangles,
+                                   CoglFrameInfo *info)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   CoglContext *context = framebuffer->context;
@@ -1879,7 +1880,8 @@ _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
 static void
 _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                                 const int *rectangles,
-                                                int n_rectangles)
+                                                int n_rectangles,
+                                                CoglFrameInfo *info)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   CoglContext *context = framebuffer->context;
diff --git a/cogl/cogl/winsys/cogl-winsys-private.h b/cogl/cogl/winsys/cogl-winsys-private.h
index 01a45b7655231a2ec9daf530dff24c2e0061aa8e..b9dbff524010f5f84fc6f5d3b53172f5112139d1 100644
--- a/cogl/cogl/winsys/cogl-winsys-private.h
+++ b/cogl/cogl/winsys/cogl-winsys-private.h
@@ -116,11 +116,13 @@ typedef struct _CoglWinsysVtable
   void
   (*onscreen_swap_buffers_with_damage) (CoglOnscreen *onscreen,
                                         const int *rectangles,
-                                        int n_rectangles);
+                                        int n_rectangles,
+                                        CoglFrameInfo *info);
 
   void
-  (*onscreen_direct_scanout) (CoglOnscreen *onscreen,
-                              CoglScanout  *scanout);
+  (*onscreen_direct_scanout) (CoglOnscreen  *onscreen,
+                              CoglScanout   *scanout,
+                              CoglFrameInfo *info);
 
   void
   (*onscreen_set_visibility) (CoglOnscreen *onscreen,
@@ -134,7 +136,8 @@ typedef struct _CoglWinsysVtable
   void
   (*onscreen_swap_region) (CoglOnscreen *onscreen,
                            const int *rectangles,
-                           int n_rectangles);
+                           int n_rectangles,
+                           CoglFrameInfo *info);
 
   void
   (*onscreen_set_resizable) (CoglOnscreen *onscreen, gboolean resizable);
diff --git a/src/backends/meta-backend.c b/src/backends/meta-backend.c
index 39f2754896e3a8da4569698f4566081b2bb7ddc2..7694d90a780bf8af4f71eff8a936424fd9c5a61e 100644
--- a/src/backends/meta-backend.c
+++ b/src/backends/meta-backend.c
@@ -170,8 +170,6 @@ struct _MetaBackendPrivate
   guint sleep_signal_id;
   GCancellable *cancellable;
   GDBusConnection *system_bus;
-
-  gboolean was_headless;
 };
 typedef struct _MetaBackendPrivate MetaBackendPrivate;
 
@@ -292,19 +290,6 @@ meta_backend_monitors_changed (MetaBackend *backend)
     }
 
   meta_cursor_renderer_force_update (priv->cursor_renderer);
-
-  if (meta_monitor_manager_is_headless (priv->monitor_manager) &&
-      !priv->was_headless)
-    {
-      clutter_stage_freeze_updates (CLUTTER_STAGE (priv->stage));
-      priv->was_headless = TRUE;
-    }
-  else if (!meta_monitor_manager_is_headless (priv->monitor_manager) &&
-           priv->was_headless)
-    {
-      clutter_stage_thaw_updates (CLUTTER_STAGE (priv->stage));
-      priv->was_headless = FALSE;
-    }
 }
 
 void
diff --git a/src/backends/meta-cursor-renderer.c b/src/backends/meta-cursor-renderer.c
index 485e96a8df6bd2ecacfe86c645ff143722cb7a67..5580136fc88c56c5c8955f868569cdab6d906501 100644
--- a/src/backends/meta-cursor-renderer.c
+++ b/src/backends/meta-cursor-renderer.c
@@ -32,6 +32,7 @@
 #include "clutter/clutter.h"
 #include "clutter/clutter-mutter.h"
 #include "cogl/cogl.h"
+#include "core/boxes-private.h"
 #include "meta/meta-backend.h"
 #include "meta/util.h"
 
@@ -59,7 +60,7 @@ struct _MetaCursorRendererPrivate
   MetaCursorSprite *displayed_cursor;
   MetaOverlay *stage_overlay;
   gboolean handled_by_backend;
-  guint post_paint_func_id;
+  gulong after_paint_handler_id;
 
   GList *hw_cursor_inhibitors;
 };
@@ -153,17 +154,27 @@ queue_redraw (MetaCursorRenderer *renderer,
                                     texture, &rect);
 }
 
-static gboolean
-meta_cursor_renderer_post_paint (gpointer data)
+static void
+meta_cursor_renderer_after_paint (ClutterStage       *stage,
+                                  ClutterStageView   *stage_view,
+                                  MetaCursorRenderer *renderer)
 {
-  MetaCursorRenderer *renderer = META_CURSOR_RENDERER (data);
   MetaCursorRendererPrivate *priv =
     meta_cursor_renderer_get_instance_private (renderer);
 
   if (priv->displayed_cursor && !priv->handled_by_backend)
-    meta_cursor_renderer_emit_painted (renderer, priv->displayed_cursor);
-
-  return TRUE;
+    {
+      graphene_rect_t rect;
+      MetaRectangle view_layout;
+      graphene_rect_t view_rect;
+
+      rect = meta_cursor_renderer_calculate_rect (renderer,
+                                                  priv->displayed_cursor);
+      clutter_stage_view_get_layout (stage_view, &view_layout);
+      view_rect = meta_rectangle_to_graphene_rect (&view_layout);
+      if (graphene_rect_intersection (&rect, &view_rect, NULL))
+        meta_cursor_renderer_emit_painted (renderer, priv->displayed_cursor);
+    }
 }
 
 static gboolean
@@ -228,11 +239,28 @@ meta_cursor_renderer_finalize (GObject *object)
   if (priv->stage_overlay)
     meta_stage_remove_cursor_overlay (META_STAGE (stage), priv->stage_overlay);
 
-  clutter_threads_remove_repaint_func (priv->post_paint_func_id);
+  g_clear_signal_handler (&priv->after_paint_handler_id, stage);
 
   G_OBJECT_CLASS (meta_cursor_renderer_parent_class)->finalize (object);
 }
 
+static void
+meta_cursor_renderer_constructed (GObject *object)
+{
+  MetaCursorRenderer *renderer = META_CURSOR_RENDERER (object);
+  MetaCursorRendererPrivate *priv =
+    meta_cursor_renderer_get_instance_private (renderer);
+  ClutterActor *stage;
+
+  stage = meta_backend_get_stage (priv->backend);
+  priv->after_paint_handler_id =
+    g_signal_connect (stage, "after-paint",
+                      G_CALLBACK (meta_cursor_renderer_after_paint),
+                      renderer);
+
+  G_OBJECT_CLASS (meta_cursor_renderer_parent_class)->constructed (object);
+}
+
 static void
 meta_cursor_renderer_class_init (MetaCursorRendererClass *klass)
 {
@@ -241,6 +269,7 @@ meta_cursor_renderer_class_init (MetaCursorRendererClass *klass)
   object_class->get_property = meta_cursor_renderer_get_property;
   object_class->set_property = meta_cursor_renderer_set_property;
   object_class->finalize = meta_cursor_renderer_finalize;
+  object_class->constructed = meta_cursor_renderer_constructed;
   klass->update_cursor = meta_cursor_renderer_real_update_cursor;
 
   obj_props[PROP_BACKEND] =
@@ -265,14 +294,6 @@ meta_cursor_renderer_class_init (MetaCursorRendererClass *klass)
 static void
 meta_cursor_renderer_init (MetaCursorRenderer *renderer)
 {
-  MetaCursorRendererPrivate *priv =
-    meta_cursor_renderer_get_instance_private (renderer);
-
-  priv->post_paint_func_id =
-    clutter_threads_add_repaint_func_full (CLUTTER_REPAINT_FLAGS_POST_PAINT,
-                                           meta_cursor_renderer_post_paint,
-                                           renderer,
-                                           NULL);
 }
 
 graphene_rect_t
diff --git a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
index 785b29cd7bd41bd939e96404d6252b42311d9e9b..d698baba64e7c3871e84b412cc4c663d00cf023d 100644
--- a/src/backends/meta-renderer-view.c
+++ b/src/backends/meta-renderer-view.c
@@ -32,6 +32,7 @@
 
 #include "backends/meta-renderer-view.h"
 
+#include "backends/meta-crtc.h"
 #include "backends/meta-renderer.h"
 #include "clutter/clutter-mutter.h"
 #include "compositor/region-utils.h"
@@ -41,6 +42,7 @@ enum
   PROP_0,
 
   PROP_TRANSFORM,
+  PROP_CRTC,
 
   PROP_LAST
 };
@@ -52,6 +54,8 @@ struct _MetaRendererView
   ClutterStageViewCogl parent;
 
   MetaMonitorTransform transform;
+
+  MetaCrtc *crtc;
 };
 
 G_DEFINE_TYPE (MetaRendererView, meta_renderer_view,
@@ -63,6 +67,12 @@ meta_renderer_view_get_transform (MetaRendererView *view)
   return view->transform;
 }
 
+MetaCrtc *
+meta_renderer_view_get_crtc (MetaRendererView *view)
+{
+  return view->crtc;
+}
+
 static void
 meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView *view,
                                                         CoglMatrix       *matrix)
@@ -161,6 +171,9 @@ meta_renderer_view_get_property (GObject    *object,
     case PROP_TRANSFORM:
       g_value_set_uint (value, view->transform);
       break;
+    case PROP_CRTC:
+      g_value_set_object (value, view->crtc);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -180,6 +193,9 @@ meta_renderer_view_set_property (GObject      *object,
     case PROP_TRANSFORM:
       meta_renderer_view_set_transform (view, g_value_get_uint (value));
       break;
+    case PROP_CRTC:
+      view->crtc = g_value_get_object (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -218,5 +234,14 @@ meta_renderer_view_class_init (MetaRendererViewClass *klass)
                        G_PARAM_CONSTRUCT_ONLY |
                        G_PARAM_STATIC_STRINGS);
 
+  obj_props[PROP_CRTC] =
+    g_param_spec_object ("crtc",
+                         "MetaCrtc",
+                         "MetaCrtc",
+                         META_TYPE_CRTC,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
diff --git a/src/backends/meta-renderer-view.h b/src/backends/meta-renderer-view.h
index f601de534fcd446e882362486de83d1792814b0b..0e19dc2f27b0ffa69e895adf0a69d58d69791ec0 100644
--- a/src/backends/meta-renderer-view.h
+++ b/src/backends/meta-renderer-view.h
@@ -28,4 +28,6 @@ G_DECLARE_FINAL_TYPE (MetaRendererView, meta_renderer_view,
 
 MetaMonitorTransform meta_renderer_view_get_transform (MetaRendererView *view);
 
+MetaCrtc *meta_renderer_view_get_crtc (MetaRendererView *view);
+
 #endif /* META_RENDERER_VIEW_H */
diff --git a/src/backends/meta-renderer.c b/src/backends/meta-renderer.c
index e0107ec9d63dbf70c28d0e5c8d6af0ff475f3fc9..c0bbb61336bf6174760b5a68776d482cb35e6b38 100644
--- a/src/backends/meta-renderer.c
+++ b/src/backends/meta-renderer.c
@@ -64,6 +64,7 @@ typedef struct _MetaRendererPrivate
 {
   MetaBackend *backend;
   GList *views;
+  gboolean is_paused;
 } MetaRendererPrivate;
 
 G_DEFINE_TYPE_WITH_PRIVATE (MetaRenderer, meta_renderer, G_TYPE_OBJECT)
@@ -127,11 +128,10 @@ create_crtc_view (MetaLogicalMonitor *logical_monitor,
                   gpointer            user_data)
 {
   MetaRenderer *renderer = user_data;
-  MetaRendererPrivate *priv = meta_renderer_get_instance_private (renderer);
   MetaRendererView *view;
 
   view = meta_renderer_create_view (renderer, logical_monitor, output, crtc);
-  priv->views = g_list_append (priv->views, view);
+  meta_renderer_add_view (renderer, view);
 }
 
 static void
@@ -172,6 +172,75 @@ meta_renderer_real_rebuild_views (MetaRenderer *renderer)
     }
 }
 
+static MetaRendererView *
+meta_renderer_get_view_for_crtc (MetaRenderer *renderer,
+                                 MetaCrtc     *crtc)
+{
+  MetaRendererPrivate *priv = meta_renderer_get_instance_private (renderer);
+  GList *l;
+
+  for (l = priv->views; l; l = l->next)
+    {
+      MetaRendererView *view = l->data;
+
+      if (meta_renderer_view_get_crtc (view) == crtc)
+        return view;
+    }
+
+  return NULL;
+}
+
+typedef struct _CollectViewsData
+{
+  MetaRenderer *renderer;
+  GList *out_views;
+} CollectViewsData;
+
+static gboolean
+collect_views (MetaMonitor          *monitor,
+               MetaMonitorMode      *mode,
+               MetaMonitorCrtcMode  *monitor_crtc_mode,
+               gpointer              user_data,
+               GError              **error)
+{
+  CollectViewsData *data = user_data;
+  MetaCrtc *crtc;
+  MetaRendererView *view;
+
+  crtc = meta_output_get_assigned_crtc (monitor_crtc_mode->output);
+  view = meta_renderer_get_view_for_crtc (data->renderer, crtc);
+  if (!g_list_find (data->out_views, view))
+    data->out_views = g_list_prepend (data->out_views, view);
+
+  return TRUE;
+}
+
+static GList *
+meta_renderer_real_get_views_for_monitor (MetaRenderer *renderer,
+                                          MetaMonitor  *monitor)
+{
+  CollectViewsData data = { 0 };
+  MetaMonitorMode *monitor_mode;
+
+  data.renderer = renderer;
+
+  monitor_mode = meta_monitor_get_current_mode (monitor);
+  meta_monitor_mode_foreach_crtc (monitor, monitor_mode,
+                                  collect_views,
+                                  &data,
+                                  NULL);
+
+  return data.out_views;
+}
+
+GList *
+meta_renderer_get_views_for_monitor (MetaRenderer *renderer,
+                                     MetaMonitor  *monitor)
+{
+  return META_RENDERER_GET_CLASS (renderer)->get_views_for_monitor (renderer,
+                                                                    monitor);
+}
+
 void
 meta_renderer_add_view (MetaRenderer     *renderer,
                         MetaRendererView *view)
@@ -179,6 +248,14 @@ meta_renderer_add_view (MetaRenderer     *renderer,
   MetaRendererPrivate *priv = meta_renderer_get_instance_private (renderer);
 
   priv->views = g_list_append (priv->views, view);
+
+  if (priv->is_paused)
+    {
+      ClutterFrameClock *frame_clock =
+        clutter_stage_view_get_frame_clock (CLUTTER_STAGE_VIEW (view));
+
+      clutter_frame_clock_inhibit (frame_clock);
+    }
 }
 
 /**
@@ -199,6 +276,44 @@ meta_renderer_get_views (MetaRenderer *renderer)
   return priv->views;
 }
 
+void
+meta_renderer_pause (MetaRenderer *renderer)
+{
+  MetaRendererPrivate *priv = meta_renderer_get_instance_private (renderer);
+  GList *l;
+
+  g_return_if_fail (!priv->is_paused);
+  priv->is_paused = TRUE;
+
+  for (l = priv->views; l; l = l->next)
+    {
+      ClutterStageView *stage_view = l->data;
+      ClutterFrameClock *frame_clock =
+        clutter_stage_view_get_frame_clock (stage_view);
+
+      clutter_frame_clock_inhibit (frame_clock);
+    }
+}
+
+void
+meta_renderer_resume (MetaRenderer *renderer)
+{
+  MetaRendererPrivate *priv = meta_renderer_get_instance_private (renderer);
+  GList *l;
+
+  g_return_if_fail (priv->is_paused);
+  priv->is_paused = FALSE;
+
+  for (l = priv->views; l; l = l->next)
+    {
+      ClutterStageView *stage_view = l->data;
+      ClutterFrameClock *frame_clock =
+        clutter_stage_view_get_frame_clock (stage_view);
+
+      clutter_frame_clock_uninhibit (frame_clock);
+    }
+}
+
 gboolean
 meta_renderer_is_hardware_accelerated (MetaRenderer *renderer)
 {
@@ -278,6 +393,7 @@ meta_renderer_class_init (MetaRendererClass *klass)
   object_class->finalize = meta_renderer_finalize;
 
   klass->rebuild_views = meta_renderer_real_rebuild_views;
+  klass->get_views_for_monitor = meta_renderer_real_get_views_for_monitor;
 
   obj_props[PROP_BACKEND] =
     g_param_spec_object ("backend",
diff --git a/src/backends/meta-renderer.h b/src/backends/meta-renderer.h
index 247d2c2aaec0945b8c863775ef651746c63f601c..134d23abf6e9b07520a703b25572f4f5b2ba9da3 100644
--- a/src/backends/meta-renderer.h
+++ b/src/backends/meta-renderer.h
@@ -46,6 +46,8 @@ struct _MetaRendererClass
                                       MetaOutput         *output,
                                       MetaCrtc           *crtc);
   void (* rebuild_views) (MetaRenderer *renderer);
+  GList * (* get_views_for_monitor) (MetaRenderer *renderer,
+                                     MetaMonitor  *monitor);
 };
 
 MetaBackend * meta_renderer_get_backend (MetaRenderer *renderer);
@@ -57,9 +59,16 @@ void meta_renderer_rebuild_views (MetaRenderer *renderer);
 void meta_renderer_add_view (MetaRenderer     *renderer,
                              MetaRendererView *view);
 
+GList * meta_renderer_get_views_for_monitor (MetaRenderer *renderer,
+                                             MetaMonitor  *monitor);
+
 META_EXPORT_TEST
 GList * meta_renderer_get_views (MetaRenderer *renderer);
 
 gboolean meta_renderer_is_hardware_accelerated (MetaRenderer *renderer);
 
+void meta_renderer_pause (MetaRenderer *renderer);
+
+void meta_renderer_resume (MetaRenderer *renderer);
+
 #endif /* META_RENDERER_H */
diff --git a/src/backends/meta-screen-cast-area-stream-src.c b/src/backends/meta-screen-cast-area-stream-src.c
index 1fe94d448bc4ff9c6ad281174e8116ae57ca0aa8..e73cafc371733adb8ef8f5d224ee703d4dc5c1d3 100644
--- a/src/backends/meta-screen-cast-area-stream-src.c
+++ b/src/backends/meta-screen-cast-area-stream-src.c
@@ -149,16 +149,32 @@ is_cursor_in_stream (MetaScreenCastAreaStreamSrc *area_src)
     }
 }
 
+static gboolean
+is_redraw_queued (MetaScreenCastAreaStreamSrc *area_src)
+{
+  ClutterStage *stage = get_stage (area_src);
+  GList *l;
+
+  for (l = clutter_stage_peek_stage_views (stage); l; l = l->next)
+    {
+      ClutterStageView *view = l->data;
+
+      if (clutter_stage_is_redraw_queued_on_view (stage, view))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
 static void
 sync_cursor_state (MetaScreenCastAreaStreamSrc *area_src)
 {
   MetaScreenCastStreamSrc *src = META_SCREEN_CAST_STREAM_SRC (area_src);
-  ClutterStage *stage = get_stage (area_src);
 
   if (!is_cursor_in_stream (area_src))
     return;
 
-  if (clutter_stage_is_redraw_queued (stage))
+  if (is_redraw_queued (area_src))
     return;
 
   meta_screen_cast_stream_src_maybe_record_frame (src);
diff --git a/src/backends/meta-screen-cast-monitor-stream-src.c b/src/backends/meta-screen-cast-monitor-stream-src.c
index 9d1d212d4ae7607048f1c8d12e0322b18d657401..759d5bda8346617a893cb5b6b91955798c0a0105 100644
--- a/src/backends/meta-screen-cast-monitor-stream-src.c
+++ b/src/backends/meta-screen-cast-monitor-stream-src.c
@@ -176,16 +176,37 @@ is_cursor_in_stream (MetaScreenCastMonitorStreamSrc *monitor_src)
     }
 }
 
+static gboolean
+is_redraw_queued (MetaScreenCastMonitorStreamSrc *monitor_src)
+{
+  MetaBackend *backend = get_backend (monitor_src);
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  ClutterStage *stage = get_stage (monitor_src);
+  MetaMonitor *monitor = get_monitor (monitor_src);
+  g_autoptr (GList) views = NULL;
+  GList *l;
+
+  views = meta_renderer_get_views_for_monitor (renderer, monitor);
+  for (l = views; l; l = l->next)
+    {
+      MetaRendererView *view = l->data;
+
+      if (clutter_stage_is_redraw_queued_on_view (stage, CLUTTER_STAGE_VIEW (view)))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
 static void
 sync_cursor_state (MetaScreenCastMonitorStreamSrc *monitor_src)
 {
   MetaScreenCastStreamSrc *src = META_SCREEN_CAST_STREAM_SRC (monitor_src);
-  ClutterStage *stage = get_stage (monitor_src);
 
   if (!is_cursor_in_stream (monitor_src))
     return;
 
-  if (clutter_stage_is_redraw_queued (stage))
+  if (is_redraw_queued (monitor_src))
     return;
 
   meta_screen_cast_stream_src_maybe_record_frame (src);
@@ -371,12 +392,12 @@ meta_screen_cast_monitor_stream_src_record_frame (MetaScreenCastStreamSrc *src,
   MetaMonitor *monitor;
   MetaLogicalMonitor *logical_monitor;
 
-  stage = get_stage (monitor_src);
-  if (!clutter_stage_is_redraw_queued (stage))
+  if (!is_redraw_queued (monitor_src))
     return FALSE;
 
   monitor = get_monitor (monitor_src);
   logical_monitor = meta_monitor_get_logical_monitor (monitor);
+  stage = get_stage (monitor_src);
   clutter_stage_capture_into (stage, FALSE, &logical_monitor->rect, data);
 
   return TRUE;
diff --git a/src/backends/native/meta-backend-native.c b/src/backends/native/meta-backend-native.c
index 12f2812b21ac29dedb6a4cb23f0adab69eeccaab..17f47b80de381aecf558a63d9ca7376a4c65d00d 100644
--- a/src/backends/native/meta-backend-native.c
+++ b/src/backends/native/meta-backend-native.c
@@ -781,7 +781,6 @@ void
 meta_backend_native_pause (MetaBackendNative *native)
 {
   MetaBackend *backend = META_BACKEND (native);
-  ClutterStage *stage = CLUTTER_STAGE (meta_backend_get_stage (backend));
   MetaMonitorManager *monitor_manager =
     meta_backend_get_monitor_manager (backend);
   MetaMonitorManagerKms *monitor_manager_kms =
@@ -789,12 +788,13 @@ meta_backend_native_pause (MetaBackendNative *native)
   ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
   MetaSeatNative *seat =
     META_SEAT_NATIVE (clutter_backend_get_default_seat (clutter_backend));
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
 
   COGL_TRACE_BEGIN_SCOPED (MetaBackendNativePause,
                            "Backend (pause)");
 
   meta_seat_native_release_devices (seat);
-  clutter_stage_freeze_updates (stage);
+  meta_renderer_pause (renderer);
 
   disconnect_udev_device_added_handler (native);
 
@@ -814,6 +814,7 @@ void meta_backend_native_resume (MetaBackendNative *native)
   ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
   MetaSeatNative *seat =
     META_SEAT_NATIVE (clutter_backend_get_default_seat (clutter_backend));
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
 
   COGL_TRACE_BEGIN_SCOPED (MetaBackendNativeResume,
                            "Backend (resume)");
@@ -823,7 +824,7 @@ void meta_backend_native_resume (MetaBackendNative *native)
   connect_udev_device_added_handler (native);
 
   meta_seat_native_reclaim_devices (seat);
-  clutter_stage_thaw_updates (stage);
+  meta_renderer_resume (renderer);
 
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
 
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 8ec809b9df7270e03dde8cad2d73cac5b8a18938..f3a6bd7e452c43b824f34b900645cfe36e2f7c0e 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -169,8 +169,6 @@ typedef struct _MetaOnscreenNativeSecondaryGpuState
     MetaDumbBuffer dumb_fbs[2];
   } cpu;
 
-  int pending_flips;
-
   gboolean noted_primary_gpu_copy_ok;
   gboolean noted_primary_gpu_copy_failed;
   MetaSharedFramebufferImportStatus import_status;
@@ -199,15 +197,9 @@ typedef struct _MetaOnscreenNative
   } egl;
 #endif
 
-  gboolean pending_swap_notify;
-
   gboolean pending_set_crtc;
 
-  int64_t pending_queue_swap_notify_frame_count;
-  int64_t pending_swap_notify_frame_count;
-
   MetaRendererView *view;
-  int total_pending_flips;
 } MetaOnscreenNative;
 
 struct _MetaRendererNative
@@ -224,7 +216,6 @@ struct _MetaRendererNative
 
   CoglClosure *swap_notify_idle;
 
-  int64_t frame_counter;
   gboolean pending_unset_disabled_crtcs;
 
   GList *power_save_page_flip_onscreens;
@@ -721,60 +712,6 @@ meta_renderer_native_disconnect (CoglRenderer *cogl_renderer)
   g_slice_free (CoglRendererEGL, cogl_renderer_egl);
 }
 
-static void
-flush_pending_swap_notify (CoglFramebuffer *framebuffer)
-{
-  if (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN)
-    {
-      CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
-      CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
-      MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
-
-      if (onscreen_native->pending_swap_notify)
-        {
-          CoglFrameInfo *info;
-
-          while ((info = g_queue_peek_head (&onscreen->pending_frame_infos)) &&
-                 info->global_frame_counter <= onscreen_native->pending_swap_notify_frame_count)
-            {
-              _cogl_onscreen_notify_frame_sync (onscreen, info);
-              _cogl_onscreen_notify_complete (onscreen, info);
-              cogl_object_unref (info);
-              g_queue_pop_head (&onscreen->pending_frame_infos);
-            }
-
-          onscreen_native->pending_swap_notify = FALSE;
-          cogl_object_unref (onscreen);
-        }
-    }
-}
-
-static void
-flush_pending_swap_notify_idle (void *user_data)
-{
-  CoglContext *cogl_context = user_data;
-  CoglRendererEGL *cogl_renderer_egl = cogl_context->display->renderer->winsys;
-  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
-  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
-  GList *l;
-
-  /* This needs to be disconnected before invoking the callbacks in
-   * case the callbacks cause it to be queued again */
-  _cogl_closure_disconnect (renderer_native->swap_notify_idle);
-  renderer_native->swap_notify_idle = NULL;
-
-  l = cogl_context->framebuffers;
-  while (l)
-    {
-      GList *next = l->next;
-      CoglFramebuffer *framebuffer = l->data;
-
-      flush_pending_swap_notify (framebuffer);
-
-      l = next;
-    }
-}
-
 static void
 free_current_secondary_bo (CoglOnscreen *onscreen)
 {
@@ -802,40 +739,14 @@ free_current_bo (CoglOnscreen *onscreen)
 static void
 meta_onscreen_native_queue_swap_notify (CoglOnscreen *onscreen)
 {
-  CoglOnscreenEGL *onscreen_egl =  onscreen->winsys;
-  MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
-  MetaRendererNative *renderer_native = onscreen_native->renderer_native;
-
-  onscreen_native->pending_swap_notify_frame_count =
-    onscreen_native->pending_queue_swap_notify_frame_count;
-
-  if (onscreen_native->pending_swap_notify)
-    return;
-
-  /* We only want to notify that the swap is complete when the
-   * application calls cogl_context_dispatch so instead of
-   * immediately notifying we queue an idle callback */
-  if (!renderer_native->swap_notify_idle)
-    {
-      CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-      CoglContext *cogl_context = framebuffer->context;
-      CoglRenderer *cogl_renderer = cogl_context->display->renderer;
+  CoglFrameInfo *info;
 
-      renderer_native->swap_notify_idle =
-        _cogl_poll_renderer_add_idle (cogl_renderer,
-                                      flush_pending_swap_notify_idle,
-                                      cogl_context,
-                                      NULL);
-    }
+  g_assert (onscreen->pending_frame_infos.length == 1);
 
-  /*
-   * The framebuffer will have its own referenc while the swap notify is
-   * pending. Otherwise when destroying the view would drop the pending
-   * notification with if the destruction happens before the idle callback
-   * is invoked.
-   */
-  cogl_object_ref (onscreen);
-  onscreen_native->pending_swap_notify = TRUE;
+  info = g_queue_pop_head (&onscreen->pending_frame_infos);
+  _cogl_onscreen_notify_frame_sync (onscreen, info);
+  _cogl_onscreen_notify_complete (onscreen, info);
+  cogl_object_unref (info);
 }
 
 static gboolean
@@ -1148,10 +1059,9 @@ notify_view_crtc_presented (MetaRendererView *view,
   CoglOnscreenEGL *onscreen_egl =  onscreen->winsys;
   MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
-  MetaGpuKms *render_gpu = onscreen_native->render_gpu;
   CoglFrameInfo *frame_info;
   MetaCrtc *crtc;
-  MetaGpuKms *gpu_kms;
+  MetaRendererNativeGpuData *renderer_gpu_data;
 
   /* Only keep the frame info for the fastest CRTC in use, which may not be
    * the first one to complete a flip. By only telling the compositor about the
@@ -1163,35 +1073,21 @@ notify_view_crtc_presented (MetaRendererView *view,
   crtc = META_CRTC (meta_crtc_kms_from_kms_crtc (kms_crtc));
   maybe_update_frame_info (crtc, frame_info, time_ns);
 
-  gpu_kms = META_GPU_KMS (meta_crtc_get_gpu (crtc));
-  if (gpu_kms != render_gpu)
-    {
-      MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state =
-        onscreen_native->secondary_gpu_state;
 
-      secondary_gpu_state->pending_flips--;
-    }
+  meta_onscreen_native_queue_swap_notify (onscreen);
 
-  onscreen_native->total_pending_flips--;
-  if (onscreen_native->total_pending_flips == 0)
+  renderer_gpu_data =
+    meta_renderer_native_get_gpu_data (renderer_native,
+                                       onscreen_native->render_gpu);
+  switch (renderer_gpu_data->mode)
     {
-      MetaRendererNativeGpuData *renderer_gpu_data;
-
-      meta_onscreen_native_queue_swap_notify (onscreen);
-
-      renderer_gpu_data =
-        meta_renderer_native_get_gpu_data (renderer_native,
-                                           onscreen_native->render_gpu);
-      switch (renderer_gpu_data->mode)
-        {
-        case META_RENDERER_NATIVE_MODE_GBM:
-          meta_onscreen_native_swap_drm_fb (onscreen);
-          break;
+    case META_RENDERER_NATIVE_MODE_GBM:
+      meta_onscreen_native_swap_drm_fb (onscreen);
+      break;
 #ifdef HAVE_EGL_DEVICE
-        case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
-          break;
+    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+      break;
 #endif
-        }
     }
 }
 
@@ -1405,10 +1301,6 @@ meta_onscreen_native_flip_crtc (CoglOnscreen     *onscreen,
                                g_object_ref (view),
                                kms_update);
 
-      onscreen_native->total_pending_flips++;
-      if (secondary_gpu_state)
-        secondary_gpu_state->pending_flips++;
-
       break;
 #ifdef HAVE_EGL_DEVICE
     case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
@@ -1418,7 +1310,6 @@ meta_onscreen_native_flip_crtc (CoglOnscreen     *onscreen,
                                         g_object_ref (view),
                                         custom_egl_stream_page_flip,
                                         onscreen_native);
-      onscreen_native->total_pending_flips++;
       break;
 #endif
     }
@@ -1486,40 +1377,6 @@ meta_onscreen_native_flip_crtcs (CoglOnscreen  *onscreen,
     }
 }
 
-static void
-wait_for_pending_flips (CoglOnscreen *onscreen)
-{
-  CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
-  MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
-  MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
-  GError *error = NULL;
-
-  secondary_gpu_state = onscreen_native->secondary_gpu_state;
-  if (secondary_gpu_state)
-    {
-      while (secondary_gpu_state->pending_flips)
-        {
-          if (!meta_gpu_kms_wait_for_flip (secondary_gpu_state->gpu_kms, &error))
-            {
-              g_warning ("Failed to wait for flip on secondary GPU: %s",
-                         error->message);
-              g_clear_error (&error);
-              break;
-            }
-        }
-    }
-
-  while (onscreen_native->total_pending_flips)
-    {
-      if (!meta_gpu_kms_wait_for_flip (onscreen_native->render_gpu, &error))
-        {
-          g_warning ("Failed to wait for flip: %s", error->message);
-          g_clear_error (&error);
-          break;
-        }
-    }
-}
-
 static gboolean
 import_shared_framebuffer (CoglOnscreen                        *onscreen,
                            MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state)
@@ -2067,9 +1924,10 @@ ensure_crtc_modes (CoglOnscreen  *onscreen,
 }
 
 static void
-meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
-                                               const int    *rectangles,
-                                               int           n_rectangles)
+meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
+                                               const int     *rectangles,
+                                               int            n_rectangles,
+                                               CoglFrameInfo *frame_info)
 {
   CoglContext *cogl_context = COGL_FRAMEBUFFER (onscreen)->context;
   CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
@@ -2084,7 +1942,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
   CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
   MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
-  CoglFrameInfo *frame_info;
   gboolean egl_context_changed = FALSE;
   MetaKmsUpdate *kms_update;
   g_autoptr (GError) error = NULL;
@@ -2096,23 +1953,12 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
 
   kms_update = meta_kms_ensure_pending_update (kms);
 
-  /*
-   * Wait for the flip callback before continuing, as we might have started the
-   * animation earlier due to the animation being driven by some other monitor.
-   */
-  COGL_TRACE_BEGIN (MetaRendererNativeSwapBuffersWait,
-                    "Onscreen (waiting for page flips)");
-  wait_for_pending_flips (onscreen);
-  COGL_TRACE_END (MetaRendererNativeSwapBuffersWait);
-
-  frame_info = g_queue_peek_tail (&onscreen->pending_frame_infos);
-  frame_info->global_frame_counter = renderer_native->frame_counter;
-
   update_secondary_gpu_state_pre_swap_buffers (onscreen);
 
   parent_vtable->onscreen_swap_buffers_with_damage (onscreen,
                                                     rectangles,
-                                                    n_rectangles);
+                                                    n_rectangles,
+                                                    frame_info);
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
@@ -2146,8 +1992,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
   update_secondary_gpu_state_post_swap_buffers (onscreen, &egl_context_changed);
 
   ensure_crtc_modes (onscreen, kms_update);
-
-  onscreen_native->pending_queue_swap_notify_frame_count = renderer_native->frame_counter;
   meta_onscreen_native_flip_crtcs (onscreen, kms_update);
 
   /*
@@ -2296,8 +2140,9 @@ meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
 }
 
 static void
-meta_onscreen_native_direct_scanout (CoglOnscreen *onscreen,
-                                     CoglScanout  *scanout)
+meta_onscreen_native_direct_scanout (CoglOnscreen  *onscreen,
+                                     CoglScanout   *scanout,
+                                     CoglFrameInfo *frame_info)
 {
   CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
   MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
@@ -2311,17 +2156,11 @@ meta_onscreen_native_direct_scanout (CoglOnscreen *onscreen,
   MetaBackend *backend = meta_renderer_get_backend (renderer);
   MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
   MetaKms *kms = meta_backend_native_get_kms (backend_native);
-  CoglFrameInfo *frame_info;
   MetaKmsUpdate *kms_update;
   g_autoptr (GError) error = NULL;
 
   kms_update = meta_kms_ensure_pending_update (kms);
 
-  wait_for_pending_flips (onscreen);
-
-  frame_info = g_queue_peek_tail (&onscreen->pending_frame_infos);
-  frame_info->global_frame_counter = renderer_native->frame_counter;
-
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
 
@@ -2331,9 +2170,6 @@ meta_onscreen_native_direct_scanout (CoglOnscreen *onscreen,
   g_set_object (&onscreen_native->gbm.next_fb, META_DRM_BUFFER (scanout));
 
   ensure_crtc_modes (onscreen, kms_update);
-
-  onscreen_native->pending_queue_swap_notify_frame_count =
-    renderer_native->frame_counter;
   meta_onscreen_native_flip_crtcs (onscreen, kms_update);
 
   meta_kms_post_pending_update_sync (kms);
@@ -3247,12 +3083,15 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
                                      &view_layout);
   view = g_object_new (META_TYPE_RENDERER_VIEW,
                        "name", meta_output_get_name (output),
+                       "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
+                       "crtc", crtc,
                        "scale", scale,
                        "framebuffer", onscreen,
                        "offscreen", offscreen,
                        "use-shadowfb", use_shadowfb,
                        "transform", view_transform,
+                       "refresh-rate", crtc_mode_info->refresh_rate,
                        NULL);
   g_clear_pointer (&offscreen, cogl_object_unref);
 
@@ -3305,8 +3144,6 @@ meta_renderer_native_finish_frame (MetaRendererNative *renderer_native)
   MetaKms *kms = meta_backend_native_get_kms (backend_native);
   MetaKmsUpdate *kms_update = NULL;
 
-  renderer_native->frame_counter++;
-
   if (renderer_native->pending_unset_disabled_crtcs)
     {
       GList *l;
@@ -3346,12 +3183,6 @@ meta_renderer_native_finish_frame (MetaRendererNative *renderer_native)
     }
 }
 
-int64_t
-meta_renderer_native_get_frame_counter (MetaRendererNative *renderer_native)
-{
-  return renderer_native->frame_counter;
-}
-
 static gboolean
 create_secondary_egl_config (MetaEgl               *egl,
                              MetaRendererNativeMode mode,
diff --git a/src/backends/native/meta-renderer-native.h b/src/backends/native/meta-renderer-native.h
index 3ea2c9cc0d81fa0fdf70bcbb6716f89270a23cfd..91afca766e5f755e14233e6bf411977e05638d00 100644
--- a/src/backends/native/meta-renderer-native.h
+++ b/src/backends/native/meta-renderer-native.h
@@ -55,8 +55,6 @@ MetaGpuKms * meta_renderer_native_get_primary_gpu (MetaRendererNative *renderer_
 
 void meta_renderer_native_finish_frame (MetaRendererNative *renderer_native);
 
-int64_t meta_renderer_native_get_frame_counter (MetaRendererNative *renderer_native);
-
 gboolean meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
                                                             uint32_t      drm_format,
                                                             uint64_t      drm_modifier,
diff --git a/src/backends/native/meta-seat-native.c b/src/backends/native/meta-seat-native.c
index fa984fd1b3059e267925db8dfcd589582043a0dd..d561e322aff3d686123bc75639d4539ace244f0a 100644
--- a/src/backends/native/meta-seat-native.c
+++ b/src/backends/native/meta-seat-native.c
@@ -885,13 +885,9 @@ meta_event_prepare (GSource *source,
 {
   gboolean retval;
 
-  _clutter_threads_acquire_lock ();
-
   *timeout = -1;
   retval = clutter_events_pending ();
 
-  _clutter_threads_release_lock ();
-
   return retval;
 }
 
@@ -901,13 +897,9 @@ meta_event_check (GSource *source)
   MetaEventSource *event_source = (MetaEventSource *) source;
   gboolean retval;
 
-  _clutter_threads_acquire_lock ();
-
   retval = ((event_source->event_poll_fd.revents & G_IO_IN) ||
             clutter_events_pending ());
 
-  _clutter_threads_release_lock ();
-
   return retval;
 }
 
@@ -1273,8 +1265,6 @@ meta_event_dispatch (GSource     *g_source,
   MetaSeatNative *seat;
   ClutterEvent *event;
 
-  _clutter_threads_acquire_lock ();
-
   seat = source->seat;
 
   /* Don't queue more events if we haven't finished handling the previous batch
@@ -1299,7 +1289,7 @@ meta_event_dispatch (GSource     *g_source,
 
       /* Drop events if we don't have any stage to forward them to */
       if (!_clutter_input_device_get_stage (input_device))
-        goto out;
+        return TRUE;
 
       /* update the device states *before* the event */
       event_state = seat->button_state |
@@ -1311,9 +1301,6 @@ meta_event_dispatch (GSource     *g_source,
       _clutter_stage_queue_event (event->any.stage, event, FALSE);
     }
 
-out:
-  _clutter_threads_release_lock ();
-
   return TRUE;
 }
 static GSourceFuncs event_funcs = {
diff --git a/src/backends/native/meta-seat-native.h b/src/backends/native/meta-seat-native.h
index 61e6ffd30bd02b4f3fd58f900489bea745c70258..31a316c51727da1654868c1a75805eac30887108 100644
--- a/src/backends/native/meta-seat-native.h
+++ b/src/backends/native/meta-seat-native.h
@@ -147,24 +147,6 @@ struct _MetaSeatNative
 G_DECLARE_FINAL_TYPE (MetaSeatNative, meta_seat_native,
                       META, SEAT_NATIVE, ClutterSeat)
 
-static inline uint64_t
-us (uint64_t us)
-{
-  return us;
-}
-
-static inline uint64_t
-ms2us (uint64_t ms)
-{
-  return us (ms * 1000);
-}
-
-static inline uint32_t
-us2ms (uint64_t us)
-{
-  return (uint32_t) (us / 1000);
-}
-
 void meta_seat_native_notify_key (MetaSeatNative     *seat,
                                   ClutterInputDevice *device,
                                   uint64_t            time_us,
diff --git a/src/backends/native/meta-stage-native.c b/src/backends/native/meta-stage-native.c
index 9a3d11cb9dca7627bf4f17b2dd92fbc3378108cc..ab519886d2f0450e7049634c379be9fc07e3e59f 100644
--- a/src/backends/native/meta-stage-native.c
+++ b/src/backends/native/meta-stage-native.c
@@ -52,86 +52,6 @@ G_DEFINE_TYPE_WITH_CODE (MetaStageNative, meta_stage_native,
                          G_IMPLEMENT_INTERFACE (CLUTTER_TYPE_STAGE_WINDOW,
                                                 clutter_stage_window_iface_init))
 
-static void
-frame_cb (CoglOnscreen  *onscreen,
-          CoglFrameEvent frame_event,
-          CoglFrameInfo *frame_info,
-          void          *user_data)
-
-{
-  MetaStageNative *stage_native = user_data;
-  ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_native);
-  int64_t global_frame_counter;
-  int64_t presented_frame_counter;
-  ClutterFrameInfo clutter_frame_info;
-
-  global_frame_counter = cogl_frame_info_get_global_frame_counter (frame_info);
-
-  switch (frame_event)
-    {
-    case COGL_FRAME_EVENT_SYNC:
-      presented_frame_counter = stage_native->presented_frame_counter_sync;
-      stage_native->presented_frame_counter_sync = global_frame_counter;
-      break;
-    case COGL_FRAME_EVENT_COMPLETE:
-      presented_frame_counter = stage_native->presented_frame_counter_complete;
-      stage_native->presented_frame_counter_complete = global_frame_counter;
-      break;
-    default:
-      g_assert_not_reached ();
-    }
-
-  if (global_frame_counter <= presented_frame_counter)
-    return;
-
-  clutter_frame_info = (ClutterFrameInfo) {
-    .frame_counter = global_frame_counter,
-    .refresh_rate = cogl_frame_info_get_refresh_rate (frame_info),
-    .presentation_time = cogl_frame_info_get_presentation_time (frame_info)
-  };
-
-  _clutter_stage_cogl_presented (stage_cogl, frame_event, &clutter_frame_info);
-}
-
-static void
-ensure_frame_callback (MetaStageNative  *stage_native,
-                       ClutterStageView *stage_view)
-{
-  CoglFramebuffer *framebuffer;
-  CoglOnscreen *onscreen;
-  CoglClosure *closure;
-
-  closure = g_object_get_qdata (G_OBJECT (stage_view),
-                                quark_view_frame_closure);
-  if (closure)
-    return;
-
-  framebuffer = clutter_stage_view_get_onscreen (stage_view);
-  onscreen = COGL_ONSCREEN (framebuffer);
-  closure = cogl_onscreen_add_frame_callback (onscreen,
-                                              frame_cb,
-                                              stage_native,
-                                              NULL);
-  g_object_set_qdata (G_OBJECT (stage_view),
-                      quark_view_frame_closure,
-                      closure);
-}
-
-static void
-ensure_frame_callbacks (MetaStageNative *stage_native)
-{
-  MetaBackend *backend = meta_get_backend ();
-  MetaRenderer *renderer = meta_backend_get_renderer (backend);
-  GList *l;
-
-  for (l = meta_renderer_get_views (renderer); l; l = l->next)
-    {
-      ClutterStageView *stage_view = l->data;
-
-      ensure_frame_callback (stage_native, stage_view);
-    }
-}
-
 void
 meta_stage_native_rebuild_views (MetaStageNative *stage_native)
 {
@@ -141,7 +61,6 @@ meta_stage_native_rebuild_views (MetaStageNative *stage_native)
 
   meta_renderer_rebuild_views (renderer);
   clutter_stage_clear_stage_views (CLUTTER_STAGE (stage));
-  ensure_frame_callbacks (stage_native);
 }
 
 static gboolean
@@ -186,16 +105,6 @@ meta_stage_native_get_views (ClutterStageWindow *stage_window)
   return meta_renderer_get_views (renderer);
 }
 
-static int64_t
-meta_stage_native_get_frame_counter (ClutterStageWindow *stage_window)
-{
-  MetaBackend *backend = meta_get_backend ();
-  MetaRenderer *renderer = meta_backend_get_renderer (backend);
-  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
-
-  return meta_renderer_native_get_frame_counter (renderer_native);
-}
-
 static void
 meta_stage_native_finish_frame (ClutterStageWindow *stage_window)
 {
@@ -225,6 +134,5 @@ clutter_stage_window_iface_init (ClutterStageWindowInterface *iface)
   iface->can_clip_redraws = meta_stage_native_can_clip_redraws;
   iface->get_geometry = meta_stage_native_get_geometry;
   iface->get_views = meta_stage_native_get_views;
-  iface->get_frame_counter = meta_stage_native_get_frame_counter;
   iface->finish_frame = meta_stage_native_finish_frame;
 }
diff --git a/src/backends/x11/cm/meta-renderer-x11-cm.c b/src/backends/x11/cm/meta-renderer-x11-cm.c
index a288fe61f6e691a7dd03d2fdc25550043eeaef69..afed2e3770e8500c09a777f0f50be8bbcd5caa5c 100644
--- a/src/backends/x11/cm/meta-renderer-x11-cm.c
+++ b/src/backends/x11/cm/meta-renderer-x11-cm.c
@@ -37,14 +37,17 @@ G_DEFINE_TYPE (MetaRendererX11Cm, meta_renderer_x11_cm,
                META_TYPE_RENDERER_X11)
 
 void
-meta_renderer_x11_cm_ensure_screen_view (MetaRendererX11Cm *renderer_x11_cm,
-                                         int                width,
-                                         int                height)
+meta_renderer_x11_cm_init_screen_view (MetaRendererX11Cm *renderer_x11_cm,
+                                       CoglOnscreen      *onscreen,
+                                       int                width,
+                                       int                height)
 {
+  MetaRenderer *renderer = META_RENDERER (renderer_x11_cm);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  ClutterActor *stage = meta_backend_get_stage (backend);
   cairo_rectangle_int_t view_layout;
 
-  if (renderer_x11_cm->screen_view)
-    return;
+  g_return_if_fail (!renderer_x11_cm->screen_view);
 
   view_layout = (cairo_rectangle_int_t) {
     .width = width,
@@ -52,7 +55,9 @@ meta_renderer_x11_cm_ensure_screen_view (MetaRendererX11Cm *renderer_x11_cm,
   };
   renderer_x11_cm->screen_view = g_object_new (META_TYPE_RENDERER_VIEW,
                                                "name", "X11 screen",
+                                               "stage", stage,
                                                "layout", &view_layout,
+                                               "framebuffer", onscreen,
                                                NULL);
   meta_renderer_add_view (META_RENDERER (renderer_x11_cm),
                           renderer_x11_cm->screen_view);
@@ -75,15 +80,6 @@ meta_renderer_x11_cm_resize (MetaRendererX11Cm *renderer_x11_cm,
                 NULL);
 }
 
-void
-meta_renderer_x11_cm_set_onscreen (MetaRendererX11Cm *renderer_x11_cm,
-                                   CoglOnscreen      *onscreen)
-{
-  g_object_set (G_OBJECT (renderer_x11_cm->screen_view),
-                "framebuffer", onscreen,
-                NULL);
-}
-
 static void
 meta_renderer_x11_cm_rebuild_views (MetaRenderer *renderer)
 {
@@ -94,6 +90,13 @@ meta_renderer_x11_cm_rebuild_views (MetaRenderer *renderer)
   meta_renderer_add_view (renderer, renderer_x11_cm->screen_view);
 }
 
+static GList *
+meta_renderer_x11_cm_get_views_for_monitor (MetaRenderer *renderer,
+                                            MetaMonitor  *monitor)
+{
+  return g_list_prepend (NULL, meta_renderer_get_views (renderer)->data);
+}
+
 static void
 meta_renderer_x11_cm_init (MetaRendererX11Cm *renderer_x11_cm)
 {
@@ -105,4 +108,6 @@ meta_renderer_x11_cm_class_init (MetaRendererX11CmClass *klass)
   MetaRendererClass *renderer_class = META_RENDERER_CLASS (klass);
 
   renderer_class->rebuild_views = meta_renderer_x11_cm_rebuild_views;
+  renderer_class->get_views_for_monitor =
+    meta_renderer_x11_cm_get_views_for_monitor;
 }
diff --git a/src/backends/x11/cm/meta-renderer-x11-cm.h b/src/backends/x11/cm/meta-renderer-x11-cm.h
index 65c5125bbcbcec4f1e282f0045a7eb2cd332190b..7ddb3445dd7282b713fa8da5745e12c134b31e12 100644
--- a/src/backends/x11/cm/meta-renderer-x11-cm.h
+++ b/src/backends/x11/cm/meta-renderer-x11-cm.h
@@ -30,15 +30,13 @@ G_DECLARE_FINAL_TYPE (MetaRendererX11Cm, meta_renderer_x11_cm,
                       META, RENDERER_X11_CM,
                       MetaRendererX11)
 
-void meta_renderer_x11_cm_ensure_screen_view (MetaRendererX11Cm *renderer_x11_cm,
-                                              int                width,
-                                              int                height);
+void meta_renderer_x11_cm_init_screen_view (MetaRendererX11Cm *renderer_x11_cm,
+                                            CoglOnscreen      *onscreen,
+                                            int                width,
+                                            int                height);
 
 void meta_renderer_x11_cm_resize (MetaRendererX11Cm *renderer_x11_cm,
                                   int                width,
                                   int                height);
 
-void meta_renderer_x11_cm_set_onscreen (MetaRendererX11Cm *renderer_x11_cm,
-                                        CoglOnscreen      *onscreen);
-
 #endif /* META_RENDERER_X11_CM_H */
diff --git a/src/backends/x11/meta-event-x11.c b/src/backends/x11/meta-event-x11.c
index 19da2235b87261aa852437ec6f08d9ac75206205..6aed4ed3f03056ae308c153a6b186396ce251f97 100644
--- a/src/backends/x11/meta-event-x11.c
+++ b/src/backends/x11/meta-event-x11.c
@@ -92,8 +92,6 @@ meta_x11_handle_event (XEvent *xevent)
 
   result = CLUTTER_X11_FILTER_CONTINUE;
 
-  _clutter_threads_acquire_lock ();
-
   backend = clutter_get_default_backend ();
 
   event = clutter_event_new (CLUTTER_NOTHING);
@@ -135,8 +133,6 @@ out:
   if (allocated_event)
     XFreeEventData (xdisplay, &xevent->xcookie);
 
-  _clutter_threads_release_lock ();
-
   return result;
 }
 
diff --git a/src/backends/x11/meta-stage-x11.c b/src/backends/x11/meta-stage-x11.c
index c5ed60b16edde3255590889bb8f1b674068b8f65..674cd3e4777dcc6f521fcee262cc089607b7ccad 100644
--- a/src/backends/x11/meta-stage-x11.c
+++ b/src/backends/x11/meta-stage-x11.c
@@ -247,35 +247,11 @@ meta_stage_x11_unrealize (ClutterStageWindow *stage_window)
                            GINT_TO_POINTER (stage_x11->xwin));
     }
 
-  if (stage_x11->frame_closure)
-    {
-      cogl_onscreen_remove_frame_callback (stage_x11->onscreen,
-                                           stage_x11->frame_closure);
-      stage_x11->frame_closure = NULL;
-    }
-
   clutter_stage_window_parent_iface->unrealize (stage_window);
 
   g_clear_pointer (&stage_x11->onscreen, cogl_object_unref);
 }
 
-static void
-frame_cb (CoglOnscreen  *onscreen,
-          CoglFrameEvent frame_event,
-          CoglFrameInfo *frame_info,
-          void          *user_data)
-
-{
-  ClutterStageCogl *stage_cogl = user_data;
-  ClutterFrameInfo clutter_frame_info = {
-    .frame_counter = cogl_frame_info_get_frame_counter (frame_info),
-    .presentation_time = cogl_frame_info_get_presentation_time (frame_info),
-    .refresh_rate = cogl_frame_info_get_refresh_rate (frame_info)
-  };
-
-  _clutter_stage_cogl_presented (stage_cogl, frame_event, &clutter_frame_info);
-}
-
 static gboolean
 meta_stage_x11_realize (ClutterStageWindow *stage_window)
 {
@@ -291,18 +267,15 @@ meta_stage_x11_realize (ClutterStageWindow *stage_window)
 
   stage_x11->onscreen = cogl_onscreen_new (backend->cogl_context, width, height);
 
-  stage_x11->frame_closure =
-    cogl_onscreen_add_frame_callback (stage_x11->onscreen,
-                                      frame_cb,
-                                      stage_cogl,
-                                      NULL);
-
   if (META_IS_BACKEND_X11_CM (stage_x11->backend))
     {
       MetaRenderer *renderer = meta_backend_get_renderer (stage_x11->backend);
       MetaRendererX11Cm *renderer_x11_cm = META_RENDERER_X11_CM (renderer);
 
-      meta_renderer_x11_cm_set_onscreen (renderer_x11_cm, stage_x11->onscreen);
+      meta_renderer_x11_cm_init_screen_view (renderer_x11_cm,
+                                             stage_x11->onscreen,
+                                             stage_x11->xwin_width,
+                                             stage_x11->xwin_height);
     }
 
   /* We just created a window of the size of the actor. No need to fix
@@ -480,14 +453,6 @@ meta_stage_x11_get_views (ClutterStageWindow *stage_window)
   return meta_renderer_get_views (renderer);
 }
 
-static int64_t
-meta_stage_x11_get_frame_counter (ClutterStageWindow *stage_window)
-{
-  MetaStageX11 *stage_x11 = META_STAGE_X11 (stage_window);
-
-  return cogl_onscreen_get_frame_counter (stage_x11->onscreen);
-}
-
 static void
 meta_stage_x11_finalize (GObject *object)
 {
@@ -509,9 +474,6 @@ meta_stage_x11_class_init (MetaStageX11Class *klass)
 static void
 meta_stage_x11_init (MetaStageX11 *stage)
 {
-  MetaRenderer *renderer;
-  MetaRendererX11Cm *renderer_x11_cm;
-
   stage->xwin = None;
   stage->xwin_width = 640;
   stage->xwin_height = 480;
@@ -522,16 +484,6 @@ meta_stage_x11_init (MetaStageX11 *stage)
 
   stage->backend = meta_get_backend ();
   g_assert (stage->backend);
-
-  if (META_IS_BACKEND_X11_CM (stage->backend))
-    {
-      renderer = meta_backend_get_renderer (stage->backend);
-      renderer_x11_cm = META_RENDERER_X11_CM (renderer);
-
-      meta_renderer_x11_cm_ensure_screen_view (renderer_x11_cm,
-                                               stage->xwin_width,
-                                               stage->xwin_height);
-    }
 }
 
 static void
@@ -548,7 +500,6 @@ clutter_stage_window_iface_init (ClutterStageWindowInterface *iface)
   iface->unrealize = meta_stage_x11_unrealize;
   iface->can_clip_redraws = meta_stage_x11_can_clip_redraws;
   iface->get_views = meta_stage_x11_get_views;
-  iface->get_frame_counter = meta_stage_x11_get_frame_counter;
 }
 
 static inline void
diff --git a/src/backends/x11/nested/meta-renderer-x11-nested.c b/src/backends/x11/nested/meta-renderer-x11-nested.c
index b4ad3ce8f1a928bd4c55373cb67f7190b39424c6..d6cbe363dc18b828f6480093369597ea226c5e95 100644
--- a/src/backends/x11/nested/meta-renderer-x11-nested.c
+++ b/src/backends/x11/nested/meta-renderer-x11-nested.c
@@ -164,6 +164,7 @@ meta_renderer_x11_nested_ensure_legacy_view (MetaRendererX11Nested *renderer_x11
   };
   legacy_view = g_object_new (META_TYPE_RENDERER_VIEW,
                               "name", "legacy nested",
+                              "stage", meta_backend_get_stage (backend),
                               "layout", &view_layout,
                               "framebuffer", COGL_FRAMEBUFFER (fake_onscreen),
                               NULL);
@@ -190,6 +191,7 @@ meta_renderer_x11_nested_create_view (MetaRenderer       *renderer,
   CoglOffscreen *fake_onscreen;
   CoglOffscreen *offscreen;
   MetaRectangle view_layout;
+  const MetaCrtcModeInfo *mode_info;
   MetaRendererView *view;
 
   view_transform = calculate_view_transform (monitor_manager, logical_monitor);
@@ -214,9 +216,14 @@ meta_renderer_x11_nested_create_view (MetaRenderer       *renderer,
                                      META_ROUNDING_STRATEGY_ROUND,
                                      &view_layout);
 
+  mode_info = meta_crtc_mode_get_info (crtc_config->mode);
+
   view = g_object_new (META_TYPE_RENDERER_VIEW,
                        "name", meta_output_get_name (output),
+                       "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
+                       "crtc", crtc,
+                       "refresh-rate", mode_info->refresh_rate,
                        "framebuffer", COGL_FRAMEBUFFER (fake_onscreen),
                        "offscreen", COGL_FRAMEBUFFER (offscreen),
                        "transform", view_transform,
diff --git a/src/backends/x11/nested/meta-stage-x11-nested.c b/src/backends/x11/nested/meta-stage-x11-nested.c
index 2d9c2ea558a85f5549fe2f76399f85eda72f2f23..be0ece2fa015fc23b131b4700568a342efc9c2b8 100644
--- a/src/backends/x11/nested/meta-stage-x11-nested.c
+++ b/src/backends/x11/nested/meta-stage-x11-nested.c
@@ -168,6 +168,7 @@ meta_stage_x11_nested_finish_frame (ClutterStageWindow *stage_window)
   ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
   CoglFramebuffer *onscreen = COGL_FRAMEBUFFER (stage_x11->onscreen);
   GList *l;
+  CoglFrameInfo *frame_info;
 
   if (!stage_nested->pipeline)
     stage_nested->pipeline = cogl_pipeline_new (clutter_backend->cogl_context);
@@ -193,7 +194,8 @@ meta_stage_x11_nested_finish_frame (ClutterStageWindow *stage_window)
       draw_view (stage_nested, renderer_view, texture);
     }
 
-  cogl_onscreen_swap_buffers (stage_x11->onscreen);
+  frame_info = cogl_frame_info_new (0);
+  cogl_onscreen_swap_buffers (stage_x11->onscreen, frame_info);
 }
 
 static void
diff --git a/src/compositor/compositor-private.h b/src/compositor/compositor-private.h
index 1917aa03dd2637db2162202f1a5f4fcd0dc38730..feb60b7e6b58ccdc8f8e072e4bd7caf4b8ccc1c9 100644
--- a/src/compositor/compositor-private.h
+++ b/src/compositor/compositor-private.h
@@ -23,8 +23,10 @@ struct _MetaCompositorClass
   gboolean (* manage) (MetaCompositor  *compositor,
                        GError         **error);
   void (* unmanage) (MetaCompositor *compositor);
-  void (* pre_paint) (MetaCompositor *compositor);
-  void (* post_paint) (MetaCompositor *compositor);
+  void (* before_paint) (MetaCompositor   *compositor,
+                         ClutterStageView *stage_view);
+  void (* after_paint) (MetaCompositor   *compositor,
+                        ClutterStageView *stage_view);
   void (* remove_window) (MetaCompositor *compositor,
                           MetaWindow     *window);
 };
diff --git a/src/compositor/compositor.c b/src/compositor/compositor.c
index 5918c904742964bc7c86025dca8f00788537efc1..79c93cf0ae36d63deb48990edbd04bfe1a37be4f 100644
--- a/src/compositor/compositor.c
+++ b/src/compositor/compositor.c
@@ -98,15 +98,6 @@ enum
 
 static GParamSpec *obj_props[N_PROPS] = { NULL, };
 
-enum
-{
-  PRE_PAINT,
-
-  N_SIGNALS
-};
-
-static guint signals[N_SIGNALS];
-
 typedef struct _MetaCompositorPrivate
 {
   GObject parent;
@@ -114,19 +105,15 @@ typedef struct _MetaCompositorPrivate
   MetaDisplay *display;
   MetaBackend *backend;
 
-  guint pre_paint_func_id;
-  guint post_paint_func_id;
-
   gulong stage_presented_id;
-  gulong stage_after_paint_id;
+  gulong before_paint_handler_id;
+  gulong after_paint_handler_id;
 
   int64_t server_time_query_time;
   int64_t server_time_offset;
 
   gboolean server_time_is_monotonic_time;
 
-  ClutterActor *stage;
-
   ClutterActor *window_group;
   ClutterActor *top_window_group;
   ClutterActor *feedback_group;
@@ -152,7 +139,7 @@ G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (MetaCompositor, meta_compositor,
 
 static void
 on_presented (ClutterStage     *stage,
-              CoglFrameEvent    event,
+              ClutterStageView *stage_view,
               ClutterFrameInfo *frame_info,
               MetaCompositor   *compositor);
 
@@ -493,19 +480,6 @@ meta_end_modal_for_plugin (MetaCompositor *compositor,
                          grab_window, grab_op);
 }
 
-static void
-after_stage_paint (ClutterStage *stage,
-                   gpointer      data)
-{
-  MetaCompositor *compositor = data;
-  MetaCompositorPrivate *priv =
-    meta_compositor_get_instance_private (compositor);
-  GList *l;
-
-  for (l = priv->windows; l; l = l->next)
-    meta_window_actor_post_paint (l->data);
-}
-
 static void
 redirect_windows (MetaX11Display *x11_display)
 {
@@ -574,18 +548,6 @@ meta_compositor_do_manage (MetaCompositor  *compositor,
                       G_CALLBACK (on_presented),
                       compositor);
 
-  /* We use connect_after() here to accomodate code in GNOME Shell that,
-   * when benchmarking drawing performance, connects to ::after-paint
-   * and calls glFinish(). The timing information from that will be
-   * more accurate if we hold off until that completes before we signal
-   * apps to begin drawing the next frame. If there are no other
-   * connections to ::after-paint, connect() vs. connect_after() doesn't
-   * matter.
-   */
-  priv->stage_after_paint_id =
-    g_signal_connect_after (stage, "after-paint",
-                            G_CALLBACK (after_stage_paint), compositor);
-
   clutter_stage_set_sync_delay (CLUTTER_STAGE (stage), META_SYNC_DELAY);
 
   priv->window_group = meta_window_group_new (display);
@@ -1073,87 +1035,86 @@ meta_compositor_sync_window_geometry (MetaCompositor *compositor,
 
 static void
 on_presented (ClutterStage     *stage,
-              CoglFrameEvent    event,
+              ClutterStageView *stage_view,
               ClutterFrameInfo *frame_info,
               MetaCompositor   *compositor)
 {
   MetaCompositorPrivate *priv =
     meta_compositor_get_instance_private (compositor);
+  int64_t presentation_time_cogl = frame_info->presentation_time;
+  int64_t presentation_time;
   GList *l;
 
-  if (event == COGL_FRAME_EVENT_COMPLETE)
+  if (presentation_time_cogl != 0)
     {
-      gint64 presentation_time_cogl = frame_info->presentation_time;
-      gint64 presentation_time;
+      int64_t current_cogl_time;
+      int64_t current_monotonic_time;
+
+      /* Cogl reports presentation in terms of its own clock, which is
+       * guaranteed to be in nanoseconds but with no specified base. The
+       * normal case with the open source GPU drivers on Linux 3.8 and
+       * newer is that the base of cogl_get_clock_time() is that of
+       * clock_gettime(CLOCK_MONOTONIC), so the same as g_get_monotonic_time),
+       * but there's no exposure of that through the API. clock_gettime()
+       * is fairly fast, so calling it twice and subtracting to get a
+       * nearly-zero number is acceptable, if a litle ugly.
+       */
+      current_cogl_time = cogl_get_clock_time (priv->context);
+      current_monotonic_time = g_get_monotonic_time ();
 
-      if (presentation_time_cogl != 0)
-        {
-          /* Cogl reports presentation in terms of its own clock, which is
-           * guaranteed to be in nanoseconds but with no specified base. The
-           * normal case with the open source GPU drivers on Linux 3.8 and
-           * newer is that the base of cogl_get_clock_time() is that of
-           * clock_gettime(CLOCK_MONOTONIC), so the same as g_get_monotonic_time),
-           * but there's no exposure of that through the API. clock_gettime()
-           * is fairly fast, so calling it twice and subtracting to get a
-           * nearly-zero number is acceptable, if a litle ugly.
-           */
-          gint64 current_cogl_time = cogl_get_clock_time (priv->context);
-          gint64 current_monotonic_time = g_get_monotonic_time ();
-
-          presentation_time =
-            current_monotonic_time + (presentation_time_cogl - current_cogl_time) / 1000;
-        }
-      else
+      presentation_time =
+        current_monotonic_time +
+        (presentation_time_cogl - current_cogl_time) / 1000;
+    }
+  else
+    {
+      presentation_time = 0;
+    }
+
+  for (l = priv->windows; l; l = l->next)
+    {
+      ClutterActor *actor = l->data;
+      GList *actor_stage_views;
+
+      actor_stage_views = clutter_actor_peek_stage_views (actor);
+      if (g_list_find (actor_stage_views, stage_view))
         {
-          presentation_time = 0;
+          meta_window_actor_frame_complete (META_WINDOW_ACTOR (actor),
+                                            frame_info,
+                                            presentation_time);
         }
-
-      for (l = priv->windows; l; l = l->next)
-        meta_window_actor_frame_complete (l->data, frame_info, presentation_time);
     }
 }
 
 static void
-meta_compositor_real_pre_paint (MetaCompositor *compositor)
+meta_compositor_real_before_paint (MetaCompositor   *compositor,
+                                   ClutterStageView *stage_view)
 {
   MetaCompositorPrivate *priv =
     meta_compositor_get_instance_private (compositor);
   GList *l;
 
   for (l = priv->windows; l; l = l->next)
-    meta_window_actor_pre_paint (l->data);
+    meta_window_actor_before_paint (l->data, stage_view);
 }
 
 static void
-meta_compositor_pre_paint (MetaCompositor *compositor)
+meta_compositor_before_paint (MetaCompositor   *compositor,
+                              ClutterStageView *stage_view)
 {
   COGL_TRACE_BEGIN_SCOPED (MetaCompositorPrePaint,
-                           "Compositor (pre-paint)");
-
-  g_signal_emit (compositor, signals[PRE_PAINT], 0);
-}
-
-static gboolean
-meta_pre_paint_func (gpointer data)
-{
-  MetaCompositor *compositor = data;
-
-  meta_compositor_pre_paint (compositor);
-
-  return TRUE;
+                           "Compositor (before-paint)");
+  META_COMPOSITOR_GET_CLASS (compositor)->before_paint (compositor, stage_view);
 }
 
 static void
-meta_compositor_real_post_paint (MetaCompositor *compositor)
+meta_compositor_real_after_paint (MetaCompositor   *compositor,
+                                  ClutterStageView *stage_view)
 {
   MetaCompositorPrivate *priv =
     meta_compositor_get_instance_private (compositor);
   CoglGraphicsResetStatus status;
-
-#ifdef HAVE_WAYLAND
-  if (meta_is_wayland_compositor ())
-    meta_wayland_compositor_paint_finished (meta_wayland_compositor_get_default ());
-#endif
+  GList *l;
 
   status = cogl_get_graphics_reset_status (priv->context);
   switch (status)
@@ -1177,24 +1138,41 @@ meta_compositor_real_post_paint (MetaCompositor *compositor)
       meta_restart (NULL);
       break;
     }
+
+  for (l = priv->windows; l; l = l->next)
+    {
+      ClutterActor *actor = l->data;
+      GList *actor_stage_views;
+
+      actor_stage_views = clutter_actor_peek_stage_views (actor);
+      if (g_list_find (actor_stage_views, stage_view))
+        meta_window_actor_after_paint (META_WINDOW_ACTOR (actor), stage_view);
+    }
 }
 
 static void
-meta_compositor_post_paint (MetaCompositor *compositor)
+meta_compositor_after_paint (MetaCompositor   *compositor,
+                             ClutterStageView *stage_view)
 {
   COGL_TRACE_BEGIN_SCOPED (MetaCompositorPostPaint,
-                           "Compositor (post-paint)");
-  META_COMPOSITOR_GET_CLASS (compositor)->post_paint (compositor);
+                           "Compositor (after-paint)");
+  META_COMPOSITOR_GET_CLASS (compositor)->after_paint (compositor, stage_view);
 }
 
-static gboolean
-meta_post_paint_func (gpointer data)
+static void
+on_before_paint (ClutterStage     *stage,
+                 ClutterStageView *stage_view,
+                 MetaCompositor   *compositor)
 {
-  MetaCompositor *compositor = data;
-
-  meta_compositor_post_paint (compositor);
+  meta_compositor_before_paint (compositor, stage_view);
+}
 
-  return TRUE;
+static void
+on_after_paint (ClutterStage     *stage,
+                ClutterStageView *stage_view,
+                MetaCompositor   *compositor)
+{
+  meta_compositor_after_paint (compositor, stage_view);
 }
 
 static void
@@ -1246,25 +1224,34 @@ meta_compositor_get_property (GObject    *object,
 static void
 meta_compositor_init (MetaCompositor *compositor)
 {
+}
+
+static void
+meta_compositor_constructed (GObject *object)
+{
+  MetaCompositor *compositor = META_COMPOSITOR (object);
   MetaCompositorPrivate *priv =
     meta_compositor_get_instance_private (compositor);
-  MetaBackend *backend = meta_get_backend ();
-  ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
+  ClutterBackend *clutter_backend =
+    meta_backend_get_clutter_backend (priv->backend);
+  ClutterActor *stage = meta_backend_get_stage (priv->backend);
 
   priv->context = clutter_backend->cogl_context;
 
-  priv->pre_paint_func_id =
-    clutter_threads_add_repaint_func_full (CLUTTER_REPAINT_FLAGS_PRE_PAINT,
-                                           meta_pre_paint_func,
-                                           compositor,
-                                           NULL);
-  priv->post_paint_func_id =
-    clutter_threads_add_repaint_func_full (CLUTTER_REPAINT_FLAGS_POST_PAINT,
-                                           meta_post_paint_func,
-                                           compositor,
-                                           NULL);
+  priv->before_paint_handler_id =
+    g_signal_connect (stage,
+                      "before-paint",
+                      G_CALLBACK (on_before_paint),
+                      compositor);
+  priv->after_paint_handler_id =
+    g_signal_connect_after (stage,
+                            "after-paint",
+                            G_CALLBACK (on_after_paint),
+                            compositor);
 
   priv->laters = meta_laters_new (compositor);
+
+  G_OBJECT_CLASS (meta_compositor_parent_class)->constructed (object);
 }
 
 static void
@@ -1277,13 +1264,9 @@ meta_compositor_dispose (GObject *object)
 
   g_clear_pointer (&priv->laters, meta_laters_free);
 
-  g_clear_signal_handler (&priv->stage_after_paint_id, stage);
   g_clear_signal_handler (&priv->stage_presented_id, stage);
-
-  g_clear_handle_id (&priv->pre_paint_func_id,
-                     clutter_threads_remove_repaint_func);
-  g_clear_handle_id (&priv->post_paint_func_id,
-                     clutter_threads_remove_repaint_func);
+  g_clear_signal_handler (&priv->before_paint_handler_id, stage);
+  g_clear_signal_handler (&priv->after_paint_handler_id, stage);
 
   g_clear_signal_handler (&priv->top_window_actor_destroy_id,
                           priv->top_window_actor);
@@ -1303,11 +1286,12 @@ meta_compositor_class_init (MetaCompositorClass *klass)
 
   object_class->set_property = meta_compositor_set_property;
   object_class->get_property = meta_compositor_get_property;
+  object_class->constructed = meta_compositor_constructed;
   object_class->dispose = meta_compositor_dispose;
 
   klass->remove_window = meta_compositor_real_remove_window;
-  klass->pre_paint = meta_compositor_real_pre_paint;
-  klass->post_paint = meta_compositor_real_post_paint;
+  klass->before_paint = meta_compositor_real_before_paint;
+  klass->after_paint = meta_compositor_real_after_paint;
 
   obj_props[PROP_DISPLAY] =
     g_param_spec_object ("display",
@@ -1326,14 +1310,6 @@ meta_compositor_class_init (MetaCompositorClass *klass)
                          G_PARAM_CONSTRUCT_ONLY |
                          G_PARAM_STATIC_STRINGS);
   g_object_class_install_properties (object_class, N_PROPS, obj_props);
-
-  signals[PRE_PAINT] =
-    g_signal_new ("pre-paint",
-                  G_TYPE_FROM_CLASS (klass),
-                  G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (MetaCompositorClass, pre_paint),
-                  NULL, NULL, NULL,
-                  G_TYPE_NONE, 0);
 }
 
 /**
diff --git a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
index cbbca374ba0886ba8894db6da187955f5a9aaf87..92b0aedf9cd3dea940e7bc5ad3e38b6c4ff9c32d 100644
--- a/src/compositor/meta-compositor-native.c
+++ b/src/compositor/meta-compositor-native.c
@@ -116,14 +116,15 @@ maybe_assign_primary_plane (MetaCompositor *compositor)
 }
 
 static void
-meta_compositor_native_pre_paint (MetaCompositor *compositor)
+meta_compositor_native_before_paint (MetaCompositor   *compositor,
+                                     ClutterStageView *stage_view)
 {
   MetaCompositorClass *parent_class;
 
   maybe_assign_primary_plane (compositor);
 
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_native_parent_class);
-  parent_class->pre_paint (compositor);
+  parent_class->before_paint (compositor, stage_view);
 }
 
 MetaCompositorNative *
@@ -146,5 +147,5 @@ meta_compositor_native_class_init (MetaCompositorNativeClass *klass)
 {
   MetaCompositorClass *compositor_class = META_COMPOSITOR_CLASS (klass);
 
-  compositor_class->pre_paint = meta_compositor_native_pre_paint;
+  compositor_class->before_paint = meta_compositor_native_before_paint;
 }
diff --git a/src/compositor/meta-compositor-x11.c b/src/compositor/meta-compositor-x11.c
index 0ab4aa0320adf142c55f08d4ee355a75edc3ee78..fcd292a1f30e53e8871e328f1c9433f6f5962977 100644
--- a/src/compositor/meta-compositor-x11.c
+++ b/src/compositor/meta-compositor-x11.c
@@ -39,6 +39,8 @@ struct _MetaCompositorX11
 
   Window output;
 
+  gulong before_update_handler_id;
+
   gboolean frame_has_updated_xsurfaces;
   gboolean have_x11_sync_object;
 
@@ -291,15 +293,11 @@ out:
 }
 
 static void
-meta_compositor_x11_pre_paint (MetaCompositor *compositor)
+on_before_update (ClutterStage     *stage,
+                  ClutterStageView *stage_view,
+                  MetaCompositor   *compositor)
 {
   MetaCompositorX11 *compositor_x11 = META_COMPOSITOR_X11 (compositor);
-  MetaCompositorClass *parent_class;
-
-  maybe_unredirect_top_window (compositor_x11);
-
-  parent_class = META_COMPOSITOR_CLASS (meta_compositor_x11_parent_class);
-  parent_class->pre_paint (compositor);
 
   if (compositor_x11->frame_has_updated_xsurfaces)
     {
@@ -333,7 +331,21 @@ meta_compositor_x11_pre_paint (MetaCompositor *compositor)
 }
 
 static void
-meta_compositor_x11_post_paint (MetaCompositor *compositor)
+meta_compositor_x11_before_paint (MetaCompositor   *compositor,
+                                  ClutterStageView *stage_view)
+{
+  MetaCompositorX11 *compositor_x11 = META_COMPOSITOR_X11 (compositor);
+  MetaCompositorClass *parent_class;
+
+  maybe_unredirect_top_window (compositor_x11);
+
+  parent_class = META_COMPOSITOR_CLASS (meta_compositor_x11_parent_class);
+  parent_class->before_paint (compositor, stage_view);
+}
+
+static void
+meta_compositor_x11_after_paint (MetaCompositor   *compositor,
+                                 ClutterStageView *stage_view)
 {
   MetaCompositorX11 *compositor_x11 = META_COMPOSITOR_X11 (compositor);
   MetaCompositorClass *parent_class;
@@ -347,7 +359,7 @@ meta_compositor_x11_post_paint (MetaCompositor *compositor)
     }
 
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_x11_parent_class);
-  parent_class->post_paint (compositor);
+  parent_class->after_paint (compositor, stage_view);
 }
 
 static void
@@ -380,10 +392,26 @@ meta_compositor_x11_new (MetaDisplay *display,
                        NULL);
 }
 
+static void
+meta_compositor_x11_constructed (GObject *object)
+{
+  MetaCompositorX11 *compositor_x11 = META_COMPOSITOR_X11 (object);
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  ClutterStage *stage = meta_compositor_get_stage (compositor);
+
+  compositor_x11->before_update_handler_id =
+    g_signal_connect (stage, "before-update",
+                      G_CALLBACK (on_before_update), compositor);
+
+  G_OBJECT_CLASS (meta_compositor_x11_parent_class)->constructed (object);
+}
+
 static void
 meta_compositor_x11_dispose (GObject *object)
 {
   MetaCompositorX11 *compositor_x11 = META_COMPOSITOR_X11 (object);
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  ClutterStage *stage = meta_compositor_get_stage (compositor);
 
   if (compositor_x11->have_x11_sync_object)
     {
@@ -391,6 +419,8 @@ meta_compositor_x11_dispose (GObject *object)
       compositor_x11->have_x11_sync_object = FALSE;
     }
 
+  g_clear_signal_handler (&compositor_x11->before_update_handler_id, stage);
+
   G_OBJECT_CLASS (meta_compositor_x11_parent_class)->dispose (object);
 }
 
@@ -405,11 +435,12 @@ meta_compositor_x11_class_init (MetaCompositorX11Class *klass)
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
   MetaCompositorClass *compositor_class = META_COMPOSITOR_CLASS (klass);
 
+  object_class->constructed = meta_compositor_x11_constructed;
   object_class->dispose = meta_compositor_x11_dispose;
 
   compositor_class->manage = meta_compositor_x11_manage;
   compositor_class->unmanage = meta_compositor_x11_unmanage;
-  compositor_class->pre_paint = meta_compositor_x11_pre_paint;
-  compositor_class->post_paint = meta_compositor_x11_post_paint;
+  compositor_class->before_paint = meta_compositor_x11_before_paint;
+  compositor_class->after_paint = meta_compositor_x11_after_paint;
   compositor_class->remove_window = meta_compositor_x11_remove_window;
 }
diff --git a/src/compositor/meta-later.c b/src/compositor/meta-later.c
index b68e59a5b04433370034af9283743ab6de692313..dff091d759cea6fe397f68904511d16315a7724b 100644
--- a/src/compositor/meta-later.c
+++ b/src/compositor/meta-later.c
@@ -50,8 +50,7 @@ struct _MetaLaters
 
   GSList *laters[META_LATER_N_TYPES];
 
-  ClutterTimeline *timeline;
-  gulong pre_paint_handler_id;
+  gulong before_update_handler_id;
 };
 
 static MetaLater *
@@ -166,12 +165,13 @@ run_repaint_laters (GSList **laters_list)
 }
 
 static void
-on_pre_paint (MetaCompositor *compositor,
-              MetaLaters     *laters)
+on_before_update (ClutterStage     *stage,
+                  ClutterStageView *stage_view,
+                  MetaLaters       *laters)
 {
   unsigned int i;
   GSList *l;
-  gboolean keep_timeline_running = FALSE;
+  gboolean needs_schedule_update = FALSE;
 
   for (i = 0; i < G_N_ELEMENTS (laters->laters); i++)
     run_repaint_laters (&laters->laters[i]);
@@ -183,18 +183,12 @@ on_pre_paint (MetaCompositor *compositor,
           MetaLater *later = l->data;
 
           if (!later->source_id)
-            keep_timeline_running = TRUE;
+            needs_schedule_update = TRUE;
         }
     }
 
-  if (!keep_timeline_running)
-    clutter_timeline_stop (laters->timeline);
-}
-
-static void
-ensure_timeline_running (MetaLaters *laters)
-{
-  clutter_timeline_start (laters->timeline);
+  if (needs_schedule_update)
+    clutter_stage_schedule_update (stage);
 }
 
 static gboolean
@@ -221,6 +215,7 @@ meta_laters_add (MetaLaters     *laters,
                  gpointer        user_data,
                  GDestroyNotify  notify)
 {
+  ClutterStage *stage = meta_compositor_get_stage (laters->compositor);
   MetaLater *later = g_slice_new0 (MetaLater);
 
   later->id = ++laters->last_later_id;
@@ -239,13 +234,13 @@ meta_laters_add (MetaLaters     *laters,
                                           invoke_later_idle,
                                           later, NULL);
       g_source_set_name_by_id (later->source_id, "[mutter] invoke_later_idle");
-      ensure_timeline_running (laters);
+      clutter_stage_schedule_update (stage);
       break;
     case META_LATER_CALC_SHOWING:
     case META_LATER_CHECK_FULLSCREEN:
     case META_LATER_SYNC_STACK:
     case META_LATER_BEFORE_REDRAW:
-      ensure_timeline_running (laters);
+      clutter_stage_schedule_update (stage);
       break;
     case META_LATER_IDLE:
       later->source_id = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
@@ -322,15 +317,16 @@ meta_later_remove (unsigned int later_id)
 MetaLaters *
 meta_laters_new (MetaCompositor *compositor)
 {
+  ClutterStage *stage = meta_compositor_get_stage (compositor);
   MetaLaters *laters;
 
   laters = g_new0 (MetaLaters, 1);
   laters->compositor = compositor;
-  laters->timeline = clutter_timeline_new (G_MAXUINT);
 
-  laters->pre_paint_handler_id = g_signal_connect (compositor, "pre-paint",
-                                                   G_CALLBACK (on_pre_paint),
-                                                   laters);
+  laters->before_update_handler_id =
+    g_signal_connect (stage, "before-update",
+                      G_CALLBACK (on_before_update),
+                      laters);
 
   return laters;
 }
@@ -338,12 +334,12 @@ meta_laters_new (MetaCompositor *compositor)
 void
 meta_laters_free (MetaLaters *laters)
 {
+  ClutterStage *stage = meta_compositor_get_stage (laters->compositor);
   unsigned int i;
 
   for (i = 0; i < G_N_ELEMENTS (laters->laters); i++)
     g_slist_free_full (laters->laters[i], (GDestroyNotify) meta_later_unref);
 
-  g_clear_object (&laters->timeline);
-  g_clear_signal_handler (&laters->pre_paint_handler_id, laters->compositor);
+  g_clear_signal_handler (&laters->before_update_handler_id, stage);
   g_free (laters);
 }
diff --git a/src/compositor/meta-surface-actor-wayland.c b/src/compositor/meta-surface-actor-wayland.c
index ce50da16200dbe6baeeb501c9232d9b540643758..b8071067bdc70f3d36175b57f368226bc0f1285a 100644
--- a/src/compositor/meta-surface-actor-wayland.c
+++ b/src/compositor/meta-surface-actor-wayland.c
@@ -58,11 +58,6 @@ meta_surface_actor_wayland_process_damage (MetaSurfaceActor *actor,
   meta_surface_actor_update_area (actor, x, y, width, height);
 }
 
-static void
-meta_surface_actor_wayland_pre_paint (MetaSurfaceActor *actor)
-{
-}
-
 static gboolean
 meta_surface_actor_wayland_is_opaque (MetaSurfaceActor *actor)
 {
@@ -113,7 +108,6 @@ meta_surface_actor_wayland_class_init (MetaSurfaceActorWaylandClass *klass)
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
   surface_actor_class->process_damage = meta_surface_actor_wayland_process_damage;
-  surface_actor_class->pre_paint = meta_surface_actor_wayland_pre_paint;
   surface_actor_class->is_opaque = meta_surface_actor_wayland_is_opaque;
 
   object_class->dispose = meta_surface_actor_wayland_dispose;
diff --git a/src/compositor/meta-surface-actor-x11.c b/src/compositor/meta-surface-actor-x11.c
index 3b1a250d944bc1ceefab58e7464ec61bc3a7752c..d46e5ad49624be4d19141f747de1aad5e660bc96 100644
--- a/src/compositor/meta-surface-actor-x11.c
+++ b/src/compositor/meta-surface-actor-x11.c
@@ -220,10 +220,9 @@ meta_surface_actor_x11_process_damage (MetaSurfaceActor *actor,
   meta_surface_actor_update_area (actor, x, y, width, height);
 }
 
-static void
-meta_surface_actor_x11_pre_paint (MetaSurfaceActor *actor)
+void
+meta_surface_actor_x11_handle_updates (MetaSurfaceActorX11 *self)
 {
-  MetaSurfaceActorX11 *self = META_SURFACE_ACTOR_X11 (actor);
   MetaDisplay *display = self->display;
   Display *xdisplay = meta_x11_display_get_xdisplay (display->x11_display);
 
@@ -332,7 +331,6 @@ meta_surface_actor_x11_class_init (MetaSurfaceActorX11Class *klass)
   object_class->dispose = meta_surface_actor_x11_dispose;
 
   surface_actor_class->process_damage = meta_surface_actor_x11_process_damage;
-  surface_actor_class->pre_paint = meta_surface_actor_x11_pre_paint;
   surface_actor_class->is_opaque = meta_surface_actor_x11_is_opaque;
 }
 
diff --git a/src/compositor/meta-surface-actor-x11.h b/src/compositor/meta-surface-actor-x11.h
index 9fd703bfe073a07dfa9bcd8f42ccbbc481fb7667..0a8517236ad116d3af55be72b001f57c42661824 100644
--- a/src/compositor/meta-surface-actor-x11.h
+++ b/src/compositor/meta-surface-actor-x11.h
@@ -55,6 +55,8 @@ gboolean meta_surface_actor_x11_is_unredirected (MetaSurfaceActorX11 *self);
 
 gboolean meta_surface_actor_x11_is_visible (MetaSurfaceActorX11 *self);
 
+void meta_surface_actor_x11_handle_updates (MetaSurfaceActorX11 *self);
+
 G_END_DECLS
 
 #endif /* __META_SURFACE_ACTOR_X11_H__ */
diff --git a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
index 2f3934a40011d643630433eefe71f67ccad7f3d6..884a7a2b34425bc6fb1d746543987ee1d8999e6f 100644
--- a/src/compositor/meta-surface-actor.c
+++ b/src/compositor/meta-surface-actor.c
@@ -555,12 +555,6 @@ meta_surface_actor_process_damage (MetaSurfaceActor *self,
   META_SURFACE_ACTOR_GET_CLASS (self)->process_damage (self, x, y, width, height);
 }
 
-void
-meta_surface_actor_pre_paint (MetaSurfaceActor *self)
-{
-  META_SURFACE_ACTOR_GET_CLASS (self)->pre_paint (self);
-}
-
 void
 meta_surface_actor_set_frozen (MetaSurfaceActor *self,
                                gboolean          frozen)
diff --git a/src/compositor/meta-surface-actor.h b/src/compositor/meta-surface-actor.h
index d8b7365b29e6a0fe8de51cf411734168863bb351..fb3764c0f944c5561100d677a2c1a4a3eedef8c1 100644
--- a/src/compositor/meta-surface-actor.h
+++ b/src/compositor/meta-surface-actor.h
@@ -24,7 +24,6 @@ struct _MetaSurfaceActorClass
 
   void     (* process_damage)    (MetaSurfaceActor *actor,
                                   int x, int y, int width, int height);
-  void     (* pre_paint)         (MetaSurfaceActor *actor);
   gboolean (* is_opaque)         (MetaSurfaceActor *actor);
 };
 
@@ -49,7 +48,7 @@ cairo_region_t * meta_surface_actor_get_opaque_region (MetaSurfaceActor *self);
 
 void meta_surface_actor_process_damage (MetaSurfaceActor *actor,
                                         int x, int y, int width, int height);
-void meta_surface_actor_pre_paint (MetaSurfaceActor *actor);
+
 gboolean meta_surface_actor_is_opaque (MetaSurfaceActor *actor);
 
 gboolean meta_surface_actor_is_frozen (MetaSurfaceActor *actor);
diff --git a/src/compositor/meta-window-actor-private.h b/src/compositor/meta-window-actor-private.h
index 31cc37702d921b0af9141e742a612494ce8acc63..57dbd0ad073ebc9fcb2fbf37e4a78441eaf86005 100644
--- a/src/compositor/meta-window-actor-private.h
+++ b/src/compositor/meta-window-actor-private.h
@@ -23,8 +23,11 @@ struct _MetaWindowActorClass
   void (*queue_frame_drawn) (MetaWindowActor *actor,
                              gboolean         skip_sync_delay);
 
-  void (*pre_paint) (MetaWindowActor *actor);
-  void (*post_paint) (MetaWindowActor *actor);
+  void (*before_paint) (MetaWindowActor  *actor,
+                        ClutterStageView *stage_view);
+  void (*after_paint) (MetaWindowActor  *actor,
+                       ClutterStageView *stage_view);
+
   void (*queue_destroy) (MetaWindowActor *actor);
   void (*set_frozen) (MetaWindowActor *actor,
                       gboolean         frozen);
@@ -49,8 +52,10 @@ void meta_window_actor_size_change   (MetaWindowActor *self,
                                       MetaRectangle   *old_frame_rect,
                                       MetaRectangle   *old_buffer_rect);
 
-void meta_window_actor_pre_paint      (MetaWindowActor    *self);
-void meta_window_actor_post_paint     (MetaWindowActor    *self);
+void meta_window_actor_before_paint   (MetaWindowActor    *self,
+                                       ClutterStageView   *stage_view);
+void meta_window_actor_after_paint    (MetaWindowActor    *self,
+                                       ClutterStageView   *stage_view);
 void meta_window_actor_frame_complete (MetaWindowActor    *self,
                                        ClutterFrameInfo   *frame_info,
                                        gint64              presentation_time);
diff --git a/src/compositor/meta-window-actor-wayland.c b/src/compositor/meta-window-actor-wayland.c
index bd890256c6b45bf69162f4c6c61af7cc515d724c..a287fdcbac1f3f0d08b7ede0deac270c10e182ff 100644
--- a/src/compositor/meta-window-actor-wayland.c
+++ b/src/compositor/meta-window-actor-wayland.c
@@ -119,12 +119,14 @@ meta_window_actor_wayland_queue_frame_drawn (MetaWindowActor *actor,
 }
 
 static void
-meta_window_actor_wayland_pre_paint (MetaWindowActor *actor)
+meta_window_actor_wayland_before_paint (MetaWindowActor  *actor,
+                                        ClutterStageView *stage_view)
 {
 }
 
 static void
-meta_window_actor_wayland_post_paint (MetaWindowActor *actor)
+meta_window_actor_wayland_after_paint (MetaWindowActor  *actor,
+                                       ClutterStageView *stage_view)
 {
 }
 
@@ -178,8 +180,8 @@ meta_window_actor_wayland_class_init (MetaWindowActorWaylandClass *klass)
   window_actor_class->assign_surface_actor = meta_window_actor_wayland_assign_surface_actor;
   window_actor_class->frame_complete = meta_window_actor_wayland_frame_complete;
   window_actor_class->queue_frame_drawn = meta_window_actor_wayland_queue_frame_drawn;
-  window_actor_class->pre_paint = meta_window_actor_wayland_pre_paint;
-  window_actor_class->post_paint = meta_window_actor_wayland_post_paint;
+  window_actor_class->before_paint = meta_window_actor_wayland_before_paint;
+  window_actor_class->after_paint = meta_window_actor_wayland_after_paint;
   window_actor_class->queue_destroy = meta_window_actor_wayland_queue_destroy;
   window_actor_class->set_frozen = meta_window_actor_wayland_set_frozen;
   window_actor_class->update_regions = meta_window_actor_wayland_update_regions;
diff --git a/src/compositor/meta-window-actor-x11.c b/src/compositor/meta-window-actor-x11.c
index c8bc3784d08dbfbe87d700b09a08e526ad796dfd..a2bc1d9394d55351f4c6e0460166fc707541fd0c 100644
--- a/src/compositor/meta-window-actor-x11.c
+++ b/src/compositor/meta-window-actor-x11.c
@@ -25,6 +25,7 @@
 #include "compositor/meta-window-actor-x11.h"
 
 #include "backends/meta-logical-monitor.h"
+#include "clutter/clutter-frame-clock.h"
 #include "compositor/compositor-private.h"
 #include "compositor/meta-cullable.h"
 #include "compositor/meta-shaped-texture-private.h"
@@ -58,6 +59,8 @@ struct _MetaWindowActorX11
 
   guint send_frame_messages_timer;
   int64_t frame_drawn_time;
+  gboolean pending_schedule_update_now;
+  ClutterFrameClock *frame_clock;
 
   gulong repaint_scheduled_id;
   gulong size_changed_id;
@@ -372,8 +375,8 @@ meta_window_actor_x11_frame_complete (MetaWindowActor  *actor,
             g_warning ("%s: Frame has assigned frame counter but no frame drawn time",
                        window->desc);
           if (G_UNLIKELY (frame->frame_counter < frame_counter))
-            g_warning ("%s: frame_complete callback never occurred for frame %" G_GINT64_FORMAT,
-                       window->desc, frame->frame_counter);
+            g_debug ("%s: frame_complete callback never occurred for frame %" G_GINT64_FORMAT,
+                     window->desc, frame->frame_counter);
 
           actor_x11->frames = g_list_delete_link (actor_x11->frames, l);
           send_frame_timings (actor_x11, frame, frame_info, presentation_time);
@@ -451,8 +454,10 @@ meta_window_actor_x11_queue_frame_drawn (MetaWindowActor *actor,
 
   if (skip_sync_delay)
     {
-      ClutterActor *stage = clutter_actor_get_stage (CLUTTER_ACTOR (actor_x11));
-      clutter_stage_skip_sync_delay (CLUTTER_STAGE (stage));
+      if (actor_x11->frame_clock)
+        clutter_frame_clock_schedule_update_now (actor_x11->frame_clock);
+      else
+        actor_x11->pending_schedule_update_now = TRUE;
     }
 
   if (!actor_x11->repaint_scheduled)
@@ -470,12 +475,14 @@ meta_window_actor_x11_queue_frame_drawn (MetaWindowActor *actor,
       /* A frame was marked by the client without actually doing any
        * damage or any unobscured, or while we had the window frozen
        * (e.g. during an interactive resize.) We need to make sure that the
-       * pre_paint/post_paint functions get called, enabling us to
+       * before_paint/after_paint functions get called, enabling us to
        * send a _NET_WM_FRAME_DRAWN. We do a 1-pixel redraw to get
        * consistent timing with non-empty frames. If the window
-       * is completely obscured we fire off the send_frame_messages timeout.
+       * is completely obscured, or completely off screen we fire off the
+       * send_frame_messages timeout.
        */
-      if (is_obscured)
+      if (is_obscured ||
+          !clutter_actor_peek_stage_views (CLUTTER_ACTOR (actor)))
         {
           queue_send_frame_messages_timeout (actor_x11);
         }
@@ -1209,7 +1216,12 @@ handle_updates (MetaWindowActorX11 *actor_x11)
       return;
     }
 
-  meta_surface_actor_pre_paint (surface);
+  if (META_IS_SURFACE_ACTOR_X11 (surface))
+    {
+      MetaSurfaceActorX11 *surface_x11 = META_SURFACE_ACTOR_X11 (surface);
+
+      meta_surface_actor_x11_handle_updates (surface_x11);
+    }
 
   if (!META_IS_SURFACE_ACTOR_X11 (surface) ||
       !meta_surface_actor_x11_is_visible (META_SURFACE_ACTOR_X11 (surface)))
@@ -1221,7 +1233,21 @@ handle_updates (MetaWindowActorX11 *actor_x11)
 }
 
 static void
-meta_window_actor_x11_pre_paint (MetaWindowActor *actor)
+handle_stage_views_changed (MetaWindowActorX11 *actor_x11)
+{
+  ClutterActor *actor = CLUTTER_ACTOR (actor_x11);
+
+  actor_x11->frame_clock = clutter_actor_pick_frame_clock (actor);
+  if (actor_x11->frame_clock && actor_x11->pending_schedule_update_now)
+    {
+      clutter_frame_clock_schedule_update_now (actor_x11->frame_clock);
+      actor_x11->pending_schedule_update_now = FALSE;
+    }
+}
+
+static void
+meta_window_actor_x11_before_paint (MetaWindowActor  *actor,
+                                    ClutterStageView *stage_view)
 {
   MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (actor);
 
@@ -1299,7 +1325,8 @@ meta_window_actor_x11_paint (ClutterActor        *actor,
 }
 
 static void
-meta_window_actor_x11_post_paint (MetaWindowActor *actor)
+meta_window_actor_x11_after_paint (MetaWindowActor  *actor,
+                                   ClutterStageView *stage_view)
 {
   MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (actor);
   MetaWindow *window;
@@ -1593,8 +1620,8 @@ meta_window_actor_x11_class_init (MetaWindowActorX11Class *klass)
   window_actor_class->frame_complete = meta_window_actor_x11_frame_complete;
   window_actor_class->assign_surface_actor = meta_window_actor_x11_assign_surface_actor;
   window_actor_class->queue_frame_drawn = meta_window_actor_x11_queue_frame_drawn;
-  window_actor_class->pre_paint = meta_window_actor_x11_pre_paint;
-  window_actor_class->post_paint = meta_window_actor_x11_post_paint;
+  window_actor_class->before_paint = meta_window_actor_x11_before_paint;
+  window_actor_class->after_paint = meta_window_actor_x11_after_paint;
   window_actor_class->queue_destroy = meta_window_actor_x11_queue_destroy;
   window_actor_class->set_frozen = meta_window_actor_x11_set_frozen;
   window_actor_class->update_regions = meta_window_actor_x11_update_regions;
@@ -1636,6 +1663,9 @@ meta_window_actor_x11_init (MetaWindowActorX11 *self)
   /* We do this now since we might be going right back into the frozen state. */
   g_signal_connect (self, "thawed", G_CALLBACK (handle_updates), NULL);
 
+  g_signal_connect (self, "stage-views-changed",
+                    G_CALLBACK (handle_stage_views_changed), NULL);
+
   self->shadow_factory = meta_shadow_factory_get_default ();
   self->shadow_factory_changed_handler_id =
     g_signal_connect_swapped (self->shadow_factory,
diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index b35d90d2474f5e98bbc03fc0b9bbc4f184df7d29..8d2548fbb76e280b619362ebb074a70f3128d2a0 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -1021,21 +1021,23 @@ meta_window_actor_sync_visibility (MetaWindowActor *self)
 }
 
 void
-meta_window_actor_pre_paint (MetaWindowActor *self)
+meta_window_actor_before_paint (MetaWindowActor  *self,
+                                ClutterStageView *stage_view)
 {
   if (meta_window_actor_is_destroyed (self))
     return;
 
-  META_WINDOW_ACTOR_GET_CLASS (self)->pre_paint (self);
+  META_WINDOW_ACTOR_GET_CLASS (self)->before_paint (self, stage_view);
 }
 
 void
-meta_window_actor_post_paint (MetaWindowActor *self)
+meta_window_actor_after_paint (MetaWindowActor  *self,
+                               ClutterStageView *stage_view)
 {
   MetaWindowActorPrivate *priv =
     meta_window_actor_get_instance_private (self);
 
-  META_WINDOW_ACTOR_GET_CLASS (self)->post_paint (self);
+  META_WINDOW_ACTOR_GET_CLASS (self)->after_paint (self, stage_view);
 
   if (meta_window_actor_is_destroyed (self))
     return;
diff --git a/src/tests/clutter/conform/actor-clone.c b/src/tests/clutter/conform/actor-clone.c
index e78bf9bafd01ebd41e8bd942072198356a532fc3..582ddbbf3001d2a0c02373c119d4ecb0b3abd58c 100644
--- a/src/tests/clutter/conform/actor-clone.c
+++ b/src/tests/clutter/conform/actor-clone.c
@@ -7,7 +7,7 @@
 
 static void
 on_presented (ClutterStage     *stage,
-              CoglFrameEvent   *frame_event,
+              ClutterStageView *view,
               ClutterFrameInfo *frame_info,
               gboolean         *was_presented)
 {
diff --git a/src/tests/clutter/conform/frame-clock-timeline.c b/src/tests/clutter/conform/frame-clock-timeline.c
new file mode 100644
index 0000000000000000000000000000000000000000..7e5798b4e27ac6be6053c990d2f4fffad4164c37
--- /dev/null
+++ b/src/tests/clutter/conform/frame-clock-timeline.c
@@ -0,0 +1,204 @@
+#include "clutter/clutter.h"
+#include "tests/clutter-test-utils.h"
+
+static const float refresh_rate = 60.0;
+
+static ClutterFrameResult
+timeline_frame_clock_frame (ClutterFrameClock *frame_clock,
+                            int64_t            frame_count,
+                            int64_t            time_us,
+                            gpointer           user_data)
+{
+  ClutterFrameInfo frame_info;
+
+  frame_info = (ClutterFrameInfo) {
+    .presentation_time = g_get_monotonic_time (),
+    .refresh_rate = refresh_rate,
+  };
+  clutter_frame_clock_notify_presented (frame_clock, &frame_info);
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface timeline_frame_listener_iface = {
+  .frame = timeline_frame_clock_frame,
+};
+
+static void
+on_marker_reached (ClutterTimeline *timeline,
+                   const char      *marker_name,
+                   unsigned int     frame_number,
+                   gboolean        *marker_reached)
+{
+  *marker_reached = TRUE;
+}
+
+static void
+on_timeline_new_frame (ClutterTimeline *timeline,
+                       int              time_ms,
+                       int             *frame_counter)
+{
+  (*frame_counter)++;
+}
+
+static void
+on_timeline_completed (ClutterTimeline *timeline,
+                       GMainLoop       *main_loop)
+{
+  g_main_loop_quit (main_loop);
+}
+
+static void
+frame_clock_timeline_basic (void)
+{
+  GMainLoop *main_loop;
+  ClutterFrameClock *frame_clock;
+  ClutterTimeline *timeline;
+  gboolean marker1_reached;
+  int frame_counter;
+  int64_t before_us;
+  int64_t after_us;
+
+  main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &timeline_frame_listener_iface,
+                                         NULL);
+  g_object_add_weak_pointer (G_OBJECT (frame_clock), (gpointer *) &frame_clock);
+
+  timeline = g_object_new (CLUTTER_TYPE_TIMELINE,
+                           "duration", 1000,
+                           "frame-clock", frame_clock,
+                           NULL);
+  g_object_add_weak_pointer (G_OBJECT (timeline), (gpointer *) &timeline);
+
+  clutter_timeline_add_marker_at_time (timeline, "marker1", 500);
+
+  marker1_reached = FALSE;
+  frame_counter = 0;
+
+  g_signal_connect (timeline, "marker-reached::marker1",
+                    G_CALLBACK (on_marker_reached),
+                    &marker1_reached);
+  g_signal_connect (timeline, "new-frame",
+                    G_CALLBACK (on_timeline_new_frame),
+                    &frame_counter);
+  g_signal_connect (timeline, "completed",
+                    G_CALLBACK (on_timeline_completed),
+                    main_loop);
+
+  clutter_timeline_start (timeline);
+
+  before_us = g_get_monotonic_time ();
+
+  g_main_loop_run (main_loop);
+
+  after_us = g_get_monotonic_time ();
+
+  g_assert_cmpint (after_us - before_us,
+                   >=,
+                   ms2us (clutter_timeline_get_duration (timeline)));
+
+  g_assert_true (marker1_reached);
+
+  /* Just check that we got at least a few frames. Require too high and we'll be
+   * flaky.
+   */
+  g_assert_cmpint (frame_counter, >, 20);
+
+  g_main_loop_unref (main_loop);
+  g_object_unref (timeline);
+  g_assert_null (timeline);
+  clutter_frame_clock_destroy (frame_clock);
+  g_assert_null (frame_clock);
+}
+
+static void
+on_switch_reached (ClutterTimeline   *timeline,
+                   const char        *marker_name,
+                   unsigned int       frame_number,
+                   ClutterFrameClock *new_frame_clock)
+{
+  ClutterFrameClock *old_frame_clock;
+
+  old_frame_clock = clutter_timeline_get_frame_clock (timeline);
+  clutter_frame_clock_inhibit (old_frame_clock);
+
+  clutter_timeline_set_frame_clock (timeline, new_frame_clock);
+}
+
+static void
+frame_clock_timeline_switch (void)
+{
+  GMainLoop *main_loop;
+  ClutterFrameClock *frame_clock2;
+  ClutterFrameClock *frame_clock1;
+  ClutterTimeline *timeline;
+  int frame_counter;
+  int64_t before_us;
+  int64_t after_us;
+
+  main_loop = g_main_loop_new (NULL, FALSE);
+
+  frame_clock1 = clutter_frame_clock_new (refresh_rate,
+                                          &timeline_frame_listener_iface,
+                                          NULL);
+  g_object_add_weak_pointer (G_OBJECT (frame_clock1), (gpointer *) &frame_clock1);
+  frame_clock2 = clutter_frame_clock_new (refresh_rate,
+                                          &timeline_frame_listener_iface,
+                                          NULL);
+  g_object_add_weak_pointer (G_OBJECT (frame_clock2), (gpointer *) &frame_clock2);
+
+  timeline = g_object_new (CLUTTER_TYPE_TIMELINE,
+                           "duration", 1000,
+                           "frame-clock", frame_clock1,
+                           NULL);
+  g_object_add_weak_pointer (G_OBJECT (timeline), (gpointer *) &timeline);
+
+  clutter_timeline_add_marker_at_time (timeline, "switch", 500);
+
+  frame_counter = 0;
+
+  g_signal_connect (timeline, "marker-reached::switch",
+                    G_CALLBACK (on_switch_reached),
+                    frame_clock2);
+  g_signal_connect (timeline, "new-frame",
+                    G_CALLBACK (on_timeline_new_frame),
+                    &frame_counter);
+  g_signal_connect (timeline, "completed",
+                    G_CALLBACK (on_timeline_completed),
+                    main_loop);
+
+  clutter_timeline_start (timeline);
+
+  before_us = g_get_monotonic_time ();
+
+  g_main_loop_run (main_loop);
+
+  after_us = g_get_monotonic_time ();
+
+  g_assert_cmpint (after_us - before_us,
+                   >=,
+                   ms2us (clutter_timeline_get_duration (timeline)));
+
+  g_assert (clutter_timeline_get_frame_clock (timeline) == frame_clock2);
+
+  /* The duration is 1s, with a 60hz clock, and we switch after 0.5s. To verify
+   * we continued to get frames, check that we have a bit more than half of the
+   * frames accounted for.
+   */
+  g_assert_cmpint (frame_counter, >, 35);
+
+  g_main_loop_unref (main_loop);
+  g_object_unref (timeline);
+  g_assert_null (timeline);
+  clutter_frame_clock_destroy (frame_clock1);
+  g_assert_null (frame_clock1);
+  clutter_frame_clock_destroy (frame_clock2);
+  g_assert_null (frame_clock2);
+}
+
+CLUTTER_TEST_SUITE (
+  CLUTTER_TEST_UNIT ("/frame-clock/timeline/basic", frame_clock_timeline_basic)
+  CLUTTER_TEST_UNIT ("/frame-clock/timeline/switch", frame_clock_timeline_switch)
+)
diff --git a/src/tests/clutter/conform/frame-clock.c b/src/tests/clutter/conform/frame-clock.c
new file mode 100644
index 0000000000000000000000000000000000000000..62a4176722b19add8900ea94bd63253f826f562f
--- /dev/null
+++ b/src/tests/clutter/conform/frame-clock.c
@@ -0,0 +1,760 @@
+#include "clutter/clutter.h"
+#include "tests/clutter-test-utils.h"
+
+static const float refresh_rate = 60.0;
+static const int64_t refresh_interval_us = (int64_t) (0.5 + G_USEC_PER_SEC /
+                                                      refresh_rate);
+
+static int64_t test_frame_count;
+static int64_t expected_frame_count;
+
+typedef struct _FakeHwClock
+{
+  GSource source;
+
+  ClutterFrameClock *frame_clock;
+
+  int64_t next_presentation_time_us;
+  gboolean has_pending_present;
+} FakeHwClock;
+
+typedef struct _FrameClockTest
+{
+  FakeHwClock *fake_hw_clock;
+
+  GMainLoop *main_loop;
+} FrameClockTest;
+
+static void
+init_frame_info (ClutterFrameInfo *frame_info,
+                 int64_t           presentation_time_us)
+{
+  *frame_info = (ClutterFrameInfo) {
+    .presentation_time = presentation_time_us,
+    .refresh_rate = refresh_rate,
+  };
+}
+
+static gboolean
+fake_hw_clock_source_dispatch (GSource     *source,
+                               GSourceFunc  callback,
+                               gpointer     user_data)
+{
+  FakeHwClock *fake_hw_clock = (FakeHwClock *) source;
+  ClutterFrameClock *frame_clock = fake_hw_clock->frame_clock;
+
+  if (fake_hw_clock->has_pending_present)
+    {
+      ClutterFrameInfo frame_info;
+
+      fake_hw_clock->has_pending_present = FALSE;
+      init_frame_info (&frame_info, g_source_get_time (source));
+      clutter_frame_clock_notify_presented (frame_clock, &frame_info);
+      if (callback)
+        callback (user_data);
+    }
+
+  fake_hw_clock->next_presentation_time_us += refresh_interval_us;
+  g_source_set_ready_time (source, fake_hw_clock->next_presentation_time_us);
+
+  return G_SOURCE_CONTINUE;
+}
+
+static GSourceFuncs fake_hw_clock_source_funcs = {
+  NULL,
+  NULL,
+  fake_hw_clock_source_dispatch,
+  NULL
+};
+
+static FakeHwClock *
+fake_hw_clock_new (ClutterFrameClock *frame_clock,
+                   GSourceFunc        callback,
+                   gpointer           user_data)
+{
+  GSource *source;
+  FakeHwClock *fake_hw_clock;
+
+  source = g_source_new (&fake_hw_clock_source_funcs, sizeof (FakeHwClock));
+  fake_hw_clock = (FakeHwClock *) source;
+  fake_hw_clock->frame_clock = frame_clock;
+
+  fake_hw_clock->next_presentation_time_us =
+    g_get_monotonic_time () + refresh_interval_us;
+  g_source_set_ready_time (source, fake_hw_clock->next_presentation_time_us);
+  g_source_set_callback (source, callback, user_data, NULL);
+
+  return fake_hw_clock;
+}
+
+static ClutterFrameResult
+frame_clock_frame (ClutterFrameClock *frame_clock,
+                   int64_t            frame_count,
+                   int64_t            time_us,
+                   gpointer           user_data)
+{
+  FrameClockTest *test = user_data;
+  GMainLoop *main_loop = test->main_loop;
+
+  g_assert_cmpint (frame_count, ==, expected_frame_count);
+
+  expected_frame_count++;
+
+  if (test_frame_count == 0)
+    {
+      g_main_loop_quit (main_loop);
+      return CLUTTER_FRAME_RESULT_IDLE;
+    }
+  else
+    {
+      test->fake_hw_clock->has_pending_present = TRUE;
+    }
+
+  test_frame_count--;
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface frame_listener_iface = {
+  .frame = frame_clock_frame,
+};
+
+static gboolean
+schedule_update_hw_callback (gpointer user_data)
+{
+  ClutterFrameClock *frame_clock = user_data;
+
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  return G_SOURCE_CONTINUE;
+}
+
+static void
+frame_clock_schedule_update (void)
+{
+  FrameClockTest test;
+  ClutterFrameClock *frame_clock;
+  int64_t before_us;
+  int64_t after_us;
+  GSource *source;
+  FakeHwClock *fake_hw_clock;
+
+  test_frame_count = 10;
+  expected_frame_count = 0;
+
+  test.main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &frame_listener_iface,
+                                         &test);
+
+  fake_hw_clock = fake_hw_clock_new (frame_clock,
+                                     schedule_update_hw_callback,
+                                     frame_clock);
+  source = &fake_hw_clock->source;
+  g_source_attach (source, NULL);
+
+  test.fake_hw_clock = fake_hw_clock;
+
+  before_us = g_get_monotonic_time ();
+
+  clutter_frame_clock_schedule_update (frame_clock);
+  g_main_loop_run (test.main_loop);
+
+  after_us = g_get_monotonic_time ();
+
+  g_assert_cmpint (after_us - before_us, >, 10 * refresh_interval_us);
+
+  g_main_loop_unref (test.main_loop);
+
+  clutter_frame_clock_destroy (frame_clock);
+  g_source_destroy (source);
+  g_source_unref (source);
+}
+
+static gboolean
+schedule_update_idle (gpointer user_data)
+{
+  ClutterFrameClock *frame_clock = user_data;
+
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  return G_SOURCE_REMOVE;
+}
+
+static ClutterFrameResult
+immediate_frame_clock_frame (ClutterFrameClock *frame_clock,
+                             int64_t            frame_count,
+                             int64_t            time_us,
+                             gpointer           user_data)
+{
+  GMainLoop *main_loop = user_data;
+  ClutterFrameInfo frame_info;
+
+  g_assert_cmpint (frame_count, ==, expected_frame_count);
+
+  expected_frame_count++;
+
+  if (test_frame_count == 0)
+    {
+      g_main_loop_quit (main_loop);
+      return CLUTTER_FRAME_RESULT_IDLE;
+    }
+
+  test_frame_count--;
+
+  init_frame_info (&frame_info, g_get_monotonic_time ());
+  clutter_frame_clock_notify_presented (frame_clock, &frame_info);
+  g_idle_add (schedule_update_idle, frame_clock);
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface immediate_frame_listener_iface = {
+  .frame = immediate_frame_clock_frame,
+};
+
+static void
+frame_clock_immediate_present (void)
+{
+  GMainLoop *main_loop;
+  ClutterFrameClock *frame_clock;
+  int64_t before_us;
+  int64_t after_us;
+
+  test_frame_count = 10;
+  expected_frame_count = 0;
+
+  main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &immediate_frame_listener_iface,
+                                         main_loop);
+
+  before_us = g_get_monotonic_time ();
+
+  clutter_frame_clock_schedule_update (frame_clock);
+  g_main_loop_run (main_loop);
+
+  after_us = g_get_monotonic_time ();
+
+  /* The initial frame will only be delayed by 2 ms, so we are checking one
+   * less.
+   */
+  g_assert_cmpint (after_us - before_us, >, 9 * refresh_interval_us);
+
+  g_main_loop_unref (main_loop);
+  clutter_frame_clock_destroy (frame_clock);
+}
+
+static gboolean
+schedule_update_timeout (gpointer user_data)
+{
+  ClutterFrameClock *frame_clock = user_data;
+
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  return G_SOURCE_REMOVE;
+}
+
+static ClutterFrameResult
+delayed_damage_frame_clock_frame (ClutterFrameClock *frame_clock,
+                                  int64_t            frame_count,
+                                  int64_t            time_us,
+                                  gpointer           user_data)
+{
+  FrameClockTest *test = user_data;
+  GMainLoop *main_loop = test->main_loop;
+
+  g_assert_cmpint (frame_count, ==, expected_frame_count);
+
+  expected_frame_count++;
+
+  if (test_frame_count == 0)
+    {
+      g_main_loop_quit (main_loop);
+      return CLUTTER_FRAME_RESULT_IDLE;
+    }
+  else
+    {
+      test->fake_hw_clock->has_pending_present = TRUE;
+    }
+
+  test_frame_count--;
+
+  g_timeout_add (100, schedule_update_timeout, frame_clock);
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface delayed_damage_frame_listener_iface = {
+  .frame = delayed_damage_frame_clock_frame,
+};
+
+static void
+frame_clock_delayed_damage (void)
+{
+  FrameClockTest test;
+  ClutterFrameClock *frame_clock;
+  int64_t before_us;
+  int64_t after_us;
+  FakeHwClock *fake_hw_clock;
+  GSource *source;
+
+  test_frame_count = 2;
+  expected_frame_count = 0;
+
+  test.main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &delayed_damage_frame_listener_iface,
+                                         &test);
+
+  fake_hw_clock = fake_hw_clock_new (frame_clock, NULL, NULL);
+  source = &fake_hw_clock->source;
+  g_source_attach (source, NULL);
+
+  test.fake_hw_clock = fake_hw_clock;
+
+  before_us = g_get_monotonic_time ();
+
+  clutter_frame_clock_schedule_update (frame_clock);
+  g_main_loop_run (test.main_loop);
+
+  after_us = g_get_monotonic_time ();
+
+  g_assert_cmpint (after_us - before_us, >, 100000 + refresh_interval_us);
+
+  g_main_loop_unref (test.main_loop);
+  clutter_frame_clock_destroy (frame_clock);
+  g_source_destroy (source);
+  g_source_unref (source);
+}
+
+static ClutterFrameResult
+no_damage_frame_clock_frame (ClutterFrameClock *frame_clock,
+                             int64_t            frame_count,
+                             int64_t            time_us,
+                             gpointer           user_data)
+{
+  g_assert_not_reached ();
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface no_damage_frame_listener_iface = {
+  .frame = no_damage_frame_clock_frame,
+};
+
+static gboolean
+quit_main_loop_idle (gpointer user_data)
+{
+  GMainLoop *main_loop = user_data;
+
+  g_main_loop_quit (main_loop);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+frame_clock_no_damage (void)
+{
+  GMainLoop *main_loop;
+  ClutterFrameClock *frame_clock;
+
+  test_frame_count = 10;
+  expected_frame_count = 0;
+
+  main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &no_damage_frame_listener_iface,
+                                         NULL);
+
+  g_timeout_add (100, quit_main_loop_idle, main_loop);
+
+  g_main_loop_run (main_loop);
+
+  g_main_loop_unref (main_loop);
+  clutter_frame_clock_destroy (frame_clock);
+}
+
+typedef struct _UpdateNowFrameClockTest
+{
+  FrameClockTest base;
+  guint idle_source_id;
+} UpdateNowFrameClockTest;
+
+static ClutterFrameResult
+update_now_frame_clock_frame (ClutterFrameClock *frame_clock,
+                              int64_t            frame_count,
+                              int64_t            time_us,
+                              gpointer           user_data)
+{
+  UpdateNowFrameClockTest *test = user_data;
+  GMainLoop *main_loop = test->base.main_loop;
+
+  g_assert_cmpint (frame_count, ==, expected_frame_count);
+
+  expected_frame_count++;
+
+  g_clear_handle_id (&test->idle_source_id, g_source_remove);
+
+  if (test_frame_count == 0)
+    {
+      g_main_loop_quit (main_loop);
+      return CLUTTER_FRAME_RESULT_IDLE;
+    }
+  else
+    {
+      test->base.fake_hw_clock->has_pending_present = TRUE;
+    }
+
+  test_frame_count--;
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface update_now_frame_listener_iface = {
+  .frame = update_now_frame_clock_frame,
+};
+
+static gboolean
+assert_not_reached_idle (gpointer user_data)
+{
+  g_assert_not_reached ();
+  return G_SOURCE_REMOVE;
+}
+
+static gboolean
+schedule_update_now_hw_callback (gpointer user_data)
+{
+  UpdateNowFrameClockTest *test = user_data;
+  ClutterFrameClock *frame_clock = test->base.fake_hw_clock->frame_clock;
+
+  clutter_frame_clock_schedule_update_now (frame_clock);
+  g_assert (!test->idle_source_id);
+  test->idle_source_id = g_idle_add (assert_not_reached_idle, NULL);
+
+  return G_SOURCE_CONTINUE;
+}
+
+static void
+frame_clock_schedule_update_now (void)
+{
+  UpdateNowFrameClockTest test = { 0 };
+  ClutterFrameClock *frame_clock;
+  int64_t before_us;
+  int64_t after_us;
+  GSource *source;
+  FakeHwClock *fake_hw_clock;
+
+  test_frame_count = 10;
+  expected_frame_count = 0;
+
+  test.base.main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &update_now_frame_listener_iface,
+                                         &test);
+
+  fake_hw_clock = fake_hw_clock_new (frame_clock,
+                                     schedule_update_now_hw_callback,
+                                     &test);
+  source = &fake_hw_clock->source;
+  g_source_attach (source, NULL);
+
+  test.base.fake_hw_clock = fake_hw_clock;
+
+  before_us = g_get_monotonic_time ();
+
+  clutter_frame_clock_schedule_update (frame_clock);
+  g_main_loop_run (test.base.main_loop);
+
+  after_us = g_get_monotonic_time ();
+
+  g_assert_cmpint (after_us - before_us, >, 10 * refresh_interval_us);
+
+  g_main_loop_unref (test.base.main_loop);
+
+  clutter_frame_clock_destroy (frame_clock);
+  g_source_destroy (source);
+  g_source_unref (source);
+}
+
+static void
+before_frame_frame_clock_before_frame (ClutterFrameClock *frame_clock,
+                                       int64_t            frame_count,
+                                       gpointer           user_data)
+{
+  int64_t *expected_frame_count = user_data;
+
+  g_assert_cmpint (*expected_frame_count, ==, frame_count);
+}
+
+static ClutterFrameResult
+before_frame_frame_clock_frame (ClutterFrameClock *frame_clock,
+                                int64_t            frame_count,
+                                int64_t            time_us,
+                                gpointer           user_data)
+{
+  int64_t *expected_frame_count = user_data;
+  ClutterFrameInfo frame_info;
+
+  g_assert_cmpint (*expected_frame_count, ==, frame_count);
+
+  (*expected_frame_count)++;
+
+  init_frame_info (&frame_info, g_get_monotonic_time ());
+  clutter_frame_clock_notify_presented (frame_clock, &frame_info);
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface before_frame_frame_listener_iface = {
+  .before_frame = before_frame_frame_clock_before_frame,
+  .frame = before_frame_frame_clock_frame,
+};
+
+static gboolean
+quit_main_loop_timeout (gpointer user_data)
+{
+  GMainLoop *main_loop = user_data;
+
+  g_main_loop_quit (main_loop);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+frame_clock_before_frame (void)
+{
+  GMainLoop *main_loop;
+  ClutterFrameClock *frame_clock;
+
+  expected_frame_count = 0;
+
+  main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &before_frame_frame_listener_iface,
+                                         &expected_frame_count);
+
+  clutter_frame_clock_schedule_update (frame_clock);
+  g_timeout_add (100, quit_main_loop_timeout, main_loop);
+  g_main_loop_run (main_loop);
+
+  /* We should have at least processed a couple of frames within 100 ms. */
+  g_assert_cmpint (expected_frame_count, >, 2);
+
+  g_main_loop_unref (main_loop);
+  clutter_frame_clock_destroy (frame_clock);
+}
+
+typedef struct _InhibitTest
+{
+  GMainLoop *main_loop;
+  ClutterFrameClock *frame_clock;
+
+  gboolean frame_count;
+  gboolean pending_inhibit;
+  gboolean pending_quit;
+} InhibitTest;
+
+static ClutterFrameResult
+inhibit_frame_clock_frame (ClutterFrameClock *frame_clock,
+                           int64_t            frame_count,
+                           int64_t            time_us,
+                           gpointer           user_data)
+{
+  InhibitTest *test = user_data;
+  ClutterFrameInfo frame_info;
+
+  g_assert_cmpint (frame_count, ==, test->frame_count);
+
+  test->frame_count++;
+
+  init_frame_info (&frame_info, g_get_monotonic_time ());
+  clutter_frame_clock_notify_presented (frame_clock, &frame_info);
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  if (test->pending_inhibit)
+    {
+      test->pending_inhibit = FALSE;
+      clutter_frame_clock_inhibit (frame_clock);
+    }
+
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  if (test->pending_quit)
+    g_main_loop_quit (test->main_loop);
+
+  return CLUTTER_FRAME_RESULT_PENDING_PRESENTED;
+}
+
+static const ClutterFrameListenerIface inhibit_frame_listener_iface = {
+  .frame = inhibit_frame_clock_frame,
+};
+
+static gboolean
+uninhibit_timeout (gpointer user_data)
+{
+  InhibitTest *test = user_data;
+
+  g_assert_cmpint (test->frame_count, ==, 1);
+
+  clutter_frame_clock_uninhibit (test->frame_clock);
+  test->pending_quit = TRUE;
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+frame_clock_inhibit (void)
+{
+  InhibitTest test = { 0 };
+
+  expected_frame_count = 0;
+
+  test.main_loop = g_main_loop_new (NULL, FALSE);
+  test.frame_clock = clutter_frame_clock_new (refresh_rate,
+                                              &inhibit_frame_listener_iface,
+                                              &test);
+
+  test.pending_inhibit = TRUE;
+
+  clutter_frame_clock_schedule_update (test.frame_clock);
+  g_timeout_add (100, uninhibit_timeout, &test);
+  g_main_loop_run (test.main_loop);
+
+  g_assert_cmpint (test.frame_count, ==, 2);
+
+  g_main_loop_unref (test.main_loop);
+  clutter_frame_clock_destroy (test.frame_clock);
+}
+
+typedef struct _RescheduleOnIdleFrameClockTest
+{
+  FrameClockTest base;
+} RescheduleOnIdleFrameClockTest;
+
+static ClutterFrameResult
+reschedule_on_idle_clock_frame (ClutterFrameClock *frame_clock,
+                                int64_t            frame_count,
+                                int64_t            time_us,
+                                gpointer           user_data)
+{
+  RescheduleOnIdleFrameClockTest *test = user_data;
+  GMainLoop *main_loop = test->base.main_loop;
+
+  g_assert_cmpint (frame_count, ==, expected_frame_count);
+
+  expected_frame_count++;
+
+  if (test_frame_count == 0)
+    {
+      g_main_loop_quit (main_loop);
+      return CLUTTER_FRAME_RESULT_IDLE;
+    }
+
+  test_frame_count--;
+
+  clutter_frame_clock_schedule_update (frame_clock);
+
+  return CLUTTER_FRAME_RESULT_IDLE;
+}
+
+static const ClutterFrameListenerIface reschedule_on_idle_listener_iface = {
+  .frame = reschedule_on_idle_clock_frame,
+};
+
+static void
+frame_clock_reschedule_on_idle (void)
+{
+  RescheduleOnIdleFrameClockTest test;
+  ClutterFrameClock *frame_clock;
+  FakeHwClock *fake_hw_clock;
+  GSource *source;
+
+  test_frame_count = 10;
+  expected_frame_count = 0;
+
+  test.base.main_loop = g_main_loop_new (NULL, FALSE);
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &reschedule_on_idle_listener_iface,
+                                         &test);
+  fake_hw_clock = fake_hw_clock_new (frame_clock, NULL, NULL);
+  source = &fake_hw_clock->source;
+  g_source_attach (source, NULL);
+  test.base.fake_hw_clock = fake_hw_clock;
+
+  clutter_frame_clock_schedule_update (frame_clock);
+  g_main_loop_run (test.base.main_loop);
+
+  g_main_loop_unref (test.base.main_loop);
+  clutter_frame_clock_destroy (frame_clock);
+}
+
+static const ClutterFrameListenerIface dummy_frame_listener_iface = {
+  .frame = NULL,
+};
+
+static void
+on_destroy (ClutterFrameClock *frame_clock,
+            gboolean          *destroy_signalled)
+{
+  g_assert_false (*destroy_signalled);
+  *destroy_signalled = TRUE;
+}
+
+static void
+frame_clock_destroy_signal (void)
+{
+  ClutterFrameClock *frame_clock;
+  ClutterFrameClock *frame_clock_backup;
+  gboolean destroy_signalled;
+
+  /* Test that the destroy signal is emitted when removing last reference. */
+
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &dummy_frame_listener_iface,
+                                         NULL);
+
+  destroy_signalled = FALSE;
+  g_signal_connect (frame_clock, "destroy",
+                    G_CALLBACK (on_destroy),
+                    &destroy_signalled);
+  g_object_add_weak_pointer (G_OBJECT (frame_clock), (gpointer *) &frame_clock);
+
+  g_object_unref (frame_clock);
+  g_assert_true (destroy_signalled);
+  g_assert_null (frame_clock);
+
+  /* Test that destroy signal is emitted when destroying with references still
+   * left.
+   */
+
+  frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         &dummy_frame_listener_iface,
+                                         NULL);
+  frame_clock_backup = frame_clock;
+
+  destroy_signalled = FALSE;
+  g_signal_connect (frame_clock, "destroy",
+                    G_CALLBACK (on_destroy),
+                    &destroy_signalled);
+  g_object_add_weak_pointer (G_OBJECT (frame_clock), (gpointer *) &frame_clock);
+  g_object_ref (frame_clock);
+
+  clutter_frame_clock_destroy (frame_clock);
+  g_assert_true (destroy_signalled);
+  g_assert_null (frame_clock);
+  g_object_unref (frame_clock_backup);
+}
+
+CLUTTER_TEST_SUITE (
+  CLUTTER_TEST_UNIT ("/frame-clock/schedule-update", frame_clock_schedule_update)
+  CLUTTER_TEST_UNIT ("/frame-clock/immediate-present", frame_clock_immediate_present)
+  CLUTTER_TEST_UNIT ("/frame-clock/delayed-damage", frame_clock_delayed_damage)
+  CLUTTER_TEST_UNIT ("/frame-clock/no-damage", frame_clock_no_damage)
+  CLUTTER_TEST_UNIT ("/frame-clock/schedule-update-now", frame_clock_schedule_update_now)
+  CLUTTER_TEST_UNIT ("/frame-clock/before-frame", frame_clock_before_frame)
+  CLUTTER_TEST_UNIT ("/frame-clock/inhibit", frame_clock_inhibit)
+  CLUTTER_TEST_UNIT ("/frame-clock/reschedule-on-idle", frame_clock_reschedule_on_idle)
+  CLUTTER_TEST_UNIT ("/frame-clock/destroy-signal", frame_clock_destroy_signal)
+)
diff --git a/src/tests/clutter/conform/meson.build b/src/tests/clutter/conform/meson.build
index 81b6922f0f4679c2d980d6c9a0a737b7471814fe..9758598b90a2ed97de6cb5a289335727df1e759b 100644
--- a/src/tests/clutter/conform/meson.build
+++ b/src/tests/clutter/conform/meson.build
@@ -31,6 +31,8 @@ clutter_conform_tests_classes_tests = [
 clutter_conform_tests_general_tests = [
   'binding-pool',
   'color',
+  'frame-clock',
+  'frame-clock-timeline',
   'interval',
   'script-parser',
   'timeline',
diff --git a/src/tests/clutter/conform/scripts/test-script-timeline-markers.json b/src/tests/clutter/conform/scripts/test-script-timeline-markers.json
index f5fff5c42cf79fa8738afc55151299c69787bc10..e26ba5f01581772e98c412c451e74a4cbff59302 100644
--- a/src/tests/clutter/conform/scripts/test-script-timeline-markers.json
+++ b/src/tests/clutter/conform/scripts/test-script-timeline-markers.json
@@ -1,12 +1,16 @@
-{
-  "id" : "timeline0",
-  "type" : "ClutterTimeline",
-  "duration" : 1000,
+[
+  { "id" : "actor0", "type" : "ClutterActor" },
+  {
+    "id" : "timeline0",
+    "type" : "ClutterTimeline",
+    "duration" : 1000,
+    "actor" : "actor0",
 
-  "markers" : [
-    { "name" : "marker0", "time" : 250 },
-    { "name" : "marker1", "time" : 500 },
-    { "name" : "marker2", "time" : 750 },
-    { "name" : "marker3", "progress" : 0.5 }
-  ]
-}
+    "markers" : [
+      { "name" : "marker0", "time" : 250 },
+      { "name" : "marker1", "time" : 500 },
+      { "name" : "marker2", "time" : 750 },
+      { "name" : "marker3", "progress" : 0.5 }
+    ]
+  }
+]
diff --git a/src/tests/clutter/conform/timeline-interpolate.c b/src/tests/clutter/conform/timeline-interpolate.c
index db17b678489ebaf3b2768b67567ab33839e9da58..d8a9dd8183d4ca4cf15f15fa6c2a698c6c3d3909 100644
--- a/src/tests/clutter/conform/timeline-interpolate.c
+++ b/src/tests/clutter/conform/timeline-interpolate.c
@@ -139,7 +139,7 @@ timeline_interpolation (void)
   stage = clutter_test_get_stage ();
 
   state.timeline = 
-    clutter_timeline_new (TEST_TIMELINE_DURATION);
+    clutter_timeline_new_for_actor (stage, TEST_TIMELINE_DURATION);
   clutter_timeline_set_repeat_count (state.timeline, -1);
   g_signal_connect (G_OBJECT(state.timeline),
 		    "new-frame",
diff --git a/src/tests/clutter/conform/timeline-progress.c b/src/tests/clutter/conform/timeline-progress.c
index 20a71f2bcfe549ee4f35be83b602ba76472a61c5..fc4ce84211370a5333dad85e20a0e8f7445142df 100644
--- a/src/tests/clutter/conform/timeline-progress.c
+++ b/src/tests/clutter/conform/timeline-progress.c
@@ -7,9 +7,10 @@
 static void
 timeline_progress_step (void)
 {
+  ClutterActor *stage = clutter_test_get_stage ();
   ClutterTimeline *timeline;
 
-  timeline = clutter_timeline_new (1000);
+  timeline = clutter_timeline_new_for_actor (stage, 1000);
 
   if (!g_test_quiet ())
     g_print ("mode: step(3, end)\n");
@@ -90,9 +91,10 @@ timeline_progress_step (void)
 static void
 timeline_progress_mode (void)
 {
+  ClutterActor *stage = clutter_test_get_stage ();
   ClutterTimeline *timeline;
 
-  timeline = clutter_timeline_new (1000);
+  timeline = clutter_timeline_new_for_actor (stage, 1000);
 
   g_assert (clutter_timeline_get_progress_mode (timeline) == CLUTTER_LINEAR);
   g_assert_cmpfloat (clutter_timeline_get_progress (timeline), ==, 0.0);
diff --git a/src/tests/clutter/conform/timeline-rewind.c b/src/tests/clutter/conform/timeline-rewind.c
index 9adc198b496ee8513c638be4304ef9fccc118e35..e669e9e8d52d48709f3b761bdd9de6d10580f65b 100644
--- a/src/tests/clutter/conform/timeline-rewind.c
+++ b/src/tests/clutter/conform/timeline-rewind.c
@@ -76,7 +76,7 @@ timeline_rewind (void)
   stage = clutter_test_get_stage ();
 
   state.timeline = 
-    clutter_timeline_new (TEST_TIMELINE_DURATION);
+    clutter_timeline_new_for_actor (stage, TEST_TIMELINE_DURATION);
   g_signal_connect (G_OBJECT(state.timeline),
                     "new-frame",
                     G_CALLBACK(new_frame_cb),
diff --git a/src/tests/clutter/conform/timeline.c b/src/tests/clutter/conform/timeline.c
index 133cbcaca4e24f75006513962c06bca5350df09d..6cab2b3e3d7fcfea969172da5e0b49f1470bb0c3 100644
--- a/src/tests/clutter/conform/timeline.c
+++ b/src/tests/clutter/conform/timeline.c
@@ -198,7 +198,7 @@ timeline_base (void)
   stage = clutter_test_get_stage ();
 
   timeline_data_init (&data_1, 1);
-  timeline_1 = clutter_timeline_new (FRAME_COUNT * 1000 / FPS);
+  timeline_1 = clutter_timeline_new_for_actor (stage, FRAME_COUNT * 1000 / FPS);
   clutter_timeline_add_marker_at_time (timeline_1, "start-marker",
                                        0 * 1000 / FPS);
   clutter_timeline_add_marker_at_time (timeline_1, "foo", 5 * 1000 / FPS);
@@ -215,7 +215,7 @@ timeline_base (void)
   g_strfreev (markers);
 
   timeline_data_init (&data_2, 2);
-  timeline_2 = clutter_timeline_new (FRAME_COUNT * 1000 / FPS);
+  timeline_2 = clutter_timeline_new_for_actor (stage, FRAME_COUNT * 1000 / FPS);
   clutter_timeline_add_marker_at_time (timeline_2, "bar", 2 * 1000 / FPS);
   markers = clutter_timeline_list_markers (timeline_2, -1, &n_markers);
   g_assert (markers != NULL);
@@ -224,7 +224,7 @@ timeline_base (void)
   g_strfreev (markers);
 
   timeline_data_init (&data_3, 3);
-  timeline_3 = clutter_timeline_new (FRAME_COUNT * 1000 / FPS);
+  timeline_3 = clutter_timeline_new_for_actor (stage, FRAME_COUNT * 1000 / FPS);
   clutter_timeline_set_direction (timeline_3, CLUTTER_TIMELINE_BACKWARD);
   clutter_timeline_add_marker_at_time (timeline_3, "start-marker",
                                        FRAME_COUNT * 1000 / FPS);
diff --git a/src/tests/clutter/interactive/test-actors.c b/src/tests/clutter/interactive/test-actors.c
index b1127ffff91f05545c994d2d1c3d2c7aa6551ce9..f654d5b10edc37cd5c8c3068675f040c19975c4b 100644
--- a/src/tests/clutter/interactive/test-actors.c
+++ b/src/tests/clutter/interactive/test-actors.c
@@ -184,7 +184,7 @@ test_actors_main (int argc, char *argv[])
   clutter_stage_set_title (CLUTTER_STAGE (oh->stage), "Actors");
 
   /* Create a timeline to manage animation */
-  oh->timeline = clutter_timeline_new (6000);
+  oh->timeline = clutter_timeline_new_for_actor (oh->stage, 6000);
   clutter_timeline_set_repeat_count (oh->timeline, -1);
 
   /* fire a callback for frame change */
diff --git a/src/tests/clutter/interactive/test-cairo-flowers.c b/src/tests/clutter/interactive/test-cairo-flowers.c
index 6ee3a4e845f240581b2d4b02d26efbb09f0f1acf..62393d1e2ffd5b5b1f7ee483efaf40d0d19555b1 100644
--- a/src/tests/clutter/interactive/test-cairo-flowers.c
+++ b/src/tests/clutter/interactive/test-cairo-flowers.c
@@ -209,12 +209,12 @@ test_cairo_flowers_main (int argc, char **argv)
   if (clutter_init (&argc, &argv) != CLUTTER_INIT_SUCCESS)
     return 1;
 
-  /* Create a timeline to manage animation */
-  timeline = clutter_timeline_new (6000);
-  clutter_timeline_set_repeat_count (timeline, -1);
-
   stage = clutter_stage_new ();
   clutter_stage_set_title (CLUTTER_STAGE (stage), "Cairo Flowers");
+
+  /* Create a timeline to manage animation */
+  timeline = clutter_timeline_new_for_actor (stage, 6000);
+  clutter_timeline_set_repeat_count (timeline, -1);
   g_signal_connect (stage, "destroy", G_CALLBACK (stop_and_quit), timeline);
 
   clutter_actor_set_background_color (stage, CLUTTER_COLOR_Black);
diff --git a/src/tests/clutter/interactive/test-cogl-multitexture.c b/src/tests/clutter/interactive/test-cogl-multitexture.c
index d2a1f94fe3ce4c4de7ac2916ffc9e83b11ca5353..00bd30f921010a7f5937e22bc986b3f7d3c46aee 100644
--- a/src/tests/clutter/interactive/test-cogl-multitexture.c
+++ b/src/tests/clutter/interactive/test-cogl-multitexture.c
@@ -212,7 +212,7 @@ test_cogl_multitexture_main (int argc, char *argv[])
   clutter_container_add_actor (CLUTTER_CONTAINER(stage),
 			       state->group);
 
-  state->timeline = clutter_timeline_new (2812);
+  state->timeline = clutter_timeline_new_for_actor (stage, 2812);
 
   g_signal_connect (state->timeline, "new-frame", G_CALLBACK (frame_cb), state);
 
diff --git a/src/tests/clutter/interactive/test-cogl-tex-polygon.c b/src/tests/clutter/interactive/test-cogl-tex-polygon.c
index e190eeefca2d22e56dd5e613e4f35ee29ace264f..5bd47a153b42c49ae9c5ad52307e180e0d2fda99 100644
--- a/src/tests/clutter/interactive/test-cogl-tex-polygon.c
+++ b/src/tests/clutter/interactive/test-cogl-tex-polygon.c
@@ -409,7 +409,7 @@ test_cogl_tex_polygon_main (int argc, char *argv[])
   clutter_container_add_actor (CLUTTER_CONTAINER (stage), coglbox);
 
   /* Timeline for animation */
-  timeline = clutter_timeline_new (6000);
+  timeline = clutter_timeline_new_for_actor (stage, 6000);
   clutter_timeline_set_repeat_count (timeline, -1);
   g_signal_connect (timeline, "new-frame", G_CALLBACK (frame_cb), coglbox);
   clutter_timeline_start (timeline);
diff --git a/src/tests/clutter/interactive/test-cogl-tex-tile.c b/src/tests/clutter/interactive/test-cogl-tex-tile.c
index 5fbd47af1f217dc78362aa041c7ec5e662fb5581..d012df6fcd6cc2e630db14aff8beaa711b216032 100644
--- a/src/tests/clutter/interactive/test-cogl-tex-tile.c
+++ b/src/tests/clutter/interactive/test-cogl-tex-tile.c
@@ -215,7 +215,7 @@ test_cogl_tex_tile_main (int argc, char *argv[])
   clutter_container_add_actor (CLUTTER_CONTAINER (stage), coglbox);
 
   /* Timeline for animation */
-  timeline = clutter_timeline_new (6000); /* 6 second duration */
+  timeline = clutter_timeline_new_for_actor (stage, 6000); /* 6 second duration */
   clutter_timeline_set_repeat_count (timeline, -1);
   g_signal_connect (timeline, "new-frame", G_CALLBACK (frame_cb), coglbox);
   clutter_timeline_start (timeline);
diff --git a/src/tests/clutter/interactive/test-layout.c b/src/tests/clutter/interactive/test-layout.c
index 5f697c90714a8a78bd6d3e21f115e2fd3a6f9edf..97ef4fad9ca95c200747262015f25c43b4d2365c 100644
--- a/src/tests/clutter/interactive/test-layout.c
+++ b/src/tests/clutter/interactive/test-layout.c
@@ -607,7 +607,7 @@ test_layout_main (int argc, char *argv[])
   clutter_stage_set_title (CLUTTER_STAGE (stage), "Layout");
   g_signal_connect (stage, "destroy", G_CALLBACK (clutter_main_quit), NULL);
 
-  main_timeline = clutter_timeline_new (2000);
+  main_timeline = clutter_timeline_new_for_actor (stage, 2000);
   clutter_timeline_set_repeat_count (main_timeline, -1);
   clutter_timeline_set_auto_reverse (main_timeline, TRUE);
   g_signal_connect (main_timeline, "new-frame",
diff --git a/src/tests/clutter/interactive/test-paint-wrapper.c b/src/tests/clutter/interactive/test-paint-wrapper.c
index 85e7147d5dad7dc074a77af85d86aa7a5db3f5bf..f66f794337f48791b22cf04e6cb8f64635b0e2d8 100644
--- a/src/tests/clutter/interactive/test-paint-wrapper.c
+++ b/src/tests/clutter/interactive/test-paint-wrapper.c
@@ -241,7 +241,7 @@ test_paint_wrapper_main (int argc, char *argv[])
   oh->stage = stage;
 
   /* Create a timeline to manage animation */
-  oh->timeline = clutter_timeline_new (6000);
+  oh->timeline = clutter_timeline_new_for_actor (oh->stage, 6000);
   clutter_timeline_set_repeat_count (oh->timeline, -1);
 
   /* fire a callback for frame change */
diff --git a/src/tests/clutter/interactive/test-shader-effects.c b/src/tests/clutter/interactive/test-shader-effects.c
index df546ad6601f116bb453013a09756d01312780dc..9c5db6a34d5055737e856daf2e3a18f4f3e301ad 100644
--- a/src/tests/clutter/interactive/test-shader-effects.c
+++ b/src/tests/clutter/interactive/test-shader-effects.c
@@ -21,15 +21,15 @@ test_shader_effects_main (int argc, char *argv[])
   if (clutter_init (&argc, &argv) != CLUTTER_INIT_SUCCESS)
     return 1;
 
-  /* Make a timeline */
-  timeline = clutter_timeline_new (7692);
-  clutter_timeline_set_repeat_count (timeline, -1);
-
   stage = clutter_stage_new ();
   clutter_stage_set_title (CLUTTER_STAGE (stage), "Rotations");
   clutter_actor_set_background_color (stage, CLUTTER_COLOR_Aluminium3);
   g_signal_connect (stage, "destroy", G_CALLBACK (clutter_main_quit), NULL);
 
+  /* Make a timeline */
+  timeline = clutter_timeline_new_for_actor (stage, 7692);
+  clutter_timeline_set_repeat_count (timeline, -1);
+
   /* Make a hand */
   file = g_build_filename (TESTS_DATADIR, "redhand.png", NULL);
   hand = clutter_test_utils_create_texture_from_file (file, NULL);
diff --git a/src/tests/stage-view-tests.c b/src/tests/stage-view-tests.c
index 76da1db45ed350e59210e5751058e138a4341da2..f0691be591bbd40c7de636622787d333f1c933fd 100644
--- a/src/tests/stage-view-tests.c
+++ b/src/tests/stage-view-tests.c
@@ -17,6 +17,8 @@
 
 #include "config.h"
 
+#include "clutter/clutter.h"
+#include "clutter/clutter-stage-view-private.h"
 #include "compositor/meta-plugin-manager.h"
 #include "core/main-private.h"
 #include "meta/main.h"
@@ -48,20 +50,6 @@ run_tests (gpointer data)
   return G_SOURCE_REMOVE;
 }
 
-static gboolean
-ignore_frame_counter_warning (const gchar    *log_domain,
-                              GLogLevelFlags  log_level,
-                              const gchar    *message,
-                              gpointer        user_data)
-{
-  if ((log_level & G_LOG_LEVEL_WARNING) &&
-      g_strcmp0 (log_domain, "mutter") == 0 &&
-      g_str_has_suffix (message, FRAME_WARNING))
-    return FALSE;
-
-  return TRUE;
-}
-
 static MonitorTestCaseSetup initial_test_case_setup = {
   .modes = {
     {
@@ -121,8 +109,9 @@ meta_test_stage_views_exist (void)
 }
 
 static void
-on_after_paint (ClutterStage *stage,
-                gboolean     *was_painted)
+on_after_paint (ClutterStage     *stage,
+                ClutterStageView *view,
+                gboolean         *was_painted)
 {
   *was_painted = TRUE;
 }
@@ -515,6 +504,312 @@ create_stage_view_test_setup (void)
                                     MONITOR_TEST_FLAG_NO_STORED);
 }
 
+static void
+assert_is_stage_view (ClutterStageView *stage_view,
+                      int               x,
+                      int               y,
+                      int               width,
+                      int               height)
+{
+  cairo_rectangle_int_t layout;
+
+  g_assert_nonnull (stage_view);
+  g_assert_true (CLUTTER_IS_STAGE_VIEW (stage_view));
+
+  clutter_stage_view_get_layout (stage_view, &layout);
+  g_assert_cmpint (layout.x, ==, x);
+  g_assert_cmpint (layout.y, ==, y);
+  g_assert_cmpint (layout.width, ==, width);
+  g_assert_cmpint (layout.height, ==, height);
+}
+
+static void
+meta_test_actor_stage_views_hot_plug (void)
+{
+  MetaBackend *backend = meta_get_backend ();
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaMonitorManagerTest *monitor_manager_test =
+    META_MONITOR_MANAGER_TEST (monitor_manager);
+  ClutterActor *stage = meta_backend_get_stage (backend);
+  ClutterActor *actor_1;
+  ClutterActor *actor_2;
+  GList *stage_views;
+  GList *prev_stage_views;
+  MonitorTestCaseSetup hotplug_test_case_setup = initial_test_case_setup;
+  MetaMonitorTestSetup *test_setup;
+
+  stage_views = clutter_stage_peek_stage_views (CLUTTER_STAGE (stage));
+  g_assert_cmpint (g_list_length (stage_views), ==, 2);
+  assert_is_stage_view (stage_views->data, 0, 0, 1024, 768);
+  assert_is_stage_view (stage_views->next->data, 1024, 0, 1024, 768);
+
+  actor_1 = clutter_actor_new ();
+  clutter_actor_set_size (actor_1, 100, 100);
+  clutter_actor_set_position (actor_1, 100, 100);
+  clutter_actor_add_child (stage, actor_1);
+
+  actor_2 = clutter_actor_new ();
+  clutter_actor_set_size (actor_2, 100, 100);
+  clutter_actor_set_position (actor_2, 1100, 100);
+  clutter_actor_add_child (stage, actor_2);
+
+  clutter_actor_show (stage);
+
+  wait_for_paint (stage);
+
+  is_on_stage_views (actor_1, 1, stage_views->data);
+  is_on_stage_views (actor_2, 1, stage_views->next->data);
+
+  test_setup = create_monitor_test_setup (&hotplug_test_case_setup,
+                                          MONITOR_TEST_FLAG_NO_STORED);
+  meta_monitor_manager_test_emulate_hotplug (monitor_manager_test, test_setup);
+
+  prev_stage_views = stage_views;
+  stage_views = clutter_stage_peek_stage_views (CLUTTER_STAGE (stage));
+
+  g_assert (stage_views != prev_stage_views);
+  g_assert_cmpint (g_list_length (stage_views), ==, 2);
+  g_assert (prev_stage_views->data != stage_views->data);
+  g_assert (prev_stage_views->next->data != stage_views->next->data);
+  assert_is_stage_view (stage_views->data, 0, 0, 1024, 768);
+  assert_is_stage_view (stage_views->next->data, 1024, 0, 1024, 768);
+
+  is_on_stage_views (actor_1, 0);
+  is_on_stage_views (actor_2, 0);
+
+  wait_for_paint (stage);
+
+  is_on_stage_views (actor_1, 1, stage_views->data);
+  is_on_stage_views (actor_2, 1, stage_views->next->data);
+
+  clutter_actor_destroy (actor_1);
+  clutter_actor_destroy (actor_2);
+}
+
+static void
+meta_test_actor_stage_views_frame_clock (void)
+{
+  MetaBackend *backend = meta_get_backend ();
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaMonitorManagerTest *monitor_manager_test =
+    META_MONITOR_MANAGER_TEST (monitor_manager);
+  ClutterActor *stage = meta_backend_get_stage (backend);
+  ClutterActor *actor_1;
+  ClutterActor *actor_2;
+  ClutterActor *actor_3;
+  GList *stage_views;
+  MonitorTestCaseSetup frame_clock_test_setup = initial_test_case_setup;
+  MetaMonitorTestSetup *test_setup;
+  ClutterFrameClock *frame_clock;
+
+  frame_clock_test_setup.modes[1].width = 1024;
+  frame_clock_test_setup.modes[1].height = 768;
+  frame_clock_test_setup.modes[1].refresh_rate = 30.0;
+  frame_clock_test_setup.n_modes = 2;
+  frame_clock_test_setup.outputs[1].modes[0] = 1;
+  frame_clock_test_setup.outputs[1].preferred_mode = 1;
+  test_setup = create_monitor_test_setup (&frame_clock_test_setup,
+                                          MONITOR_TEST_FLAG_NO_STORED);
+  meta_monitor_manager_test_emulate_hotplug (monitor_manager_test, test_setup);
+
+  stage_views = clutter_stage_peek_stage_views (CLUTTER_STAGE (stage));
+
+  g_assert_cmpfloat (clutter_stage_view_get_refresh_rate (stage_views->data),
+                     ==,
+                     60.0);
+  g_assert_cmpfloat (clutter_stage_view_get_refresh_rate (stage_views->next->data),
+                     ==,
+                     30.0);
+
+  actor_1 = clutter_actor_new ();
+  clutter_actor_set_size (actor_1, 100, 100);
+  clutter_actor_set_position (actor_1, 100, 100);
+  clutter_actor_add_child (stage, actor_1);
+
+  actor_2 = clutter_actor_new ();
+  clutter_actor_set_size (actor_2, 100, 100);
+  clutter_actor_set_position (actor_2, 1100, 100);
+  clutter_actor_add_child (stage, actor_2);
+
+  actor_3 = clutter_actor_new ();
+  clutter_actor_set_size (actor_3, 100, 100);
+  clutter_actor_set_position (actor_3, 1000, 400);
+  clutter_actor_add_child (stage, actor_3);
+
+  clutter_actor_show (stage);
+
+  wait_for_paint (stage);
+
+  is_on_stage_views (actor_1, 1, stage_views->data);
+  is_on_stage_views (actor_2, 1, stage_views->next->data);
+  is_on_stage_views (actor_3, 2,
+                     stage_views->data,
+                     stage_views->next->data);
+
+  frame_clock = clutter_actor_pick_frame_clock (actor_1);
+  g_assert_cmpfloat (clutter_frame_clock_get_refresh_rate (frame_clock),
+                     ==,
+                     60.0);
+  frame_clock = clutter_actor_pick_frame_clock (actor_2);
+  g_assert_cmpfloat (clutter_frame_clock_get_refresh_rate (frame_clock),
+                     ==,
+                     30.0);
+  frame_clock = clutter_actor_pick_frame_clock (actor_3);
+  g_assert_cmpfloat (clutter_frame_clock_get_refresh_rate (frame_clock),
+                     ==,
+                     60.0);
+
+  clutter_actor_destroy (actor_1);
+  clutter_actor_destroy (actor_2);
+  clutter_actor_destroy (actor_3);
+}
+
+typedef struct _TimelineTest
+{
+  GMainLoop *main_loop;
+  ClutterFrameClock *frame_clock_1;
+  ClutterFrameClock *frame_clock_2;
+  int phase;
+
+  int frame_counter[2];
+} TimelineTest;
+
+static void
+on_transition_stopped (ClutterTransition *transition,
+                       gboolean           is_finished,
+                       TimelineTest      *test)
+{
+  g_assert_true (is_finished);
+
+  g_assert_cmpint (test->phase, ==, 2);
+
+  test->phase = 3;
+
+  g_main_loop_quit (test->main_loop);
+}
+
+static void
+on_transition_new_frame (ClutterTransition *transition,
+                         int                elapsed_time_ms,
+                         TimelineTest      *test)
+{
+  ClutterTimeline *timeline = CLUTTER_TIMELINE (transition);
+
+  if (test->phase == 1)
+    {
+      g_assert (clutter_timeline_get_frame_clock (timeline) ==
+                test->frame_clock_1);
+      test->frame_counter[0]++;
+    }
+  else if (test->phase == 2)
+    {
+      g_assert (clutter_timeline_get_frame_clock (timeline) ==
+                test->frame_clock_2);
+      test->frame_counter[1]++;
+    }
+  else
+    {
+      g_assert_not_reached ();
+    }
+}
+
+static void
+on_transition_frame_clock_changed (ClutterTimeline    *timeline,
+                                   GParamSpec         *pspec,
+                                   TimelineTest       *test)
+{
+  ClutterFrameClock *frame_clock;
+
+  frame_clock = clutter_timeline_get_frame_clock (timeline);
+  g_assert (frame_clock == test->frame_clock_2);
+  g_assert_cmpint (test->phase, ==, 1);
+
+  test->phase = 2;
+}
+
+static void
+meta_test_actor_stage_views_timeline (void)
+{
+  TimelineTest test = { 0 };
+  MetaBackend *backend = meta_get_backend ();
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaMonitorManagerTest *monitor_manager_test =
+    META_MONITOR_MANAGER_TEST (monitor_manager);
+  ClutterActor *stage = meta_backend_get_stage (backend);
+  MonitorTestCaseSetup frame_clock_test_setup;
+  ClutterActor *actor;
+  GList *stage_views;
+  ClutterStageView *stage_view_1;
+  ClutterStageView *stage_view_2;
+  MetaMonitorTestSetup *test_setup;
+  ClutterTransition *transition;
+
+  frame_clock_test_setup = initial_test_case_setup;
+  frame_clock_test_setup.modes[1].width = 1024;
+  frame_clock_test_setup.modes[1].height = 768;
+  frame_clock_test_setup.modes[1].refresh_rate = 30.0;
+  frame_clock_test_setup.n_modes = 2;
+  frame_clock_test_setup.outputs[1].modes[0] = 1;
+  frame_clock_test_setup.outputs[1].preferred_mode = 1;
+  test_setup = create_monitor_test_setup (&frame_clock_test_setup,
+                                          MONITOR_TEST_FLAG_NO_STORED);
+  meta_monitor_manager_test_emulate_hotplug (monitor_manager_test, test_setup);
+
+  stage_views = clutter_stage_peek_stage_views (CLUTTER_STAGE (stage));
+  stage_view_1 = stage_views->data;
+  stage_view_2 = stage_views->next->data;
+  g_assert_nonnull (stage_view_1);
+  g_assert_nonnull (stage_view_2);
+  test.frame_clock_1 = clutter_stage_view_get_frame_clock (stage_view_1);
+  test.frame_clock_2 = clutter_stage_view_get_frame_clock (stage_view_2);
+  g_assert_nonnull (test.frame_clock_1);
+  g_assert_nonnull (test.frame_clock_2);
+
+  actor = clutter_actor_new ();
+  clutter_actor_set_size (actor, 100, 100);
+  clutter_actor_set_position (actor, 100, 100);
+  clutter_actor_add_child (stage, actor);
+
+  clutter_actor_show (stage);
+
+  wait_for_paint (stage);
+
+  is_on_stage_views (actor, 1, stage_views->data);
+
+  clutter_actor_set_easing_duration (actor, 1000);
+  clutter_actor_set_position (actor, 1200, 300);
+
+  transition = clutter_actor_get_transition (actor, "position");
+  g_assert_nonnull (transition);
+  g_assert (clutter_timeline_get_frame_clock (CLUTTER_TIMELINE (transition)) ==
+            test.frame_clock_1);
+
+  test.main_loop = g_main_loop_new (NULL, FALSE);
+  g_signal_connect (transition, "stopped",
+                    G_CALLBACK (on_transition_stopped),
+                    &test);
+  g_signal_connect (transition, "new-frame",
+                    G_CALLBACK (on_transition_new_frame),
+                    &test);
+  g_signal_connect (transition, "notify::frame-clock",
+                    G_CALLBACK (on_transition_frame_clock_changed),
+                    &test);
+
+  test.phase = 1;
+
+  g_main_loop_run (test.main_loop);
+
+  g_assert_cmpint (test.phase, ==, 3);
+  g_assert_cmpint (test.frame_counter[0], >, 0);
+  g_assert_cmpint (test.frame_counter[1], >, 0);
+
+  clutter_actor_destroy (actor);
+  g_main_loop_unref (test.main_loop);
+}
+
 static void
 init_tests (int argc, char **argv)
 {
@@ -530,6 +825,12 @@ init_tests (int argc, char **argv)
                    meta_test_actor_stage_views_reparent);
   g_test_add_func ("/stage-views/actor-stage-views-hide-parent",
                    meta_test_actor_stage_views_hide_parent);
+  g_test_add_func ("/stage-views/actor-stage-views-hot-plug",
+                   meta_test_actor_stage_views_hot_plug);
+  g_test_add_func ("/stage-views/actor-stage-views-frame-clock",
+                   meta_test_actor_stage_views_frame_clock);
+  g_test_add_func ("/stage-views/actor-stage-views-timeline",
+                   meta_test_actor_stage_views_timeline);
 }
 
 int
@@ -546,8 +847,6 @@ main (int argc, char *argv[])
   meta_init ();
   meta_register_with_session ();
 
-  g_test_log_set_fatal_handler (ignore_frame_counter_warning, NULL);
-
   g_idle_add (run_tests, NULL);
 
   return meta_run ();
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index e4b09cbfc711d4c62c23904324dc654220742ced..1feddef93f3038a1177359dba31acf7c70a265ae 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -194,8 +194,10 @@ meta_wayland_compositor_update (MetaWaylandCompositor *compositor,
     meta_wayland_seat_update (compositor->seat, event);
 }
 
-void
-meta_wayland_compositor_paint_finished (MetaWaylandCompositor *compositor)
+static void
+on_after_update (ClutterStage          *stage,
+                 ClutterStageView      *stage_view,
+                 MetaWaylandCompositor *compositor)
 {
   GList *l;
   int64_t now_us;
@@ -220,6 +222,10 @@ meta_wayland_compositor_paint_finished (MetaWaylandCompositor *compositor)
           meta_surface_actor_is_obscured (actor))
         continue;
 
+      if (!clutter_actor_is_effectively_on_stage_view (CLUTTER_ACTOR (actor),
+                                                       stage_view))
+        continue;
+
       actor_surface = META_WAYLAND_ACTOR_SURFACE (surface->role);
       meta_wayland_actor_surface_emit_frame_callbacks (actor_surface,
                                                        now_us / 1000);
@@ -397,9 +403,9 @@ meta_wayland_compositor_new (MetaBackend *backend)
 }
 
 void
-meta_wayland_compositor_setup (MetaWaylandCompositor *wayland_compositor)
+meta_wayland_compositor_setup (MetaWaylandCompositor *compositor)
 {
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  ClutterActor *stage = meta_backend_get_stage (compositor->backend);
   GSource *wayland_event_source;
 
   wayland_event_source = wayland_event_source_new (compositor->wayland_display);
@@ -413,6 +419,9 @@ meta_wayland_compositor_setup (MetaWaylandCompositor *wayland_compositor)
   g_source_set_priority (wayland_event_source, GDK_PRIORITY_EVENTS + 1);
   g_source_attach (wayland_event_source, NULL);
 
+  g_signal_connect (stage, "after-update",
+                    G_CALLBACK (on_after_update), compositor);
+
   if (!wl_global_create (compositor->wayland_display,
 			 &wl_compositor_interface,
 			 META_WL_COMPOSITOR_VERSION,
