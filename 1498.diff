diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index 114259e68ccbe7bcfa9bb42ad3b49ea2c281cf6a..e3f698b253d3bf912ff7132e61b27ebaa6083da0 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -858,7 +858,6 @@ struct _ClutterActorPrivate
   guint needs_y_expand              : 1;
   guint needs_paint_volume_update   : 1;
   guint had_effects_on_last_paint_volume_update : 1;
-  guint absolute_origin_changed     : 1;
   guint needs_update_stage_views    : 1;
   guint has_inverse_transform       : 1;
 };
@@ -2202,6 +2201,7 @@ unrealize_actor_after_children_cb (ClutterActor *self,
                                    int depth,
                                    void *user_data)
 {
+  ClutterActorPrivate *priv = self->priv;
   ClutterActor *stage = user_data;
 
   /* We want to unset the realized flag only _after_
@@ -2211,10 +2211,13 @@ unrealize_actor_after_children_cb (ClutterActor *self,
   g_object_notify_by_pspec (G_OBJECT (self), obj_props[PROP_REALIZED]);
 
   if (stage != NULL &&
-      self->priv->parent != NULL &&
-      self->priv->parent->flags & CLUTTER_ACTOR_NO_LAYOUT)
+      priv->parent != NULL &&
+      priv->parent->flags & CLUTTER_ACTOR_NO_LAYOUT)
     clutter_stage_dequeue_actor_relayout (CLUTTER_STAGE (stage), self);
 
+  if (priv->unmapped_paint_branch_counter == 0)
+    priv->allocation = (ClutterActorBox) CLUTTER_ACTOR_BOX_UNINITIALIZED;
+
   return CLUTTER_ACTOR_TRAVERSE_VISIT_CONTINUE;
 }
 
@@ -2608,11 +2611,6 @@ clutter_actor_set_allocation_internal (ClutterActor           *self,
   priv->needs_height_request = FALSE;
   priv->needs_allocation = FALSE;
 
-  priv->absolute_origin_changed |= x1_changed || y1_changed;
-
-  if (priv->absolute_origin_changed || x2_changed || y2_changed)
-    absolute_geometry_changed (self);
-
   if (x1_changed ||
       y1_changed ||
       x2_changed ||
@@ -2621,6 +2619,7 @@ clutter_actor_set_allocation_internal (ClutterActor           *self,
       CLUTTER_NOTE (LAYOUT, "Allocation for '%s' changed",
                     _clutter_actor_get_debug_name (self));
 
+      /* This will also call absolute_geometry_changed() on the subtree */
       transform_changed (self);
 
       g_object_notify_by_pspec (obj, obj_props[PROP_ALLOCATION]);
@@ -9554,25 +9553,10 @@ clutter_actor_allocate (ClutterActor          *self,
 
   priv = self->priv;
 
-  priv->absolute_origin_changed = priv->parent
-                                ? priv->parent->priv->absolute_origin_changed
-                                : FALSE;
-
   if (!CLUTTER_ACTOR_IS_TOPLEVEL (self) &&
       !CLUTTER_ACTOR_IS_MAPPED (self) &&
       !clutter_actor_has_mapped_clones (self))
-    {
-      if (priv->absolute_origin_changed)
-        {
-          _clutter_actor_traverse (self,
-                                   CLUTTER_ACTOR_TRAVERSE_DEPTH_FIRST,
-                                   absolute_geometry_changed_cb,
-                                   NULL,
-                                   NULL);
-        }
-
-      goto out;
-    }
+    return;
 
   old_allocation = priv->allocation;
   real_allocation = *box;
@@ -9615,22 +9599,12 @@ clutter_actor_allocate (ClutterActor          *self,
    * queue_relayout() and needs a new allocation.
    *
    * In case needs_allocation isn't set and we didn't move nor resize, we
-   * can safely stop allocating, but we need to notify the sub-tree in case
-   * our absolute origin changed.
+   * can safely stop allocating.
    */
   if (!priv->needs_allocation && !origin_changed && !size_changed)
     {
-      if (priv->absolute_origin_changed)
-        {
-          _clutter_actor_traverse (self,
-                                   CLUTTER_ACTOR_TRAVERSE_DEPTH_FIRST,
-                                   absolute_geometry_changed_cb,
-                                   NULL,
-                                   NULL);
-        }
-
       CLUTTER_NOTE (LAYOUT, "No allocation needed");
-      goto out;
+      return;
     }
 
   if (CLUTTER_ACTOR_IS_MAPPED (self))
@@ -9641,16 +9615,13 @@ clutter_actor_allocate (ClutterActor          *self,
       /* If the actor didn't move but needs_allocation is set, we just
        * need to allocate the children (see comment above) */
       clutter_actor_allocate_internal (self, &real_allocation);
-      goto out;
+      return;
     }
 
   if (_clutter_actor_create_transition (self, obj_props[PROP_ALLOCATION],
                                         &priv->allocation,
                                         &real_allocation))
     clutter_actor_allocate_internal (self, &priv->allocation);
-
-out:
-  priv->absolute_origin_changed = FALSE;
 }
 
 /**
