diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 3f3b9d9d83fb4d5a98f60e5d1bcac9abde54865a..28f461c70863e7343d5983482ad1cdfc0382bfa3 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -189,7 +189,7 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
     {
       frame_clock->last_presentation_time_us = presentation_time_us;
     }
-  else
+  else if (presentation_time_us != 0)
     {
       g_warning_once ("Bogus presentation time %" G_GINT64_FORMAT
                       " travelled back in time, using current time.",
diff --git a/cogl/cogl/cogl-onscreen-private.h b/cogl/cogl/cogl-onscreen-private.h
index ad46273042d91557a757ddfb4066d8867e9ddf47..1acd3139b017ed26c6e77b01381d960c896b8fb1 100644
--- a/cogl/cogl/cogl-onscreen-private.h
+++ b/cogl/cogl/cogl-onscreen-private.h
@@ -72,6 +72,8 @@ struct _CoglOnscreen
                                * cogl_onscreen_swap_buffers() */
   GQueue pending_frame_infos;
 
+  guint timeout_source_id;
+
   void *winsys;
 };
 
diff --git a/cogl/cogl/cogl-onscreen.c b/cogl/cogl/cogl-onscreen.c
index 651f3a72757f04368d718c48b5f0079b6dad5a3a..1ab0eefa5cf543e771a83ff7c1b9812efe8cdbaf 100644
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -146,6 +146,12 @@ cogl_onscreen_dispose (GObject *object)
   _cogl_closure_list_disconnect_all (&onscreen->frame_closures);
   _cogl_closure_list_disconnect_all (&onscreen->dirty_closures);
 
+  if (onscreen->timeout_source_id)
+    {
+      g_source_remove (onscreen->timeout_source_id);
+      onscreen->timeout_source_id = 0;
+    }
+
   while ((frame_info = g_queue_pop_tail (&onscreen->pending_frame_infos)))
     cogl_object_unref (frame_info);
   g_queue_clear (&onscreen->pending_frame_infos);
@@ -299,6 +305,60 @@ _cogl_onscreen_queue_event (CoglOnscreen *onscreen,
   _cogl_onscreen_queue_dispatch_idle (onscreen);
 }
 
+static void
+cogl_onscreen_schedule_presentation_events (CoglOnscreen *onscreen);
+
+static gboolean
+cogl_onscreen_emit_presentation_event_now (gpointer user_data)
+{
+  CoglOnscreen *onscreen = COGL_ONSCREEN (user_data);
+  CoglFrameInfo *info;
+
+  info = g_queue_pop_head (&onscreen->pending_frame_infos);
+  _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
+  _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
+  cogl_object_unref (info);
+
+  onscreen->timeout_source_id = 0;
+
+  if (!g_queue_is_empty (&onscreen->pending_frame_infos))
+    cogl_onscreen_schedule_presentation_events (onscreen);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+cogl_onscreen_schedule_presentation_events (CoglOnscreen *onscreen)
+{
+  CoglFrameInfo *info;
+
+  info = g_queue_peek_head (&onscreen->pending_frame_infos);
+
+  if (!info || onscreen->timeout_source_id)
+    return;
+
+  if (info->presentation_time)
+    {
+      CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+      CoglContext *context = cogl_framebuffer_get_context (framebuffer);
+      int64_t now_ns = cogl_get_clock_time (context);
+
+      if (info->presentation_time > now_ns)
+        {
+          int64_t delay_ns = info->presentation_time - now_ns;
+          unsigned int delay_ms = (delay_ns + 999999) / 1000000;
+
+          onscreen->timeout_source_id =
+            g_timeout_add (delay_ms,
+                           cogl_onscreen_emit_presentation_event_now,
+                           onscreen);
+          return;
+        }
+    }
+
+  cogl_onscreen_emit_presentation_event_now (onscreen);
+}
+
 void
 cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                         const int *rectangles,
@@ -325,18 +385,7 @@ cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                     COGL_BUFFER_BIT_STENCIL);
 
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT))
-    {
-      CoglFrameInfo *info;
-
-      g_warn_if_fail (onscreen->pending_frame_infos.length == 1);
-
-      info = g_queue_pop_tail (&onscreen->pending_frame_infos);
-
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
-
-      cogl_object_unref (info);
-    }
+    cogl_onscreen_schedule_presentation_events (onscreen);
 
   onscreen->frame_counter++;
 }
@@ -381,18 +430,7 @@ cogl_onscreen_swap_region (CoglOnscreen *onscreen,
                                     COGL_BUFFER_BIT_STENCIL);
 
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT))
-    {
-      CoglFrameInfo *info;
-
-      g_warn_if_fail (onscreen->pending_frame_infos.length == 1);
-
-      info = g_queue_pop_tail (&onscreen->pending_frame_infos);
-
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
-
-      cogl_object_unref (info);
-    }
+    cogl_onscreen_schedule_presentation_events (onscreen);
 
   onscreen->frame_counter++;
 }
diff --git a/cogl/cogl/winsys/cogl-winsys-glx.c b/cogl/cogl/winsys/cogl-winsys-glx.c
index 759a15c715a44e25f3f649071abf97d3afd45018..40c63e6307dbd3fa1fd49ac50a844ea10d50ebef 100644
--- a/cogl/cogl/winsys/cogl-winsys-glx.c
+++ b/cogl/cogl/winsys/cogl-winsys-glx.c
@@ -1909,11 +1909,55 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
         _cogl_winsys_wait_for_vblank (onscreen);
     }
 
-  glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
-
   if (have_counter)
-    glx_onscreen->last_swap_vsync_counter =
-      _cogl_winsys_get_vsync_counter (context);
+    {
+      uint32_t vsync_count_before, vsync_count_after;
+
+      vsync_count_before = _cogl_winsys_get_vsync_counter (context);
+      glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
+      vsync_count_after = _cogl_winsys_get_vsync_counter (context);
+
+      glx_onscreen->last_swap_vsync_counter = vsync_count_after;
+
+      /* If we don't have presentation event support (Nvidia) but the swap
+       * blocked then right now is a pretty good estimate of the presentation
+       * time of the frame from nbuffers-1 swaps ago.
+       */
+      if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT) &&
+          vsync_count_after != vsync_count_before)
+        {
+          CoglFrameInfo *frame_info;
+
+          frame_info = g_queue_peek_tail (&onscreen->pending_frame_infos);
+          g_warn_if_fail (frame_info != NULL);
+
+          if (frame_info)
+            {
+              const int64_t one_second_ns = 1000000000;
+              float refresh_rate;
+              int64_t refresh_interval_ns;
+
+              refresh_rate = cogl_output_get_refresh_rate (xlib_onscreen->output);
+              refresh_interval_ns = one_second_ns / refresh_rate;
+
+              /* If the current time is when the swap at the head of the queue
+               * presented, then the expected presentation time of our most
+               * recent swap at the tail of the queue is nbuffers-1 frames
+               * later. However since we can't reliably know the value of
+               * nbuffers, or the semantics of whether the driver will use them
+               * FIFO, we assume the minimum which is two buffers. Thus the
+               * expected presentation time of the most recent swap is one
+               * frame interval from now:
+               */
+              frame_info->presentation_time =
+                _cogl_winsys_get_clock_time (context) + refresh_interval_ns;
+            }
+        }
+    }
+  else
+    {
+      glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
+    }
 
   set_frame_info_output (onscreen, xlib_onscreen->output);
 }
