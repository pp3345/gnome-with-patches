diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 3f3b9d9d83fb4d5a98f60e5d1bcac9abde54865a..28f461c70863e7343d5983482ad1cdfc0382bfa3 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -189,7 +189,7 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
     {
       frame_clock->last_presentation_time_us = presentation_time_us;
     }
-  else
+  else if (presentation_time_us != 0)
     {
       g_warning_once ("Bogus presentation time %" G_GINT64_FORMAT
                       " travelled back in time, using current time.",
diff --git a/cogl/cogl/winsys/cogl-winsys-glx.c b/cogl/cogl/winsys/cogl-winsys-glx.c
index 452a88060c6698eaeabec53602eaa9157b42bb8d..d2b6579549d3a04b8621b1b90a4d4615d63d4a4f 100644
--- a/cogl/cogl/winsys/cogl-winsys-glx.c
+++ b/cogl/cogl/winsys/cogl-winsys-glx.c
@@ -1842,6 +1842,33 @@ _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
     }
 }
 
+static unsigned int
+get_buffer_queue_len (CoglOnscreen *onscreen)
+{
+  unsigned int buffer_queue_len;
+  static int nvidia_max_frames_allowed = -1;
+
+  /* If __GL_MaxFramesAllowed is set on the Nvidia driver then the buffer
+   * age, while correct, stops representing nbuffers-1. So we need to treat
+   * that environment case differently.
+   */
+  if (nvidia_max_frames_allowed == -1)
+    {
+      const gchar *env = g_getenv ("__GL_MaxFramesAllowed");
+      if (env)
+        nvidia_max_frames_allowed = atoi (env);
+      else
+        nvidia_max_frames_allowed = 0;
+    }
+
+  if (nvidia_max_frames_allowed > 0)
+    buffer_queue_len = nvidia_max_frames_allowed;
+  else
+    buffer_queue_len = _cogl_winsys_onscreen_get_buffer_age (onscreen) + 1;
+
+  return buffer_queue_len;
+}
+
 static void
 _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                                 const int *rectangles,
@@ -1911,11 +1938,52 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
         _cogl_winsys_wait_for_vblank (onscreen);
     }
 
-  glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
-
   if (have_counter)
-    glx_onscreen->last_swap_vsync_counter =
-      _cogl_winsys_get_vsync_counter (context);
+    {
+      uint32_t vsync_count_before, vsync_count_after;
+
+      vsync_count_before = _cogl_winsys_get_vsync_counter (context);
+      glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
+      vsync_count_after = _cogl_winsys_get_vsync_counter (context);
+
+      glx_onscreen->last_swap_vsync_counter = vsync_count_after;
+
+      /* If we don't have presentation event support (Nvidia) but the swap
+       * blocked then right now is a pretty good estimate of the presentation
+       * time of the frame from nbuffers-1 swaps ago.
+       */
+      if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT) &&
+          vsync_count_after != vsync_count_before)
+        {
+          CoglFrameInfo *frame_info;
+
+          frame_info = g_queue_peek_tail (&onscreen->pending_frame_infos);
+          g_warn_if_fail (frame_info != NULL);
+
+          if (frame_info)
+            {
+              const int64_t one_second_ns = 1000000000;
+              float refresh_rate;
+              int64_t refresh_interval_ns;
+
+              refresh_rate = cogl_output_get_refresh_rate (xlib_onscreen->output);
+              refresh_interval_ns = one_second_ns / refresh_rate;
+
+              /* If the current time is that of the swap from the head of the
+               * queue then the expected presentation time of our most recent
+               * swap at the tail of the queue is buffer_queue_len-1 frames
+               * later.
+               */
+              frame_info->presentation_time =
+                _cogl_winsys_get_clock_time (context) +
+                (get_buffer_queue_len (onscreen) - 1) * refresh_interval_ns;
+            }
+        }
+    }
+  else
+    {
+      glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
+    }
 
   set_frame_info_output (onscreen, xlib_onscreen->output);
 }
