diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 1fea057bd2f02437a18f990d596857687603ac8a..48ba31f8bc8b743e378fff0560ec070a916ce202 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -63,6 +63,7 @@ struct _ClutterFrameClock
   GObject parent;
 
   float refresh_rate;
+  int64_t refresh_interval_us;
   ClutterFrameListener listener;
 
   GSource *source;
@@ -71,6 +72,7 @@ struct _ClutterFrameClock
 
   ClutterFrameClockState state;
   int64_t last_presentation_time_us;
+  int64_t last_known_presentation_phase_us;
 
   gboolean is_next_presentation_time_valid;
   int64_t next_presentation_time_us;
@@ -188,6 +190,16 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
        INT64_MAX / 2))
     {
       frame_clock->last_presentation_time_us = presentation_time_us;
+      frame_clock->last_known_presentation_phase_us =
+        presentation_time_us % frame_clock->refresh_interval_us;
+    }
+  else if (presentation_time_us == 0)
+    {
+      /* On some platforms we have intermittent presentation time
+       * measurements. So we rely on the already known phase value
+       * and will estimate the last presentation time from that later.
+       */
+      frame_clock->last_presentation_time_us = 0;
     }
   else
     {
@@ -195,6 +207,9 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
                       " travelled back in time, using current time.",
                       presentation_time_us);
       frame_clock->last_presentation_time_us = g_get_monotonic_time ();
+      frame_clock->last_known_presentation_phase_us =
+        frame_clock->last_presentation_time_us %
+        frame_clock->refresh_interval_us;
     }
 
   switch (frame_clock->state)
@@ -219,7 +234,6 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
 {
   int64_t last_presentation_time_us;
   int64_t now_us;
-  float refresh_rate;
   int64_t refresh_interval_us;
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
@@ -230,8 +244,7 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
 
   now_us = g_get_monotonic_time ();
 
-  refresh_rate = frame_clock->refresh_rate;
-  refresh_interval_us = (int64_t) (0.5 + G_USEC_PER_SEC / refresh_rate);
+  refresh_interval_us = frame_clock->refresh_interval_us;
 
   min_render_time_allowed_us = refresh_interval_us / 2;
   max_render_time_allowed_us = refresh_interval_us - SYNC_DELAY_US;
@@ -245,15 +258,17 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
   /* Skip ahead to get close to the actual next presentation time. */
   if (next_presentation_time_us < now_us)
     {
-      int64_t logical_clock_offset_us;
-      int64_t logical_clock_phase_us;
-      int64_t hw_clock_offset_us;
+      int64_t earliest_last_presentation_time_us;
+
+      earliest_last_presentation_time_us =
+        now_us - now_us % refresh_interval_us;
 
-      logical_clock_offset_us = now_us % refresh_interval_us;
-      logical_clock_phase_us = now_us - logical_clock_offset_us;
-      hw_clock_offset_us = last_presentation_time_us % refresh_interval_us;
+      last_presentation_time_us =
+        earliest_last_presentation_time_us +
+        frame_clock->last_known_presentation_phase_us;
 
-      next_presentation_time_us = logical_clock_phase_us + hw_clock_offset_us;
+      next_presentation_time_us =
+        last_presentation_time_us + refresh_interval_us;
     }
 
   /* Skip one interval if we got an early presented event. */
@@ -500,6 +515,8 @@ clutter_frame_clock_new (float                            refresh_rate,
   init_frame_clock_source (frame_clock);
 
   frame_clock->refresh_rate = refresh_rate;
+  frame_clock->refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC / refresh_rate);
 
   return frame_clock;
 }
diff --git a/cogl/cogl/winsys/cogl-winsys-glx.c b/cogl/cogl/winsys/cogl-winsys-glx.c
index 452a88060c6698eaeabec53602eaa9157b42bb8d..28d05aff8674afa7c80e043aebe7ab7d26870162 100644
--- a/cogl/cogl/winsys/cogl-winsys-glx.c
+++ b/cogl/cogl/winsys/cogl-winsys-glx.c
@@ -1842,6 +1842,35 @@ _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
     }
 }
 
+static unsigned int
+get_max_nonblocking_swaps (CoglOnscreen *onscreen)
+{
+  unsigned int max_nonblocking_swaps;
+  static int nvidia_max_frames_allowed = -1;
+
+  /* The reason we measure "max nonblocking swaps" is because that can actually
+   * be a smaller value than nbuffers-1 on the Nvidia driver when this
+   * environment is set. It appears Nvidia doesn't bother to restrict the
+   * number of unique buffers, but does throttle swaps as if the number of
+   * buffers was lower. So we need to check for that...
+   */
+  if (nvidia_max_frames_allowed == -1)
+    {
+      const gchar *env = g_getenv ("__GL_MaxFramesAllowed");
+      if (env)
+        nvidia_max_frames_allowed = atoi (env);
+      else
+        nvidia_max_frames_allowed = 0;
+    }
+
+  if (nvidia_max_frames_allowed > 0)
+    max_nonblocking_swaps = nvidia_max_frames_allowed - 1;
+  else
+    max_nonblocking_swaps = _cogl_winsys_onscreen_get_buffer_age (onscreen);
+
+  return max_nonblocking_swaps;
+}
+
 static void
 _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                                 const int *rectangles,
@@ -1858,6 +1887,7 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
   CoglOnscreenGLX *glx_onscreen = onscreen->winsys;
   gboolean have_counter;
   GLXDrawable drawable;
+  int64_t swap_start_time_ns, swap_end_time_ns;
 
   /* XXX: theoretically this shouldn't be necessary but at least with
    * the Intel drivers we have see that if we don't call
@@ -1911,13 +1941,43 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
         _cogl_winsys_wait_for_vblank (onscreen);
     }
 
+  swap_start_time_ns = _cogl_winsys_get_clock_time (context);
   glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
+  swap_end_time_ns = _cogl_winsys_get_clock_time (context);
 
   if (have_counter)
     glx_onscreen->last_swap_vsync_counter =
       _cogl_winsys_get_vsync_counter (context);
 
   set_frame_info_output (onscreen, xlib_onscreen->output);
+
+  if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT))
+    {
+      float refresh_rate;
+      int64_t refresh_interval_ns, min_vsync_blocking_ns;
+      CoglFrameInfo *frame_info;
+
+      refresh_rate = cogl_output_get_refresh_rate (xlib_onscreen->output);
+      refresh_interval_ns = 1000000000 / refresh_rate;
+      min_vsync_blocking_ns = refresh_interval_ns / 2;
+
+      frame_info = g_queue_peek_tail (&onscreen->pending_frame_infos);
+      g_warn_if_fail (frame_info != NULL);
+
+      /* glXSwapBuffers takes a minimum of tens to hundreds of microseconds. If
+       * it starts taking milliseconds then that's not CPU time, but means it
+       * is sleeping to throttle to vsync. So on those frames we get a good
+       * estimate of the last presentation time (of the OLDEST swap pending,
+       * not our most recent swap). And on faster swaps, the frame clock code
+       * can just extrapolate when it would be.
+       */
+      if (frame_info &&
+          (swap_end_time_ns - swap_start_time_ns) >= min_vsync_blocking_ns)
+        {
+          frame_info->presentation_time = swap_end_time_ns +
+            get_max_nonblocking_swaps (onscreen) * refresh_interval_ns;
+        }
+    }
 }
 
 static uint32_t
