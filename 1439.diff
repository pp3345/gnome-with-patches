diff --git a/clutter/clutter/clutter-actor-private.h b/clutter/clutter/clutter-actor-private.h
index 16ab012b6f6a9daa6e5399d8a47e934f95ae62bf..dda39e4fde431b9a2ef6303f0b61757cca7c0910 100644
--- a/clutter/clutter/clutter-actor-private.h
+++ b/clutter/clutter/clutter-actor-private.h
@@ -180,10 +180,10 @@ struct _ClutterTransformInfo
   graphene_point_t pivot;
   gfloat pivot_z;
 
-  CoglMatrix transform;
+  graphene_matrix_t transform;
   guint transform_set : 1;
 
-  CoglMatrix child_transform;
+  graphene_matrix_t child_transform;
   guint child_transform_set : 1;
 };
 
@@ -220,11 +220,11 @@ void                            _clutter_actor_traverse
                                                                                          gpointer user_data);
 ClutterActor *                  _clutter_actor_get_stage_internal                       (ClutterActor *actor);
 
-void                            _clutter_actor_apply_modelview_transform                (ClutterActor *self,
-                                                                                         CoglMatrix   *matrix);
-void                            _clutter_actor_apply_relative_transformation_matrix     (ClutterActor *self,
-                                                                                         ClutterActor *ancestor,
-                                                                                         CoglMatrix   *matrix);
+void                            _clutter_actor_apply_modelview_transform                (ClutterActor      *self,
+                                                                                         graphene_matrix_t *matrix);
+void                            _clutter_actor_apply_relative_transformation_matrix     (ClutterActor      *self,
+                                                                                         ClutterActor      *ancestor,
+                                                                                         graphene_matrix_t *matrix);
 
 void                            _clutter_actor_rerealize                                (ClutterActor    *self,
                                                                                          ClutterCallback  callback,
diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index da610f4cf9aed952e626f7a5d314225a282901e4..68290b986d2ff33816bdcca6661b2fa47e5ca4e3 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -703,7 +703,8 @@ struct _ClutterActorPrivate
   graphene_rect_t clip;
 
   /* the cached transformation matrix; see apply_transform() */
-  CoglMatrix transform;
+  graphene_matrix_t transform;
+  graphene_matrix_t inverse_transform;
 
   float resource_scale;
 
@@ -857,6 +858,7 @@ struct _ClutterActorPrivate
   guint had_effects_on_last_paint_volume_update : 1;
   guint absolute_origin_changed     : 1;
   guint needs_update_stage_views    : 1;
+  guint has_inverse_transform       : 1;
 };
 
 enum
@@ -1048,9 +1050,9 @@ static void clutter_actor_update_map_state       (ClutterActor  *self,
                                                   MapStateChange change);
 static void clutter_actor_unrealize_not_hiding   (ClutterActor *self);
 
-static void _clutter_actor_get_relative_transformation_matrix (ClutterActor *self,
-                                                               ClutterActor *ancestor,
-                                                               CoglMatrix *matrix);
+static void _clutter_actor_get_relative_transformation_matrix (ClutterActor      *self,
+                                                               ClutterActor      *ancestor,
+                                                               graphene_matrix_t *matrix);
 
 static ClutterPaintVolume *_clutter_actor_get_paint_volume_mutable (ClutterActor *self);
 
@@ -1068,10 +1070,10 @@ static inline void clutter_actor_set_margin_internal (ClutterActor *self,
                                                       gfloat        margin,
                                                       GParamSpec   *pspec);
 
-static void clutter_actor_set_transform_internal (ClutterActor        *self,
-                                                  const ClutterMatrix *transform);
-static void clutter_actor_set_child_transform_internal (ClutterActor        *self,
-                                                        const ClutterMatrix *transform);
+static void clutter_actor_set_transform_internal (ClutterActor            *self,
+                                                  const graphene_matrix_t *transform);
+static void clutter_actor_set_child_transform_internal (ClutterActor            *self,
+                                                        const graphene_matrix_t *transform);
 
 static void     clutter_actor_realize_internal          (ClutterActor *self);
 static void     clutter_actor_unrealize_internal        (ClutterActor *self);
@@ -1080,4 +1082,5 @@ static void clutter_actor_push_in_cloned_branch (ClutterActor *self,
                                                  gulong        count);
 static void clutter_actor_pop_in_cloned_branch (ClutterActor *self,
                                                 gulong        count);
+static void ensure_valid_actor_transform (ClutterActor *actor);
 
@@ -1253,17 +1256,21 @@ _clutter_actor_transform_local_box_to_stage (ClutterActor          *self,
                                              const ClutterActorBox *box,
                                              graphene_point_t       vertices[4])
 {
+  ClutterActor *stage_actor = CLUTTER_ACTOR (stage);
+  ClutterActorPrivate *stage_priv = stage_actor->priv;
   CoglFramebuffer *fb =
    clutter_pick_context_get_framebuffer (pick_context);
-  CoglMatrix stage_transform, inv_stage_transform;
-  CoglMatrix modelview, transform_to_stage;
+  graphene_matrix_t modelview, transform_to_stage;
   int v;
 
-  clutter_actor_get_transform (CLUTTER_ACTOR (stage), &stage_transform);
-  if (!cogl_matrix_get_inverse (&stage_transform, &inv_stage_transform))
+  ensure_valid_actor_transform (stage_actor);
+
+  if (!stage_priv->has_inverse_transform)
     return FALSE;
   cogl_framebuffer_get_modelview_matrix (fb, &modelview);
-  cogl_matrix_multiply (&transform_to_stage, &inv_stage_transform, &modelview);
+  graphene_matrix_multiply (&modelview,
+                            &stage_priv->inverse_transform,
+                            &transform_to_stage);
 
   vertices[0].x = box->x1;
   vertices[0].y = box->y1;
@@ -1282,11 +1289,11 @@ _clutter_actor_transform_local_box_to_stage (ClutterActor          *self,
       float z = 0.f;
       float w = 1.f;
 
-      cogl_matrix_transform_point (&transform_to_stage,
-                                   &vertices[v].x,
-                                   &vertices[v].y,
-                                   &z,
-                                   &w);
+      cogl_graphene_matrix_project_point (&transform_to_stage,
+                                          &vertices[v].x,
+                                          &vertices[v].y,
+                                          &z,
+                                          &w);
     }
 
   return TRUE;
@@ -2846,7 +2853,7 @@ clutter_actor_apply_relative_transform_to_point (ClutterActor             *self,
                                                  graphene_point3d_t       *vertex)
 {
   gfloat w;
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
 
   g_return_if_fail (CLUTTER_IS_ACTOR (self));
   g_return_if_fail (ancestor == NULL || CLUTTER_IS_ACTOR (ancestor));
@@ -2866,7 +2873,11 @@ clutter_actor_apply_relative_transform_to_point (ClutterActor             *self,
     }
 
   _clutter_actor_get_relative_transformation_matrix (self, ancestor, &matrix);
-  cogl_matrix_transform_point (&matrix, &vertex->x, &vertex->y, &vertex->z, &w);
+  cogl_graphene_matrix_project_point (&matrix,
+                                      &vertex->x,
+                                      &vertex->y,
+                                      &vertex->z,
+                                      &w);
 }
 
 static gboolean
@@ -2876,8 +2887,8 @@ _clutter_actor_fully_transform_vertices (ClutterActor             *self,
                                          int                       n_vertices)
 {
   ClutterActor *stage;
-  CoglMatrix modelview;
-  CoglMatrix projection;
+  graphene_matrix_t modelview;
+  graphene_matrix_t projection;
   float viewport[4];
 
   g_return_val_if_fail (CLUTTER_IS_ACTOR (self), FALSE);
@@ -2939,7 +2950,7 @@ clutter_actor_apply_transform_to_point (ClutterActor             *self,
  * @self: The actor whose coordinate space you want to transform from.
  * @ancestor: The ancestor actor whose coordinate space you want to transform too
  *            or %NULL if you want to transform all the way to eye coordinates.
- * @matrix: A #CoglMatrix to store the transformation
+ * @matrix: A #graphene_matrix_t to store the transformation
  *
  * This gets a transformation @matrix that will transform coordinates from the
  * coordinate space of @self into the coordinate space of @ancestor.
@@ -2964,11 +2975,11 @@ clutter_actor_apply_transform_to_point (ClutterActor             *self,
 /* XXX: We should consider caching the stage relative modelview along with
  * the actor itself */
 static void
-_clutter_actor_get_relative_transformation_matrix (ClutterActor *self,
-                                                   ClutterActor *ancestor,
-                                                   CoglMatrix *matrix)
+_clutter_actor_get_relative_transformation_matrix (ClutterActor      *self,
+                                                   ClutterActor      *ancestor,
+                                                   graphene_matrix_t *matrix)
 {
-  cogl_matrix_init_identity (matrix);
+  graphene_matrix_init_identity (matrix);
 
   _clutter_actor_apply_relative_transformation_matrix (self, ancestor, matrix);
 }
@@ -3053,11 +3064,12 @@ clutter_actor_get_abs_allocation_vertices (ClutterActor       *self,
 }
 
 static void
-clutter_actor_real_apply_transform (ClutterActor  *self,
-                                    ClutterMatrix *matrix)
+clutter_actor_real_apply_transform (ClutterActor      *self,
+                                    graphene_matrix_t *matrix)
 {
   ClutterActorPrivate *priv = self->priv;
   const ClutterTransformInfo *info;
+  graphene_point3d_t p;
   float pivot_x = 0.f, pivot_y = 0.f;
 
   info = _clutter_actor_get_transform_info_or_defaults (self);
@@ -3079,87 +3091,92 @@ clutter_actor_real_apply_transform (ClutterActor  *self,
                 priv->allocation.x1 + pivot_x + info->translation.x,
                 priv->allocation.y1 + pivot_y + info->translation.y);
 
-  /* we apply the :child-transform from the parent actor, if we have one */
-  if (priv->parent != NULL)
+  /* roll back the pivot translation */
+  if (pivot_x != 0.f || pivot_y != 0.f || info->pivot_z != 0.f)
     {
-      const ClutterTransformInfo *parent_info;
-
-      parent_info = _clutter_actor_get_transform_info_or_defaults (priv->parent);
-      clutter_matrix_init_from_matrix (matrix, &(parent_info->child_transform));
+      graphene_point3d_init (&p, -pivot_x, -pivot_y, -info->pivot_z);
+      graphene_matrix_translate (matrix, &p);
     }
-  else
-    clutter_matrix_init_identity (matrix);
 
   /* if we have an overriding transformation, we use that, and get out */
   if (info->transform_set)
     {
+      graphene_matrix_multiply (matrix, &info->transform, matrix);
+
       /* we still need to apply the :allocation's origin and :pivot-point
        * translations, since :transform is relative to the actor's coordinate
        * space, and to the pivot point
        */
-      cogl_matrix_translate (matrix,
+      graphene_point3d_init (&p,
                              priv->allocation.x1 + pivot_x,
                              priv->allocation.y1 + pivot_y,
                              info->pivot_z);
-      cogl_matrix_multiply (matrix, matrix, &info->transform);
-      goto roll_back_pivot;
+      graphene_matrix_translate (matrix, &p);
+      goto roll_back;
     }
 
+  if (info->rx_angle)
+    graphene_matrix_rotate (matrix, info->rx_angle, graphene_vec3_x_axis ());
+
+  if (info->ry_angle)
+    graphene_matrix_rotate (matrix, info->ry_angle, graphene_vec3_y_axis ());
+
+  if (info->rz_angle)
+    graphene_matrix_rotate (matrix, info->rz_angle, graphene_vec3_z_axis ());
+
+  if (info->scale_x != 1.0 || info->scale_y != 1.0 || info->scale_z != 1.0)
+    graphene_matrix_scale (matrix, info->scale_x, info->scale_y, info->scale_z);
+
   /* basic translation: :allocation's origin and :z-position; instead
    * of decomposing the pivot and translation info separate operations,
    * we just compose everything into a single translation
    */
-  cogl_matrix_translate (matrix,
+  graphene_point3d_init (&p,
                          priv->allocation.x1 + pivot_x + info->translation.x,
                          priv->allocation.y1 + pivot_y + info->translation.y,
                          info->z_position + info->pivot_z + info->translation.z);
+  graphene_matrix_translate (matrix, &p);
 
-  /* because the rotation involves translations, we must scale
-   * before applying the rotations (if we apply the scale after
-   * the rotations, the translations included in the rotation are
-   * not scaled and so the entire object will move on the screen
-   * as a result of rotating it).
-   *
-   * XXX:2.0 the comment has to be reworded once we remove the
-   * per-transformation centers; we also may want to apply rotation
-   * first and scaling after, to match the matrix decomposition
-   * code we use when interpolating transformations
-   */
-  if (info->scale_x != 1.0 || info->scale_y != 1.0 || info->scale_z != 1.0)
-    cogl_matrix_scale (matrix, info->scale_x, info->scale_y, info->scale_z);
-
-  if (info->rz_angle)
-    cogl_matrix_rotate (matrix, info->rz_angle, 0, 0, 1.0);
-
-  if (info->ry_angle)
-    cogl_matrix_rotate (matrix, info->ry_angle, 0, 1.0, 0);
-
-  if (info->rx_angle)
-    cogl_matrix_rotate (matrix, info->rx_angle, 1.0, 0, 0);
+roll_back:
+  /* we apply the :child-transform from the parent actor, if we have one */
+  if (priv->parent != NULL)
+    {
+      const ClutterTransformInfo *parent_info;
 
-roll_back_pivot:
-  /* roll back the pivot translation */
-  if (pivot_x != 0.f || pivot_y != 0.f || info->pivot_z != 0.f)
-    cogl_matrix_translate (matrix, -pivot_x, -pivot_y, -info->pivot_z);
+      parent_info = _clutter_actor_get_transform_info_or_defaults (priv->parent);
+      graphene_matrix_multiply (matrix, &parent_info->child_transform, matrix);
+    }
 }
 
 /* Applies the transforms associated with this actor to the given
  * matrix. */
-void
-_clutter_actor_apply_modelview_transform (ClutterActor  *self,
-                                          ClutterMatrix *matrix)
+
+static void
+ensure_valid_actor_transform (ClutterActor *actor)
 {
-  ClutterActorPrivate *priv = self->priv;
+  ClutterActorPrivate *priv = actor->priv;
 
   if (priv->transform_valid)
-    goto out;
+    return;
+
+  graphene_matrix_init_identity (&priv->transform);
 
-  CLUTTER_ACTOR_GET_CLASS (self)->apply_transform (self, &priv->transform);
+  CLUTTER_ACTOR_GET_CLASS (actor)->apply_transform (actor, &priv->transform);
+  priv->has_inverse_transform =
+    cogl_graphene_matrix_get_inverse (&priv->transform,
+                                      &priv->inverse_transform);
 
   priv->transform_valid = TRUE;
+}
 
-out:
-  cogl_matrix_multiply (matrix, matrix, &priv->transform);
+void
+_clutter_actor_apply_modelview_transform (ClutterActor      *self,
+                                          graphene_matrix_t *matrix)
+{
+  ClutterActorPrivate *priv = self->priv;
+
+  ensure_valid_actor_transform (self);
+  graphene_matrix_multiply (&priv->transform, matrix, matrix);
 }
 
 /*
@@ -3167,7 +3184,7 @@ out:
  * @self: The actor whose coordinate space you want to transform from.
  * @ancestor: The ancestor actor whose coordinate space you want to transform too
  *            or %NULL if you want to transform all the way to eye coordinates.
- * @matrix: A #ClutterMatrix to apply the transformation too.
+ * @matrix: A #graphene_matrix_t to apply the transformation too.
  *
  * This multiplies a transform with @matrix that will transform coordinates
  * from the coordinate space of @self into the coordinate space of @ancestor.
@@ -3185,14 +3202,14 @@ out:
  *
  * This function doesn't initialize the given @matrix, it simply
  * multiplies the requested transformation matrix with the existing contents of
- * @matrix. You can use cogl_matrix_init_identity() to initialize the @matrix
+ * @matrix. You can use graphene_matrix_init_identity() to initialize the @matrix
  * before calling this function, or you can use
  * clutter_actor_get_relative_transformation_matrix() instead.
  */
 void
-_clutter_actor_apply_relative_transformation_matrix (ClutterActor *self,
-                                                     ClutterActor *ancestor,
-                                                     CoglMatrix *matrix)
+_clutter_actor_apply_relative_transformation_matrix (ClutterActor      *self,
+                                                     ClutterActor      *ancestor,
+                                                     graphene_matrix_t *matrix)
 {
   /* Note we terminate before ever calling stage->apply_transform()
    * since that would conceptually be relative to the underlying
@@ -3819,11 +3836,11 @@ clutter_actor_paint (ClutterActor        *self,
   if (priv->enable_model_view_transform)
     {
       ClutterPaintNode *transform_node;
-      CoglMatrix transform;
+      graphene_matrix_t transform;
 
       clutter_actor_get_transform (self, &transform);
 
-      if (!cogl_matrix_is_identity (&transform))
+      if (!graphene_matrix_is_identity (&transform))
         {
           transform_node = clutter_transform_node_new (&transform);
           clutter_paint_node_add_child (transform_node, root_node);
@@ -3837,12 +3854,12 @@ clutter_actor_paint (ClutterActor        *self,
        * of an apply_transform vfunc... */
       if (G_UNLIKELY (clutter_debug_flags & CLUTTER_DEBUG_OOB_TRANSFORMS))
         {
-          CoglMatrix expected_matrix;
+          graphene_matrix_t expected_matrix;
 
           _clutter_actor_get_relative_transformation_matrix (self, NULL,
                                                              &expected_matrix);
 
-          if (!cogl_matrix_equal (&transform, &expected_matrix))
+          if (!graphene_matrix_equal_fast (&transform, &expected_matrix))
             {
               GString *buf = g_string_sized_new (1024);
               ClutterActor *parent;
@@ -4073,7 +4090,7 @@ clutter_actor_pick (ClutterActor       *actor,
 
   if (priv->enable_model_view_transform)
     {
-      CoglMatrix matrix;
+      graphene_matrix_t matrix;
 
       cogl_framebuffer_get_modelview_matrix (framebuffer, &matrix);
       _clutter_actor_apply_modelview_transform (actor, &matrix);
@@ -4418,7 +4435,7 @@ clutter_actor_remove_child_internal (ClutterActor                 *self,
   g_object_unref (child);
 }
 
-static const ClutterTransformInfo default_transform_info = {
+static ClutterTransformInfo default_transform_info = {
   0.0,                          /* rotation-x */
   0.0,                          /* rotation-y */
   0.0,                          /* rotation-z */
@@ -4432,12 +4449,27 @@ static const ClutterTransformInfo default_transform_info = {
   GRAPHENE_POINT_INIT_ZERO,     /* pivot */
   0.f,                          /* pivot-z */
 
-  CLUTTER_MATRIX_INIT_IDENTITY,
+  { },
   FALSE,                        /* transform */
-  CLUTTER_MATRIX_INIT_IDENTITY,
+  { },
   FALSE,                        /* child-transform */
 };
 
+static inline const ClutterTransformInfo *
+get_default_transform_info (void)
+{
+  static gsize initialized = FALSE;
+
+  if (G_UNLIKELY (g_once_init_enter (&initialized)))
+    {
+      graphene_matrix_init_identity (&default_transform_info.transform);
+      graphene_matrix_init_identity (&default_transform_info.child_transform);
+      g_once_init_leave (&initialized, TRUE);
+    }
+
+  return &default_transform_info;
+}
+
 /*< private >
  * _clutter_actor_get_transform_info_or_defaults:
  * @self: a #ClutterActor
@@ -4460,7 +4492,7 @@ _clutter_actor_get_transform_info_or_defaults (ClutterActor *self)
   if (info != NULL)
     return info;
 
-  return &default_transform_info;
+  return get_default_transform_info ();
 }
 
 static void
@@ -4497,7 +4529,7 @@ _clutter_actor_get_transform_info (ClutterActor *self)
     {
       info = g_slice_new (ClutterTransformInfo);
 
-      *info = default_transform_info;
+      *info = *get_default_transform_info ();
 
       g_object_set_qdata_full (G_OBJECT (self), quark_actor_transform_info,
                                info,
@@ -5456,7 +5488,7 @@ clutter_actor_get_property (GObject    *object,
 
     case PROP_TRANSFORM:
       {
-        ClutterMatrix m;
+        graphene_matrix_t m;
 
         clutter_actor_get_transform (actor, &m);
         g_value_set_boxed (value, &m);
@@ -5474,7 +5506,7 @@ clutter_actor_get_property (GObject    *object,
 
     case PROP_CHILD_TRANSFORM:
       {
-        ClutterMatrix m;
+        graphene_matrix_t m;
 
         clutter_actor_get_child_transform (actor, &m);
         g_value_set_boxed (value, &m);
@@ -6865,7 +6897,7 @@ clutter_actor_class_init (ClutterActorClass *klass)
    *
    * Application code should rarely need to use this function directly.
    *
-   * Setting this property with a #ClutterMatrix will set the
+   * Setting this property with a #graphene_matrix_t will set the
    * #ClutterActor:transform-set property to %TRUE as a side effect;
    * setting this property with %NULL will set the
    * #ClutterActor:transform-set property to %FALSE.
@@ -6878,7 +6910,7 @@ clutter_actor_class_init (ClutterActorClass *klass)
     g_param_spec_boxed ("transform",
                         P_("Transform"),
                         P_("Transformation matrix"),
-                        CLUTTER_TYPE_MATRIX,
+                        GRAPHENE_TYPE_MATRIX,
                         G_PARAM_READWRITE |
                         G_PARAM_STATIC_STRINGS |
                         CLUTTER_PARAM_ANIMATABLE);
@@ -6903,7 +6935,7 @@ clutter_actor_class_init (ClutterActorClass *klass)
    *
    * Applies a transformation matrix on each child of an actor.
    *
-   * Setting this property with a #ClutterMatrix will set the
+   * Setting this property with a #graphene_matrix_t will set the
    * #ClutterActor:child-transform-set property to %TRUE as a side effect;
    * setting this property with %NULL will set the
    * #ClutterActor:child-transform-set property to %FALSE.
@@ -6916,7 +6948,7 @@ clutter_actor_class_init (ClutterActorClass *klass)
     g_param_spec_boxed ("child-transform",
                         P_("Child Transform"),
                         P_("Children transformation matrix"),
-                        CLUTTER_TYPE_MATRIX,
+                        GRAPHENE_TYPE_MATRIX,
                         G_PARAM_READWRITE |
                         G_PARAM_STATIC_STRINGS |
                         CLUTTER_PARAM_ANIMATABLE);
@@ -14772,8 +14804,8 @@ clutter_actor_unset_flags (ClutterActor      *self,
 }
 
 static void
-clutter_actor_set_transform_internal (ClutterActor        *self,
-                                      const ClutterMatrix *transform)
+clutter_actor_set_transform_internal (ClutterActor            *self,
+                                      const graphene_matrix_t *transform)
 {
   ClutterTransformInfo *info;
   gboolean was_set;
@@ -14786,7 +14818,7 @@ clutter_actor_set_transform_internal (ClutterActor        *self,
   was_set = info->transform_set;
 
   info->transform = *transform;
-  info->transform_set = !cogl_matrix_is_identity (&info->transform);
+  info->transform_set = !graphene_matrix_is_identity (&info->transform);
 
   transform_changed (self);
 
@@ -14801,7 +14833,7 @@ clutter_actor_set_transform_internal (ClutterActor        *self,
 /**
  * clutter_actor_set_transform:
  * @self: a #ClutterActor
- * @transform: (allow-none): a #ClutterMatrix, or %NULL to
+ * @transform: (allow-none): a #graphene_matrix_t, or %NULL to
  *   unset a custom transformation
  *
  * Overrides the transformations of a #ClutterActor with a custom
@@ -14813,20 +14845,20 @@ clutter_actor_set_transform_internal (ClutterActor        *self,
  * Since: 1.12
  */
 void
-clutter_actor_set_transform (ClutterActor        *self,
-                             const ClutterMatrix *transform)
+clutter_actor_set_transform (ClutterActor            *self,
+                             const graphene_matrix_t *transform)
 {
   const ClutterTransformInfo *info;
-  ClutterMatrix new_transform;
+  graphene_matrix_t new_transform;
 
   g_return_if_fail (CLUTTER_IS_ACTOR (self));
 
   info = _clutter_actor_get_transform_info_or_defaults (self);
 
   if (transform != NULL)
-    clutter_matrix_init_from_matrix (&new_transform, transform);
+    graphene_matrix_init_from_matrix (&new_transform, transform);
   else
-    clutter_matrix_init_identity (&new_transform);
+    graphene_matrix_init_identity (&new_transform);
 
   _clutter_actor_create_transition (self, obj_props[PROP_TRANSFORM],
                                     &info->transform,
@@ -14836,20 +14868,20 @@ clutter_actor_set_transform (ClutterActor        *self,
 /**
  * clutter_actor_get_transform:
  * @self: a #ClutterActor
- * @transform: (out caller-allocates): a #ClutterMatrix
+ * @transform: (out caller-allocates): a #graphene_matrix_t
  *
  * Retrieves the current transformation matrix of a #ClutterActor.
  *
  * Since: 1.12
  */
 void
-clutter_actor_get_transform (ClutterActor  *self,
-                             ClutterMatrix *transform)
+clutter_actor_get_transform (ClutterActor      *self,
+                             graphene_matrix_t *transform)
 {
   g_return_if_fail (CLUTTER_IS_ACTOR (self));
   g_return_if_fail (transform != NULL);
 
-  cogl_matrix_init_identity (transform);
+  graphene_matrix_init_identity (transform);
   _clutter_actor_apply_modelview_transform (self, transform);
 }
 
@@ -19383,8 +19415,8 @@ done:
 }
 
 static void
-clutter_actor_set_child_transform_internal (ClutterActor        *self,
-                                            const ClutterMatrix *transform)
+clutter_actor_set_child_transform_internal (ClutterActor            *self,
+                                            const graphene_matrix_t *transform)
 {
   ClutterTransformInfo *info = _clutter_actor_get_transform_info (self);
   ClutterActorIter iter;
@@ -19392,10 +19424,10 @@ clutter_actor_set_child_transform_internal (ClutterActor        *self,
   GObject *obj;
   gboolean was_set = info->child_transform_set;
 
-  clutter_matrix_init_from_matrix (&info->child_transform, transform);
+  graphene_matrix_init_from_matrix (&info->child_transform, transform);
 
   /* if it's the identity matrix, we need to toggle the boolean flag */
-  info->child_transform_set = !cogl_matrix_is_identity (transform);
+  info->child_transform_set = !graphene_matrix_is_identity (transform);
 
   /* we need to reset the transform_valid flag on each child */
   clutter_actor_iter_init (&iter, self);
@@ -19414,7 +19446,7 @@ clutter_actor_set_child_transform_internal (ClutterActor        *self,
 /**
  * clutter_actor_set_child_transform:
  * @self: a #ClutterActor
- * @transform: (allow-none): a #ClutterMatrix, or %NULL
+ * @transform: (allow-none): a #graphene_matrix_t, or %NULL
  *
  * Sets the transformation matrix to be applied to all the children
  * of @self prior to their own transformations. The default child
@@ -19427,20 +19459,20 @@ clutter_actor_set_child_transform_internal (ClutterActor        *self,
  * Since: 1.12
  */
 void
-clutter_actor_set_child_transform (ClutterActor        *self,
-                                   const ClutterMatrix *transform)
+clutter_actor_set_child_transform (ClutterActor            *self,
+                                   const graphene_matrix_t *transform)
 {
   const ClutterTransformInfo *info;
-  ClutterMatrix new_transform;
+  graphene_matrix_t new_transform;
 
   g_return_if_fail (CLUTTER_IS_ACTOR (self));
 
   info = _clutter_actor_get_transform_info_or_defaults (self);
 
   if (transform != NULL)
-    clutter_matrix_init_from_matrix (&new_transform, transform);
+    graphene_matrix_init_from_matrix (&new_transform, transform);
   else
-    clutter_matrix_init_identity (&new_transform);
+    graphene_matrix_init_identity (&new_transform);
 
   _clutter_actor_create_transition (self, obj_props[PROP_CHILD_TRANSFORM],
                                     &info->child_transform,
@@ -19450,7 +19482,7 @@ clutter_actor_set_child_transform (ClutterActor        *self,
 /**
  * clutter_actor_get_child_transform:
  * @self: a #ClutterActor
- * @transform: (out caller-allocates): a #ClutterMatrix
+ * @transform: (out caller-allocates): a #graphene_matrix_t
  *
  * Retrieves the child transformation matrix set using
  * clutter_actor_set_child_transform(); if none is currently set,
@@ -19459,8 +19491,8 @@ clutter_actor_set_child_transform (ClutterActor        *self,
  * Since: 1.12
  */
 void
-clutter_actor_get_child_transform (ClutterActor  *self,
-                                   ClutterMatrix *transform)
+clutter_actor_get_child_transform (ClutterActor      *self,
+                                   graphene_matrix_t *transform)
 {
   const ClutterTransformInfo *info;
 
@@ -19470,9 +19502,9 @@ clutter_actor_get_child_transform (ClutterActor  *self,
   info = _clutter_actor_get_transform_info_or_defaults (self);
 
   if (info->child_transform_set)
-    clutter_matrix_init_from_matrix (transform, &info->child_transform);
+    graphene_matrix_init_from_matrix (transform, &info->child_transform);
   else
-    clutter_matrix_init_identity (transform);
+    graphene_matrix_init_identity (transform);
 }
 
 static void
diff --git a/clutter/clutter/clutter-actor.h b/clutter/clutter/clutter-actor.h
index b404dd635931a47584158b4dd83953b65a565a5c..3ffd98f2cb1964887f823786d54be5dc9979cc51 100644
--- a/clutter/clutter/clutter-actor.h
+++ b/clutter/clutter/clutter-actor.h
@@ -257,7 +257,7 @@ struct _ClutterActorClass
 
   /* transformations */
   void (* apply_transform)      (ClutterActor           *actor,
-                                 ClutterMatrix          *matrix);
+                                 graphene_matrix_t      *matrix);
 
   /* event signals */
   gboolean (* event)                (ClutterActor         *actor,
@@ -803,16 +803,16 @@ void                            clutter_actor_get_translation
                                                                                  gfloat                     *translate_z);
 CLUTTER_EXPORT
 void                            clutter_actor_set_transform                     (ClutterActor               *self,
-                                                                                 const ClutterMatrix        *transform);
+                                                                                 const graphene_matrix_t    *transform);
 CLUTTER_EXPORT
 void                            clutter_actor_get_transform                     (ClutterActor               *self,
-                                                                                 ClutterMatrix              *transform);
+                                                                                 graphene_matrix_t          *transform);
 CLUTTER_EXPORT
 void                            clutter_actor_set_child_transform               (ClutterActor               *self,
-                                                                                 const ClutterMatrix        *transform);
+                                                                                 const graphene_matrix_t    *transform);
 CLUTTER_EXPORT
 void                            clutter_actor_get_child_transform               (ClutterActor               *self,
-                                                                                 ClutterMatrix              *transform);
+                                                                                 graphene_matrix_t          *transform);
 
 CLUTTER_EXPORT
 void                            clutter_actor_get_transformed_extents          (ClutterActor               *self,
diff --git a/clutter/clutter/clutter-autocleanups.h b/clutter/clutter/clutter-autocleanups.h
index a9d103e7c2d6700cdd2db040e76c0ac0b28c6e04..1d5af5ef877dcd9a37983ee91725e7af5fbb5744 100644
--- a/clutter/clutter/clutter-autocleanups.h
+++ b/clutter/clutter/clutter-autocleanups.h
@@ -83,7 +83,6 @@ G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterZoomAction, g_object_unref)
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterActorBox, clutter_actor_box_free)
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterColor, clutter_color_free)
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterMargin, clutter_margin_free)
-G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterMatrix, clutter_matrix_free)
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterPaintContext, clutter_paint_context_unref)
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterPaintNode, clutter_paint_node_unref)
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterPaintVolume, clutter_paint_volume_free)
diff --git a/clutter/clutter/clutter-base-types.c b/clutter/clutter/clutter-base-types.c
index ea2719c69bb62f3a79e4dda29b8149fa474f90da..9825ba1f2c42e8902d0781fb25ff4085d6c83290 100644
--- a/clutter/clutter/clutter-base-types.c
+++ b/clutter/clutter/clutter-base-types.c
@@ -101,192 +101,3 @@ clutter_margin_free (ClutterMargin *margin_)
 G_DEFINE_BOXED_TYPE (ClutterMargin, clutter_margin,
                      clutter_margin_copy,
                      clutter_margin_free)
-
-/**
- * ClutterMatrix:
- *
- * A type representing a 4x4 matrix.
- *
- * It is identicaly to #CoglMatrix.
- *
- * Since: 1.12
- */
-
-static gpointer
-clutter_matrix_copy (gpointer data)
-{
-  return cogl_matrix_copy (data);
-}
-
-static gboolean
-clutter_matrix_progress (const GValue *a,
-                         const GValue *b,
-                         gdouble       progress,
-                         GValue       *retval)
-{
-  const ClutterMatrix *matrix1 = g_value_get_boxed (a);
-  const ClutterMatrix *matrix2 = g_value_get_boxed (b);
-  graphene_point3d_t scale1 = GRAPHENE_POINT3D_INIT (1.f, 1.f, 1.f);
-  float shear1[3] = { 0.f, 0.f, 0.f };
-  graphene_point3d_t rotate1 = GRAPHENE_POINT3D_INIT_ZERO;
-  graphene_point3d_t translate1 = GRAPHENE_POINT3D_INIT_ZERO;
-  ClutterVertex4 perspective1 = { 0.f, 0.f, 0.f, 0.f };
-  graphene_point3d_t scale2 = GRAPHENE_POINT3D_INIT (1.f, 1.f, 1.f);
-  float shear2[3] = { 0.f, 0.f, 0.f };
-  graphene_point3d_t rotate2 = GRAPHENE_POINT3D_INIT_ZERO;
-  graphene_point3d_t translate2 = GRAPHENE_POINT3D_INIT_ZERO;
-  ClutterVertex4 perspective2 = { 0.f, 0.f, 0.f, 0.f };
-  graphene_point3d_t scale_res = GRAPHENE_POINT3D_INIT (1.f, 1.f, 1.f);
-  float shear_res = 0.f;
-  graphene_point3d_t rotate_res = GRAPHENE_POINT3D_INIT_ZERO;
-  graphene_point3d_t translate_res = GRAPHENE_POINT3D_INIT_ZERO;
-  ClutterVertex4 perspective_res = { 0.f, 0.f, 0.f, 0.f };
-  ClutterMatrix res;
-
-  clutter_matrix_init_identity (&res);
-
-  _clutter_util_matrix_decompose (matrix1,
-                                  &scale1, shear1, &rotate1, &translate1,
-                                  &perspective1);
-  _clutter_util_matrix_decompose (matrix2,
-                                  &scale2, shear2, &rotate2, &translate2,
-                                  &perspective2);
-
-  /* perspective */
-  _clutter_util_vertex4_interpolate (&perspective1, &perspective2, progress, &perspective_res);
-  res.wx = perspective_res.x;
-  res.wy = perspective_res.y;
-  res.wz = perspective_res.z;
-  res.ww = perspective_res.w;
-
-  /* translation */
-  graphene_point3d_interpolate (&translate1, &translate2, progress, &translate_res);
-  cogl_matrix_translate (&res, translate_res.x, translate_res.y, translate_res.z);
-
-  /* rotation */
-  graphene_point3d_interpolate (&rotate1, &rotate2, progress, &rotate_res);
-  cogl_matrix_rotate (&res, rotate_res.x, 1.0f, 0.0f, 0.0f);
-  cogl_matrix_rotate (&res, rotate_res.y, 0.0f, 1.0f, 0.0f);
-  cogl_matrix_rotate (&res, rotate_res.z, 0.0f, 0.0f, 1.0f);
-
-  /* skew */
-  shear_res = shear1[2] + (shear2[2] - shear1[2]) * progress; /* YZ */
-  if (shear_res != 0.f)
-    _clutter_util_matrix_skew_yz (&res, shear_res);
-
-  shear_res = shear1[1] + (shear2[1] - shear1[1]) * progress; /* XZ */
-  if (shear_res != 0.f)
-    _clutter_util_matrix_skew_xz (&res, shear_res);
-
-  shear_res = shear1[0] + (shear2[0] - shear1[0]) * progress; /* XY */
-  if (shear_res != 0.f)
-    _clutter_util_matrix_skew_xy (&res, shear_res);
-
-  /* scale */
-  graphene_point3d_interpolate (&scale1, &scale2, progress, &scale_res);
-  cogl_matrix_scale (&res, scale_res.x, scale_res.y, scale_res.z);
-
-  g_value_set_boxed (retval, &res);
-
-  return TRUE;
-}
-
-G_DEFINE_BOXED_TYPE_WITH_CODE (ClutterMatrix, clutter_matrix,
-                               clutter_matrix_copy,
-                               clutter_matrix_free,
-                               CLUTTER_REGISTER_INTERVAL_PROGRESS (clutter_matrix_progress))
-
-/**
- * clutter_matrix_alloc:
- *
- * Allocates enough memory to hold a #ClutterMatrix.
- *
- * Return value: (transfer full): the newly allocated #ClutterMatrix
- *
- * Since: 1.12
- */
-ClutterMatrix *
-clutter_matrix_alloc (void)
-{
-  return g_new0 (ClutterMatrix, 1);
-}
-
-/**
- * clutter_matrix_free:
- * @matrix: (allow-none): a #ClutterMatrix
- *
- * Frees the memory allocated by clutter_matrix_alloc().
- *
- * Since: 1.12
- */
-void
-clutter_matrix_free (ClutterMatrix *matrix)
-{
-  cogl_matrix_free (matrix);
-}
-
-/**
- * clutter_matrix_init_identity:
- * @matrix: a #ClutterMatrix
- *
- * Initializes @matrix with the identity matrix, i.e.:
- *
- * |[
- *   .xx = 1.0, .xy = 0.0, .xz = 0.0, .xw = 0.0
- *   .yx = 0.0, .yy = 1.0, .yz = 0.0, .yw = 0.0
- *   .zx = 0.0, .zy = 0.0, .zz = 1.0, .zw = 0.0
- *   .wx = 0.0, .wy = 0.0, .wz = 0.0, .ww = 1.0
- * ]|
- *
- * Return value: (transfer none): the initialized #ClutterMatrix
- *
- * Since: 1.12
- */
-ClutterMatrix *
-clutter_matrix_init_identity (ClutterMatrix *matrix)
-{
-  cogl_matrix_init_identity (matrix);
-
-  return matrix;
-}
-
-/**
- * clutter_matrix_init_from_array:
- * @matrix: a #ClutterMatrix
- * @values: (array fixed-size=16): a C array of 16 floating point values,
- *   representing a 4x4 matrix, with column-major order
- *
- * Initializes @matrix with the contents of a C array of floating point
- * values.
- *
- * Return value: (transfer none): the initialized #ClutterMatrix
- *
- * Since: 1.12
- */
-ClutterMatrix *
-clutter_matrix_init_from_array (ClutterMatrix *matrix,
-                                const float    values[16])
-{
-  cogl_matrix_init_from_array (matrix, values);
-
-  return matrix;
-}
-
-/**
- * clutter_matrix_init_from_matrix:
- * @a: the #ClutterMatrix to initialize
- * @b: the #ClutterMatrix to copy
- *
- * Initializes the #ClutterMatrix @a with the contents of the
- * #ClutterMatrix @b.
- *
- * Return value: (transfer none): the initialized #ClutterMatrix
- *
- * Since: 1.12
- */
-ClutterMatrix *
-clutter_matrix_init_from_matrix (ClutterMatrix       *a,
-                                 const ClutterMatrix *b)
-{
-  return memcpy (a, b, sizeof (ClutterMatrix));
-}
diff --git a/clutter/clutter/clutter-clone.c b/clutter/clutter/clutter-clone.c
index a546d4c0680aca276a33600ff6baf32a2fafb114..86f124e6da336a2e3e988fc7c9f416c437ccedc5 100644
--- a/clutter/clutter/clutter-clone.c
+++ b/clutter/clutter/clutter-clone.c
@@ -121,20 +121,17 @@ clutter_clone_get_preferred_height (ClutterActor *self,
 }
 
 static void
-clutter_clone_apply_transform (ClutterActor *self, CoglMatrix *matrix)
+clutter_clone_apply_transform (ClutterActor      *self,
+                               graphene_matrix_t *matrix)
 {
   ClutterClonePrivate *priv = CLUTTER_CLONE (self)->priv;
 
-  /* First chain up and apply all the standard ClutterActor
-   * transformations... */
-  CLUTTER_ACTOR_CLASS (clutter_clone_parent_class)->apply_transform (self,
-                                                                     matrix);
 
-  /* if we don't have a source, nothing else to do */
-  if (priv->clone_source == NULL)
-    return;
+  if (priv->clone_source)
+    graphene_matrix_scale (matrix, priv->x_scale, priv->y_scale, 1.f);
 
-  cogl_matrix_scale (matrix, priv->x_scale, priv->y_scale, 1.f);
+  CLUTTER_ACTOR_CLASS (clutter_clone_parent_class)->apply_transform (self,
+                                                                     matrix);
 }
 
 static void
diff --git a/clutter/clutter/clutter-graphene.c b/clutter/clutter/clutter-graphene.c
index d1c447a5e58f77cf7369b2c21c9e5685fd3cc1ad..409c189b07bc3f76ee3cca1e34fb25637e3568ba 100644
--- a/clutter/clutter/clutter-graphene.c
+++ b/clutter/clutter/clutter-graphene.c
@@ -29,6 +29,23 @@
 #include "clutter-private.h"
 #include "clutter-types.h"
 
+static gboolean
+graphene_matrix_progress (const GValue *a,
+                          const GValue *b,
+                          double        progress,
+                          GValue       *retval)
+{
+  const graphene_matrix_t *am = g_value_get_boxed (a);
+  const graphene_matrix_t *bm = g_value_get_boxed (b);
+  graphene_matrix_t res;
+
+  graphene_matrix_interpolate (am, bm, progress, &res);
+
+  g_value_set_boxed (retval, &res);
+
+  return TRUE;
+}
+
 static gboolean
 graphene_point_progress (const GValue *a,
                          const GValue *b,
@@ -100,6 +117,8 @@ graphene_size_progress (const GValue *a,
 void
 clutter_graphene_init (void)
 {
+  clutter_interval_register_progress_func (GRAPHENE_TYPE_MATRIX,
+                                           graphene_matrix_progress);
   clutter_interval_register_progress_func (GRAPHENE_TYPE_POINT,
                                            graphene_point_progress);
   clutter_interval_register_progress_func (GRAPHENE_TYPE_POINT3D,
diff --git a/clutter/clutter/clutter-offscreen-effect.c b/clutter/clutter/clutter-offscreen-effect.c
index 40bb5f8cc6c8b12c8fda4edbfb9d487f115acf7c..129d7e6f4b0dd65f51fd60225399e1edb8700565 100644
--- a/clutter/clutter/clutter-offscreen-effect.c
+++ b/clutter/clutter/clutter-offscreen-effect.c
@@ -258,7 +258,7 @@ clutter_offscreen_effect_pre_paint (ClutterEffect       *effect,
   ClutterOffscreenEffectPrivate *priv = self->priv;
   ClutterActorBox raw_box, box;
   ClutterActor *stage;
-  CoglMatrix projection, old_modelview, modelview;
+  graphene_matrix_t projection, old_modelview, modelview;
   const ClutterPaintVolume *volume;
   CoglColor transparent;
   gfloat stage_width, stage_height;
@@ -427,7 +427,6 @@ clutter_offscreen_effect_paint_texture (ClutterOffscreenEffect *effect,
   ClutterOffscreenEffectPrivate *priv = effect->priv;
   CoglFramebuffer *framebuffer =
     clutter_paint_context_get_framebuffer (paint_context);
-  CoglMatrix modelview;
   float resource_scale;
 
   cogl_framebuffer_push_matrix (framebuffer);
@@ -435,21 +434,18 @@ clutter_offscreen_effect_paint_texture (ClutterOffscreenEffect *effect,
   /* The current modelview matrix is *almost* perfect already. It's only
    * missing a correction for the expanded FBO and offset rendering within...
    */
-  cogl_framebuffer_get_modelview_matrix (framebuffer, &modelview);
-
   resource_scale = clutter_actor_get_resource_scale (priv->actor);
 
   if (resource_scale != 1.0f)
     {
       float paint_scale = 1.0f / resource_scale;
-      cogl_matrix_scale (&modelview, paint_scale, paint_scale, 1);
+      cogl_framebuffer_scale (framebuffer, paint_scale, paint_scale, 1.f);
     }
 
-  cogl_matrix_translate (&modelview,
-                         priv->fbo_offset_x,
-                         priv->fbo_offset_y,
-                         0.0f);
-  cogl_framebuffer_set_modelview_matrix (framebuffer, &modelview);
+  cogl_framebuffer_translate (framebuffer,
+                              priv->fbo_offset_x,
+                              priv->fbo_offset_y,
+                              0.0f);
 
   /* paint the target material; this is virtualized for
    * sub-classes that require special hand-holding
diff --git a/clutter/clutter/clutter-paint-node-private.h b/clutter/clutter/clutter-paint-node-private.h
index faf5df23cf3787056b09d3790151a3de3f7d0267..a7ee1b4bd9480cafa2b74378830807dd837b1645 100644
--- a/clutter/clutter/clutter-paint-node-private.h
+++ b/clutter/clutter/clutter-paint-node-private.h
@@ -111,7 +111,7 @@ void                    _clutter_paint_operation_paint_primitive        (const C
 void                    _clutter_paint_node_init_types                  (void);
 gpointer                _clutter_paint_node_create                      (GType gtype);
 
-ClutterPaintNode *      _clutter_transform_node_new                     (const CoglMatrix            *matrix);
+ClutterPaintNode *      _clutter_transform_node_new                     (const graphene_matrix_t     *matrix);
 ClutterPaintNode *      _clutter_dummy_node_new                         (ClutterActor                *actor,
                                                                          CoglFramebuffer             *framebuffer);
 
diff --git a/clutter/clutter/clutter-paint-nodes.c b/clutter/clutter/clutter-paint-nodes.c
index 6301661da14530ca0ee6baaae8767d2694acfff4..3fb750dbcd0fbcea4a3094aa0def3669a3402b4a 100644
--- a/clutter/clutter/clutter-paint-nodes.c
+++ b/clutter/clutter/clutter-paint-nodes.c
@@ -191,7 +191,7 @@ struct _ClutterTransformNode
 {
   ClutterPaintNode parent_instance;
 
-  CoglMatrix transform;
+  graphene_matrix_t transform;
 };
 
 struct _ClutterTransformNodeClass
@@ -238,7 +238,7 @@ clutter_transform_node_class_init (ClutterTransformNodeClass *klass)
 static void
 clutter_transform_node_init (ClutterTransformNode *self)
 {
-  cogl_matrix_init_identity (&self->transform);
+  graphene_matrix_init_identity (&self->transform);
 }
 
 /*
@@ -249,13 +249,13 @@ clutter_transform_node_init (ClutterTransformNode *self)
  *   Use clutter_paint_node_unref() when done.
  */
 ClutterPaintNode *
-clutter_transform_node_new (const CoglMatrix *transform)
+clutter_transform_node_new (const graphene_matrix_t *transform)
 {
   ClutterTransformNode *res;
 
   res = _clutter_paint_node_create (CLUTTER_TYPE_TRANSFORM_NODE);
   if (transform)
-    res->transform = *transform;
+    graphene_matrix_init_from_matrix (&res->transform, transform);
 
   return (ClutterPaintNode *) res;
 }
@@ -1226,7 +1226,7 @@ struct _ClutterLayerNode
 
   cairo_rectangle_t viewport;
 
-  CoglMatrix projection;
+  graphene_matrix_t projection;
 
   float fbo_width;
   float fbo_height;
@@ -1250,7 +1250,7 @@ clutter_layer_node_pre_draw (ClutterPaintNode *node,
 {
   ClutterLayerNode *lnode = (ClutterLayerNode *) node;
   CoglFramebuffer *framebuffer;
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
 
   /* if we were unable to create an offscreen buffer for this node, then
    * we simply ignore it
@@ -1381,7 +1381,7 @@ clutter_layer_node_class_init (ClutterLayerNodeClass *klass)
 static void
 clutter_layer_node_init (ClutterLayerNode *self)
 {
-  cogl_matrix_init_identity (&self->projection);
+  graphene_matrix_init_identity (&self->projection);
 }
 
 /*
@@ -1404,7 +1404,7 @@ clutter_layer_node_init (ClutterLayerNode *self)
  * Since: 1.10
  */
 ClutterPaintNode *
-clutter_layer_node_new (const CoglMatrix        *projection,
+clutter_layer_node_new (const graphene_matrix_t *projection,
                         const cairo_rectangle_t *viewport,
                         float                    width,
                         float                    height,
diff --git a/clutter/clutter/clutter-paint-nodes.h b/clutter/clutter/clutter-paint-nodes.h
index 235f4bc4566a699ac879c4ecbc59e518b35daf5d..2e81c2b5df2e6b6867295ed320ddd277b79d30a3 100644
--- a/clutter/clutter/clutter-paint-nodes.h
+++ b/clutter/clutter/clutter-paint-nodes.h
@@ -202,7 +202,7 @@ CLUTTER_EXPORT
 GType clutter_layer_node_get_type (void) G_GNUC_CONST;
 
 CLUTTER_EXPORT
-ClutterPaintNode *      clutter_layer_node_new          (const CoglMatrix        *projection,
+ClutterPaintNode *      clutter_layer_node_new          (const graphene_matrix_t *projection,
                                                          const cairo_rectangle_t *viewport,
                                                          float                    width,
                                                          float                    height,
@@ -228,7 +228,7 @@ CLUTTER_EXPORT
 GType clutter_transform_node_get_type (void) G_GNUC_CONST;
 
 CLUTTER_EXPORT
-ClutterPaintNode *      clutter_transform_node_new          (const CoglMatrix *projection);
+ClutterPaintNode *      clutter_transform_node_new          (const graphene_matrix_t *projection);
 
 G_END_DECLS
 
diff --git a/clutter/clutter/clutter-paint-volume-private.h b/clutter/clutter/clutter-paint-volume-private.h
index 6a3f53428d2491c5820c7672330cc1dbac1032e1..48524f4223aecdc878db5d10775f3bbf175811dd 100644
--- a/clutter/clutter/clutter-paint-volume-private.h
+++ b/clutter/clutter/clutter-paint-volume-private.h
@@ -111,12 +111,12 @@ void                _clutter_paint_volume_set_from_volume      (ClutterPaintVolu
                                                                 const ClutterPaintVolume *src);
 
 void                _clutter_paint_volume_complete             (ClutterPaintVolume *pv);
-void                _clutter_paint_volume_transform            (ClutterPaintVolume *pv,
-                                                                const CoglMatrix *matrix);
-void                _clutter_paint_volume_project              (ClutterPaintVolume *pv,
-                                                                const CoglMatrix   *modelview,
-                                                                const CoglMatrix   *projection,
-                                                                const float        *viewport);
+void                _clutter_paint_volume_transform            (ClutterPaintVolume      *pv,
+                                                                const graphene_matrix_t *matrix);
+void                _clutter_paint_volume_project              (ClutterPaintVolume      *pv,
+                                                                const graphene_matrix_t *modelview,
+                                                                const graphene_matrix_t *projection,
+                                                                const float             *viewport);
 void                _clutter_paint_volume_get_bounding_box     (ClutterPaintVolume *pv,
                                                                 ClutterActorBox    *box);
 void                _clutter_paint_volume_axis_align           (ClutterPaintVolume *pv);
diff --git a/clutter/clutter/clutter-paint-volume.c b/clutter/clutter/clutter-paint-volume.c
index 3facd71cfcaa1a8bb9a0f56559f45b44c9d37c94..c78bfb6c951933e0c2484a0844947befd59c3e51 100644
--- a/clutter/clutter/clutter-paint-volume.c
+++ b/clutter/clutter/clutter-paint-volume.c
@@ -808,8 +808,8 @@ _clutter_paint_volume_get_bounding_box (ClutterPaintVolume *pv,
 
 void
 _clutter_paint_volume_project (ClutterPaintVolume *pv,
-                               const CoglMatrix *modelview,
-                               const CoglMatrix *projection,
+                               const graphene_matrix_t *modelview,
+                               const graphene_matrix_t *projection,
                                const float *viewport)
 {
   int transform_count;
@@ -849,7 +849,7 @@ _clutter_paint_volume_project (ClutterPaintVolume *pv,
 
 void
 _clutter_paint_volume_transform (ClutterPaintVolume *pv,
-                                 const CoglMatrix *matrix)
+                                 const graphene_matrix_t *matrix)
 {
   int transform_count;
 
@@ -857,11 +857,11 @@ _clutter_paint_volume_transform (ClutterPaintVolume *pv,
     {
       gfloat w = 1;
       /* Just transform the origin */
-      cogl_matrix_transform_point (matrix,
-                                   &pv->vertices[0].x,
-                                   &pv->vertices[0].y,
-                                   &pv->vertices[0].z,
-                                   &w);
+      cogl_graphene_matrix_project_point (matrix,
+                                          &pv->vertices[0].x,
+                                          &pv->vertices[0].y,
+                                          &pv->vertices[0].z,
+                                          &w);
       return;
     }
 
@@ -876,13 +876,13 @@ _clutter_paint_volume_transform (ClutterPaintVolume *pv,
   else
     transform_count = 8;
 
-  cogl_matrix_transform_points (matrix,
-                                3,
-                                sizeof (graphene_point3d_t),
-                                pv->vertices,
-                                sizeof (graphene_point3d_t),
-                                pv->vertices,
-                                transform_count);
+  cogl_graphene_matrix_transform_points (matrix,
+                                         3,
+                                         sizeof (graphene_point3d_t),
+                                         pv->vertices,
+                                         sizeof (graphene_point3d_t),
+                                         pv->vertices,
+                                         transform_count);
 
   pv->is_axis_aligned = FALSE;
 }
@@ -1130,13 +1130,13 @@ _clutter_paint_volume_get_stage_paint_box (ClutterPaintVolume *pv,
                                            ClutterActorBox *box)
 {
   ClutterPaintVolume projected_pv;
-  CoglMatrix modelview;
-  CoglMatrix projection;
+  graphene_matrix_t modelview;
+  graphene_matrix_t projection;
   float viewport[4];
 
   _clutter_paint_volume_copy_static (pv, &projected_pv);
 
-  cogl_matrix_init_identity (&modelview);
+  graphene_matrix_init_identity (&modelview);
 
   /* If the paint volume isn't already in eye coordinates... */
   if (pv->actor)
@@ -1181,7 +1181,7 @@ void
 _clutter_paint_volume_transform_relative (ClutterPaintVolume *pv,
                                           ClutterActor *relative_to_ancestor)
 {
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
   ClutterActor *actor;
 
   actor = pv->actor;
@@ -1190,7 +1190,7 @@ _clutter_paint_volume_transform_relative (ClutterPaintVolume *pv,
 
   _clutter_paint_volume_set_reference_actor (pv, relative_to_ancestor);
 
-  cogl_matrix_init_identity (&matrix);
+  graphene_matrix_init_identity (&matrix);
   _clutter_actor_apply_relative_transformation_matrix (actor,
                                                        relative_to_ancestor,
                                                       &matrix);
diff --git a/clutter/clutter/clutter-pan-action.c b/clutter/clutter/clutter-pan-action.c
index 6a42627e49b47fa77783eaef34cb46f70bb87327..5ad82ff6f50e362a8f10df375d92c76c78620022 100644
--- a/clutter/clutter/clutter-pan-action.c
+++ b/clutter/clutter/clutter-pan-action.c
@@ -354,12 +354,15 @@ clutter_pan_action_real_pan (ClutterPanAction *self,
                              gboolean          is_interpolated)
 {
   gfloat dx, dy;
-  ClutterMatrix transform;
+  graphene_matrix_t transform;
+  graphene_matrix_t translate;
 
   clutter_pan_action_get_constrained_motion_delta (self, 0, &dx, &dy);
 
   clutter_actor_get_child_transform (actor, &transform);
-  cogl_matrix_translate (&transform, dx, dy, 0.0f);
+  graphene_matrix_init_translate (&translate,
+                                  &GRAPHENE_POINT3D_INIT (dx, dy, 0.0f));
+  graphene_matrix_multiply (&translate, &transform, &transform);
   clutter_actor_set_child_transform (actor, &transform);
   return TRUE;
 }
diff --git a/clutter/clutter/clutter-private.h b/clutter/clutter/clutter-private.h
index e4119b99fab16b8921b4d21ec479d9da734236e6..b6a8e10409764ead95da586b4138c0bf3acec663 100644
--- a/clutter/clutter/clutter-private.h
+++ b/clutter/clutter/clutter-private.h
@@ -44,7 +44,6 @@
 G_BEGIN_DECLS
 
 typedef struct _ClutterMainContext      ClutterMainContext;
-typedef struct _ClutterVertex4          ClutterVertex4;
 
 #define CLUTTER_REGISTER_VALUE_TRANSFORM_TO(TYPE_TO,func)             { \
   g_value_register_transform_func (g_define_type_id, TYPE_TO, func);    \
@@ -211,8 +210,8 @@ void _clutter_run_repaint_functions (ClutterRepaintFlags flags);
 
 GType _clutter_layout_manager_get_child_meta_type (ClutterLayoutManager *manager);
 
-void  _clutter_util_fully_transform_vertices (const CoglMatrix         *modelview,
-                                              const CoglMatrix         *projection,
+void  _clutter_util_fully_transform_vertices (const graphene_matrix_t  *modelview,
+                                              const graphene_matrix_t  *projection,
                                               const float              *viewport,
                                               const graphene_point3d_t *vertices_in,
                                               graphene_point3d_t       *vertices_out,
@@ -240,44 +239,6 @@ gboolean _clutter_util_rectangle_intersection (const cairo_rectangle_int_t *src1
 gboolean clutter_util_rectangle_equal (const cairo_rectangle_int_t *src1,
                                        const cairo_rectangle_int_t *src2);
 
-
-struct _ClutterVertex4
-{
-  float x;
-  float y;
-  float z;
-  float w;
-};
-
-void
-_clutter_util_vertex4_interpolate (const ClutterVertex4 *a,
-                                   const ClutterVertex4 *b,
-                                   double                progress,
-                                   ClutterVertex4       *res);
-
-#define CLUTTER_MATRIX_INIT_IDENTITY { \
-  1.0f, 0.0f, 0.0f, 0.0f, \
-  0.0f, 1.0f, 0.0f, 0.0f, \
-  0.0f, 0.0f, 1.0f, 0.0f, \
-  0.0f, 0.0f, 0.0f, 1.0f, \
-}
-
-float   _clutter_util_matrix_determinant        (const ClutterMatrix *matrix);
-
-void    _clutter_util_matrix_skew_xy            (ClutterMatrix *matrix,
-                                                 float          factor);
-void    _clutter_util_matrix_skew_xz            (ClutterMatrix *matrix,
-                                                 float          factor);
-void    _clutter_util_matrix_skew_yz            (ClutterMatrix *matrix,
-                                                 float          factor);
-
-gboolean        _clutter_util_matrix_decompose  (const ClutterMatrix *src,
-                                                 graphene_point3d_t  *scale_p,
-                                                 float                shear_p[3],
-                                                 graphene_point3d_t  *rotate_p,
-                                                 graphene_point3d_t  *translate_p,
-                                                 ClutterVertex4      *perspective_p);
-
 CLUTTER_EXPORT
 PangoDirection _clutter_pango_unichar_direction (gunichar ch);
 
diff --git a/clutter/clutter/clutter-scroll-actor.c b/clutter/clutter/clutter-scroll-actor.c
index 661654b75af2ad4a9e2a4e9d05aed9fa05865a9a..9ef63b23a2024f85adf851991b49bf9c6524cf43 100644
--- a/clutter/clutter/clutter-scroll-actor.c
+++ b/clutter/clutter/clutter-scroll-actor.c
@@ -99,7 +99,7 @@ clutter_scroll_actor_set_scroll_to_internal (ClutterScrollActor     *self,
 {
   ClutterScrollActorPrivate *priv = self->priv;
   ClutterActor *actor = CLUTTER_ACTOR (self);
-  ClutterMatrix m = CLUTTER_MATRIX_INIT_IDENTITY;
+  graphene_matrix_t m;
   float dx, dy;
 
   if (graphene_point_equal (&priv->scroll_to, point))
@@ -120,7 +120,8 @@ clutter_scroll_actor_set_scroll_to_internal (ClutterScrollActor     *self,
   else
     dy = 0.f;
 
-  cogl_matrix_translate (&m, dx, dy, 0.f);
+  graphene_matrix_init_translate (&m,
+                                  &GRAPHENE_POINT3D_INIT (dx, dy, 0.f));
   clutter_actor_set_child_transform (actor, &m);
 }
 
diff --git a/clutter/clutter/clutter-shader-effect.c b/clutter/clutter/clutter-shader-effect.c
index be15d32b101b61f556a0bccaa3186c2af0b64f58..92526b47ee9677fe095717881fcb0f85cd463c24 100644
--- a/clutter/clutter/clutter-shader-effect.c
+++ b/clutter/clutter/clutter-shader-effect.c
@@ -824,9 +824,12 @@ add_uniform:
  * Finally, a uniform named "map" and containing a matrix can be set using:
  *
  * |[<!-- language="C" -->
+ *   float v[16];
+ *
+ *   cogl_matrix_to_float (&matrix, v);
  *   clutter_shader_effect_set_uniform (effect, "map",
- *                                      CLUTTER_TYPE_SHADER_MATRIX, 1,
- *                                      cogl_matrix_get_array (&matrix));
+ *                                      CLUTTER_TYPE_SHADER_MATRIX,
+ *                                      1, v);
  * ]|
  *
  * Since: 1.4
diff --git a/clutter/clutter/clutter-stage-private.h b/clutter/clutter/clutter-stage-private.h
index f2a371c5ef8e14263233a2681717051c28d868e7..ef5ce1da492463813c830b985eb8c648ee3ff222 100644
--- a/clutter/clutter/clutter-stage-private.h
+++ b/clutter/clutter/clutter-stage-private.h
@@ -55,7 +55,7 @@ void                _clutter_stage_set_window            (ClutterStage
 CLUTTER_EXPORT
 ClutterStageWindow *_clutter_stage_get_window            (ClutterStage          *stage);
 void                _clutter_stage_get_projection_matrix (ClutterStage          *stage,
-                                                          CoglMatrix            *projection);
+                                                          graphene_matrix_t     *projection);
 void                _clutter_stage_dirty_projection      (ClutterStage          *stage);
 void                _clutter_stage_get_viewport          (ClutterStage          *stage,
                                                           float                 *x,
diff --git a/clutter/clutter/clutter-stage-view-private.h b/clutter/clutter/clutter-stage-view-private.h
index e4132202e41e24e28ee4353c3d60ec50a6f740b9..d98fb463af4698dacff5bbfe81a323a286414e01 100644
--- a/clutter/clutter/clutter-stage-view-private.h
+++ b/clutter/clutter/clutter-stage-view-private.h
@@ -41,8 +41,8 @@ gboolean clutter_stage_view_is_dirty_projection (ClutterStageView *view);
 
 void clutter_stage_view_invalidate_projection (ClutterStageView *view);
 
-void clutter_stage_view_set_projection (ClutterStageView *view,
-                                        const CoglMatrix *matrix);
+void clutter_stage_view_set_projection (ClutterStageView        *view,
+                                        const graphene_matrix_t *matrix);
 
 void clutter_stage_view_add_redraw_clip (ClutterStageView            *view,
                                          const cairo_rectangle_int_t *clip);
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index 00a4d5ad1461c1fdc0cc819c72257b4f9a07eaad..6e505bd07e7820e89890a3779b5e68aef6e84552 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -213,7 +213,7 @@ paint_transformed_framebuffer (ClutterStageView     *view,
                                CoglFramebuffer      *dst_framebuffer,
                                const cairo_region_t *redraw_clip)
 {
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
   unsigned int n_rectangles, i;
   int dst_width, dst_height;
   cairo_rectangle_int_t view_layout;
@@ -236,13 +236,14 @@ paint_transformed_framebuffer (ClutterStageView     *view,
 
   cogl_framebuffer_push_matrix (dst_framebuffer);
 
-  cogl_matrix_init_identity (&matrix);
-  cogl_matrix_scale (&matrix,
-                     1.0 / (dst_width / 2.0),
-                     -1.0 / (dst_height / 2.0), 0);
-  cogl_matrix_translate (&matrix,
-                         -(dst_width / 2.0),
-                         -(dst_height / 2.0), 0);
+  graphene_matrix_init_translate (&matrix,
+                                  &GRAPHENE_POINT3D_INIT (-dst_width / 2.0,
+                                                          -dst_height / 2.0,
+                                                          0.f));
+  graphene_matrix_scale (&matrix,
+                         1.0 / (dst_width / 2.0),
+                         -1.0 / (dst_height / 2.0),
+                         0.f);
   cogl_framebuffer_set_projection_matrix (dst_framebuffer, &matrix);
   cogl_framebuffer_set_viewport (dst_framebuffer,
                                  0, 0, dst_width, dst_height);
@@ -882,8 +883,8 @@ clutter_stage_view_invalidate_projection (ClutterStageView *view)
 }
 
 void
-clutter_stage_view_set_projection (ClutterStageView *view,
-                                   const CoglMatrix *matrix)
+clutter_stage_view_set_projection (ClutterStageView        *view,
+                                   const graphene_matrix_t *matrix)
 {
   ClutterStageViewPrivate *priv =
     clutter_stage_view_get_instance_private (view);
@@ -895,8 +896,8 @@ clutter_stage_view_set_projection (ClutterStageView *view,
 }
 
 void
-clutter_stage_view_get_offscreen_transformation_matrix (ClutterStageView *view,
-                                                        CoglMatrix       *matrix)
+clutter_stage_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
+                                                        graphene_matrix_t *matrix)
 {
   ClutterStageViewClass *view_class = CLUTTER_STAGE_VIEW_GET_CLASS (view);
 
@@ -984,10 +985,10 @@ clutter_stage_view_take_redraw_clip (ClutterStageView *view)
 }
 
 static void
-clutter_stage_default_get_offscreen_transformation_matrix (ClutterStageView *view,
-                                                           CoglMatrix       *matrix)
+clutter_stage_default_get_offscreen_transformation_matrix (ClutterStageView  *view,
+                                                           graphene_matrix_t *matrix)
 {
-  cogl_matrix_init_identity (matrix);
+  graphene_matrix_init_identity (matrix);
 }
 
 void
diff --git a/clutter/clutter/clutter-stage-view.h b/clutter/clutter/clutter-stage-view.h
index 4c54553ed61eaa17a83264495ae9aba09b0d3635..3f2ef8af94d3637c684ef5d787d413f36de968c2 100644
--- a/clutter/clutter/clutter-stage-view.h
+++ b/clutter/clutter/clutter-stage-view.h
@@ -42,8 +42,8 @@ struct _ClutterStageViewClass
   void (* setup_offscreen_blit_pipeline) (ClutterStageView *view,
                                           CoglPipeline     *pipeline);
 
-  void (* get_offscreen_transformation_matrix) (ClutterStageView *view,
-                                                CoglMatrix       *matrix);
+  void (* get_offscreen_transformation_matrix) (ClutterStageView  *view,
+                                                graphene_matrix_t *matrix);
 
   void (* transform_rect_to_onscreen) (ClutterStageView            *view,
                                        const cairo_rectangle_int_t *src_rect,
@@ -70,8 +70,8 @@ CLUTTER_EXPORT
 float clutter_stage_view_get_scale (ClutterStageView *view);
 
 CLUTTER_EXPORT
-void clutter_stage_view_get_offscreen_transformation_matrix (ClutterStageView *view,
-                                                             CoglMatrix       *matrix);
+void clutter_stage_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
+                                                             graphene_matrix_t *matrix);
 
 CLUTTER_EXPORT
 ClutterFrameClock * clutter_stage_view_get_frame_clock (ClutterStageView *view);
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index 10ce401de0e4ef998127dcf098e7ad4decfb5567..c9680388b6fdca3de3dafeac84abaf71a8830fe8 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -103,9 +103,9 @@ struct _ClutterStagePrivate
   ClutterStageWindow *impl;
 
   ClutterPerspective perspective;
-  CoglMatrix projection;
-  CoglMatrix inverse_projection;
-  CoglMatrix view;
+  graphene_matrix_t projection;
+  graphene_matrix_t inverse_projection;
+  graphene_matrix_t view;
   float viewport[4];
 
   gchar *title;
@@ -662,8 +662,8 @@ static void
 _cogl_util_get_eye_planes_for_screen_poly (float *polygon,
                                            int n_vertices,
                                            float *viewport,
-                                           const CoglMatrix *projection,
-                                           const CoglMatrix *inverse_project,
+                                           const graphene_matrix_t *projection,
+                                           const graphene_matrix_t *inverse_project,
                                            ClutterPlane *planes)
 {
   float Wc;
@@ -673,6 +673,7 @@ _cogl_util_get_eye_planes_for_screen_poly (float *polygon,
   Vector4 *poly;
   graphene_vec3_t b;
   graphene_vec3_t c;
+  float zw, ww;
   int count;
 
   tmp_poly = g_alloca (sizeof (Vector4) * n_vertices * 2);
@@ -693,7 +694,9 @@ _cogl_util_get_eye_planes_for_screen_poly (float *polygon,
    * frustum; coordinates range from [-Wc,Wc] left to right on the
    * x-axis and [Wc,-Wc] top to bottom on the y-axis.
    */
-  Wc = DEPTH * projection->wz + projection->ww;
+  zw = graphene_matrix_get_value (projection, 2, 3);
+  ww = graphene_matrix_get_value (projection, 3, 3);
+  Wc = DEPTH * zw + ww;
 
 #define CLIP_X(X) ((((float)X - viewport[0]) * (2.0 / viewport[2])) - 1) * Wc
 #define CLIP_Y(Y) ((((float)Y - viewport[1]) * (2.0 / viewport[3])) - 1) * -Wc
@@ -706,7 +709,7 @@ _cogl_util_get_eye_planes_for_screen_poly (float *polygon,
       tmp_poly[i].w = Wc;
     }
 
-  Wc = DEPTH * 2 * projection->wz + projection->ww;
+  Wc = DEPTH * 2 * zw + ww;
 
   /* FIXME: technically we don't need to project all of the points
    * twice, it would be enough project every other point since
@@ -722,13 +725,13 @@ _cogl_util_get_eye_planes_for_screen_poly (float *polygon,
 #undef CLIP_X
 #undef CLIP_Y
 
-  cogl_matrix_project_points (inverse_project,
-                              4,
-                              sizeof (Vector4),
-                              tmp_poly,
-                              sizeof (Vector4),
-                              tmp_poly,
-                              n_vertices * 2);
+  cogl_graphene_matrix_project_points (inverse_project,
+                                       4,
+                                       sizeof (Vector4),
+                                       tmp_poly,
+                                       sizeof (Vector4),
+                                       tmp_poly,
+                                       n_vertices * 2);
 
   /* XXX: It's quite ugly that we end up with these casts between
    * Vector4 types and CoglVector3s, it might be better if the
@@ -1575,15 +1578,14 @@ _clutter_stage_do_pick (ClutterStage   *stage,
 }
 
 static void
-clutter_stage_real_apply_transform (ClutterActor *stage,
-                                    CoglMatrix   *matrix)
+clutter_stage_real_apply_transform (ClutterActor      *stage,
+                                    graphene_matrix_t *matrix)
 {
   ClutterStagePrivate *priv = CLUTTER_STAGE (stage)->priv;
 
   /* FIXME: we probably shouldn't be explicitly resetting the matrix
    * here... */
-  cogl_matrix_init_identity (matrix);
-  cogl_matrix_multiply (matrix, matrix, &priv->view);
+  graphene_matrix_init_from_matrix (matrix, &priv->view);
 }
 
 static void
@@ -2061,14 +2063,13 @@ clutter_stage_set_perspective (ClutterStage       *stage,
 
   priv->perspective = *perspective;
 
-  cogl_matrix_init_identity (&priv->projection);
-  cogl_matrix_perspective (&priv->projection,
-                           priv->perspective.fovy,
-                           priv->perspective.aspect,
-                           priv->perspective.z_near,
-                           priv->perspective.z_far);
-  cogl_matrix_get_inverse (&priv->projection,
-                           &priv->inverse_projection);
+  graphene_matrix_init_perspective (&priv->projection,
+                                    priv->perspective.fovy,
+                                    priv->perspective.aspect,
+                                    priv->perspective.z_near,
+                                    priv->perspective.z_far);
+  cogl_graphene_matrix_get_inverse (&priv->projection,
+                                    &priv->inverse_projection);
 
   _clutter_stage_dirty_projection (stage);
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
@@ -2095,7 +2096,7 @@ clutter_stage_get_perspective (ClutterStage       *stage,
 /*
  * clutter_stage_get_projection_matrix:
  * @stage: A #ClutterStage
- * @projection: return location for a #CoglMatrix representing the
+ * @projection: return location for a #graphene_matrix_t representing the
  *              perspective projection applied to actors on the given
  *              @stage.
  *
@@ -2105,8 +2106,8 @@ clutter_stage_get_perspective (ClutterStage       *stage,
  * Since: 1.6
  */
 void
-_clutter_stage_get_projection_matrix (ClutterStage *stage,
-                                      CoglMatrix *projection)
+_clutter_stage_get_projection_matrix (ClutterStage      *stage,
+                                      graphene_matrix_t *projection)
 {
   g_return_if_fail (CLUTTER_IS_STAGE (stage));
   g_return_if_fail (projection != NULL);
@@ -2752,6 +2753,40 @@ calculate_z_translation (float z_near)
        + z_near;
 }
 
+static void
+view_2d_in_perspective (graphene_matrix_t *matrix,
+                        float              fov_y,
+                        float              aspect,
+                        float              z_near,
+                        float              z_2d,
+                        float              width_2d,
+                        float              height_2d)
+{
+  float top = z_near * tan (fov_y * G_PI / 360.0);
+  float left = -top * aspect;
+  float right = top * aspect;
+  float bottom = -top;
+
+  float left_2d_plane = left / z_near * z_2d;
+  float right_2d_plane = right / z_near * z_2d;
+  float bottom_2d_plane = bottom / z_near * z_2d;
+  float top_2d_plane = top / z_near * z_2d;
+
+  float width_2d_start = right_2d_plane - left_2d_plane;
+  float height_2d_start = top_2d_plane - bottom_2d_plane;
+
+  /* Factors to scale from framebuffer geometry to frustum
+   * cross-section geometry. */
+  float width_scale = width_2d_start / width_2d;
+  float height_scale = height_2d_start / height_2d;
+
+  graphene_matrix_init_scale (matrix, width_scale, -height_scale, width_scale);
+  graphene_matrix_translate (matrix,
+                             &GRAPHENE_POINT3D_INIT (left_2d_plane,
+                                                     top_2d_plane,
+                                                     -z_2d));
+}
+
 static void
 clutter_stage_update_view_perspective (ClutterStage *stage)
 {
@@ -2776,14 +2811,13 @@ clutter_stage_update_view_perspective (ClutterStage *stage)
 
   clutter_stage_set_perspective (stage, &perspective);
 
-  cogl_matrix_init_identity (&priv->view);
-  cogl_matrix_view_2d_in_perspective (&priv->view,
-                                      perspective.fovy,
-                                      perspective.aspect,
-                                      perspective.z_near,
-                                      z_2d,
-                                      priv->viewport[2],
-                                      priv->viewport[3]);
+  view_2d_in_perspective (&priv->view,
+                          perspective.fovy,
+                          perspective.aspect,
+                          perspective.z_near,
+                          z_2d,
+                          priv->viewport[2],
+                          priv->viewport[3]);
 
   clutter_actor_invalidate_transform (CLUTTER_ACTOR (stage));
 }
diff --git a/clutter/clutter/clutter-types.h b/clutter/clutter/clutter-types.h
index b9825327558d1ef2caa15c13b8fa816d4fce1628..1453eaaadfd38ba5cf55b930e82cde777601f1ea 100644
--- a/clutter/clutter/clutter-types.h
+++ b/clutter/clutter/clutter-types.h
@@ -40,7 +40,6 @@ G_BEGIN_DECLS
 #define CLUTTER_TYPE_ACTOR_BOX          (clutter_actor_box_get_type ())
 #define CLUTTER_TYPE_KNOT               (clutter_knot_get_type ())
 #define CLUTTER_TYPE_MARGIN             (clutter_margin_get_type ())
-#define CLUTTER_TYPE_MATRIX             (clutter_matrix_get_type ())
 #define CLUTTER_TYPE_PAINT_VOLUME       (clutter_paint_volume_get_type ())
 #define CLUTTER_TYPE_PERSPECTIVE        (clutter_perspective_get_type ())
 
@@ -87,8 +86,6 @@ typedef struct _ClutterVirtualInputDevice       ClutterVirtualInputDevice;
 typedef struct _ClutterInputMethod              ClutterInputMethod;
 typedef struct _ClutterInputFocus               ClutterInputFocus;
 
-typedef CoglMatrix                              ClutterMatrix;
-
 typedef union _ClutterEvent                     ClutterEvent;
 
 /**
@@ -432,22 +429,6 @@ CLUTTER_EXPORT
 void clutter_interval_register_progress_func (GType               value_type,
                                               ClutterProgressFunc func);
 
-CLUTTER_EXPORT
-GType clutter_matrix_get_type (void) G_GNUC_CONST;
-
-CLUTTER_EXPORT
-ClutterMatrix * clutter_matrix_alloc            (void);
-CLUTTER_EXPORT
-ClutterMatrix * clutter_matrix_init_identity    (ClutterMatrix       *matrix);
-CLUTTER_EXPORT
-ClutterMatrix * clutter_matrix_init_from_array  (ClutterMatrix       *matrix,
-                                                 const float          values[16]);
-CLUTTER_EXPORT
-ClutterMatrix * clutter_matrix_init_from_matrix (ClutterMatrix       *a,
-                                                 const ClutterMatrix *b);
-CLUTTER_EXPORT
-void            clutter_matrix_free             (ClutterMatrix       *matrix);
-
 G_END_DECLS
 
 #endif /* __CLUTTER_TYPES_H__ */
diff --git a/clutter/clutter/clutter-util.c b/clutter/clutter/clutter-util.c
index d386b1db8ee8965534c4ed8dab132c4653793583..f598332c8f7da6c0a3974ee1571cb9b5cc063c90 100644
--- a/clutter/clutter/clutter-util.c
+++ b/clutter/clutter/clutter-util.c
@@ -49,15 +49,23 @@
 
 #define ROUND_TO_256THS(x) (roundf ((x) * 256) / 256)
 
+typedef struct
+{
+  float x;
+  float y;
+  float z;
+  float w;
+} ClutterVertex4;
+
 void
-_clutter_util_fully_transform_vertices (const CoglMatrix *modelview,
-                                        const CoglMatrix *projection,
-                                        const float *viewport,
+_clutter_util_fully_transform_vertices (const graphene_matrix_t  *modelview,
+                                        const graphene_matrix_t  *projection,
+                                        const float              *viewport,
                                         const graphene_point3d_t *vertices_in,
-                                        graphene_point3d_t *vertices_out,
-                                        int n_vertices)
+                                        graphene_point3d_t       *vertices_out,
+                                        int                       n_vertices)
 {
-  CoglMatrix modelview_projection;
+  graphene_matrix_t modelview_projection;
   ClutterVertex4 *vertices_tmp;
   int i;
 
@@ -66,34 +74,33 @@ _clutter_util_fully_transform_vertices (const CoglMatrix *modelview,
   if (n_vertices >= 4)
     {
       /* XXX: we should find a way to cache this per actor */
-      cogl_matrix_multiply (&modelview_projection,
-                            projection,
-                            modelview);
-      cogl_matrix_project_points (&modelview_projection,
-                                  3,
-                                  sizeof (graphene_point3d_t),
-                                  vertices_in,
-                                  sizeof (ClutterVertex4),
-                                  vertices_tmp,
-                                  n_vertices);
+      graphene_matrix_multiply (modelview, projection, &modelview_projection);
+
+      cogl_graphene_matrix_project_points (&modelview_projection,
+                                           3,
+                                           sizeof (graphene_point3d_t),
+                                           vertices_in,
+                                           sizeof (ClutterVertex4),
+                                           vertices_tmp,
+                                           n_vertices);
     }
   else
     {
-      cogl_matrix_transform_points (modelview,
-                                    3,
-                                    sizeof (graphene_point3d_t),
-                                    vertices_in,
-                                    sizeof (ClutterVertex4),
-                                    vertices_tmp,
-                                    n_vertices);
-
-      cogl_matrix_project_points (projection,
-                                  3,
-                                  sizeof (ClutterVertex4),
-                                  vertices_tmp,
-                                  sizeof (ClutterVertex4),
-                                  vertices_tmp,
-                                  n_vertices);
+      cogl_graphene_matrix_transform_points (modelview,
+                                             3,
+                                             sizeof (graphene_point3d_t),
+                                             vertices_in,
+                                             sizeof (ClutterVertex4),
+                                             vertices_tmp,
+                                             n_vertices);
+
+      cogl_graphene_matrix_project_points (projection,
+                                           3,
+                                           sizeof (ClutterVertex4),
+                                           vertices_tmp,
+                                           sizeof (ClutterVertex4),
+                                           vertices_tmp,
+                                           n_vertices);
     }
 
   for (i = 0; i < n_vertices; i++)
@@ -230,310 +237,6 @@ clutter_util_rectangle_equal (const cairo_rectangle_int_t *src1,
           (src1->height == src2->height));
 }
 
-float
-_clutter_util_matrix_determinant (const ClutterMatrix *matrix)
-{
-  return matrix->xw * matrix->yz * matrix->zy * matrix->wz
-       - matrix->xz * matrix->yw * matrix->zy * matrix->wz
-       - matrix->xw * matrix->yy * matrix->zz * matrix->wz
-       + matrix->xy * matrix->yw * matrix->zz * matrix->wz
-       + matrix->xz * matrix->yy * matrix->zw * matrix->wz
-       - matrix->xy * matrix->yz * matrix->zw * matrix->wz
-       - matrix->xw * matrix->yz * matrix->zx * matrix->wy
-       + matrix->xz * matrix->yw * matrix->zx * matrix->wy
-       + matrix->xw * matrix->yx * matrix->zz * matrix->wy
-       - matrix->xx * matrix->yw * matrix->zz * matrix->wy
-       - matrix->xz * matrix->yx * matrix->zw * matrix->wy
-       + matrix->xx * matrix->yz * matrix->zw * matrix->wy
-       + matrix->xw * matrix->yy * matrix->zx * matrix->wz
-       - matrix->xy * matrix->yw * matrix->zx * matrix->wz
-       - matrix->xw * matrix->yx * matrix->zy * matrix->wz
-       + matrix->xx * matrix->yw * matrix->zy * matrix->wz
-       + matrix->xy * matrix->yx * matrix->zw * matrix->wz
-       - matrix->xx * matrix->yy * matrix->zw * matrix->wz
-       - matrix->xz * matrix->yy * matrix->zx * matrix->ww
-       + matrix->xy * matrix->yz * matrix->zx * matrix->ww
-       + matrix->xz * matrix->yx * matrix->zy * matrix->ww
-       - matrix->xx * matrix->yz * matrix->zy * matrix->ww
-       - matrix->xy * matrix->yx * matrix->zz * matrix->ww
-       + matrix->xx * matrix->yy * matrix->zz * matrix->ww;
-}
-
-static void
-_clutter_util_matrix_transpose_vector4_transform (const ClutterMatrix  *matrix,
-                                                  const ClutterVertex4 *point,
-                                                  ClutterVertex4       *res)
-{
-  res->x = matrix->xx * point->x
-         + matrix->xy * point->y
-         + matrix->xz * point->z
-         + matrix->xw * point->w;
-
-  res->y = matrix->yx * point->x
-         + matrix->yy * point->y
-         + matrix->yz * point->z
-         + matrix->yw * point->w;
-
-  res->z = matrix->zx * point->x
-         + matrix->zy * point->y
-         + matrix->zz * point->z
-         + matrix->zw * point->w;
-
-  res->w = matrix->wz * point->x
-         + matrix->wy * point->w
-         + matrix->wz * point->z
-         + matrix->ww * point->w;
-}
-
-void
-_clutter_util_matrix_skew_xy (ClutterMatrix *matrix,
-                              float          factor)
-{
-  matrix->yx += matrix->xx * factor;
-  matrix->yy += matrix->xy * factor;
-  matrix->yz += matrix->xz * factor;
-  matrix->yw += matrix->xw * factor;
-}
-
-void
-_clutter_util_matrix_skew_xz (ClutterMatrix *matrix,
-                              float          factor)
-{
-  matrix->zx += matrix->xx * factor;
-  matrix->zy += matrix->xy * factor;
-  matrix->zz += matrix->xz * factor;
-  matrix->zw += matrix->xw * factor;
-}
-
-void
-_clutter_util_matrix_skew_yz (ClutterMatrix *matrix,
-                              float          factor)
-{
-  matrix->zx += matrix->yx * factor;
-  matrix->zy += matrix->yy * factor;
-  matrix->zz += matrix->yz * factor;
-  matrix->zw += matrix->yw * factor;
-}
-
-static void
-_clutter_util_vertex_combine (const graphene_point3d_t *a,
-                              const graphene_point3d_t *b,
-                              double                    ascl,
-                              double                    bscl,
-                              graphene_point3d_t       *res)
-{
-  res->x = (ascl * a->x) + (bscl * b->x);
-  res->y = (ascl * a->y) + (bscl * b->y);
-  res->z = (ascl * a->z) + (bscl * b->z);
-}
-
-void
-_clutter_util_vertex4_interpolate (const ClutterVertex4 *a,
-                                   const ClutterVertex4 *b,
-                                   double                progress,
-                                   ClutterVertex4       *res)
-{
-  res->x = a->x + (b->x - a->x) * progress;
-  res->y = a->y + (b->y - a->y) * progress;
-  res->z = a->z + (b->z - a->z) * progress;
-  res->w = a->w + (b->w - a->w) * progress;
-}
-
-/*< private >
- * clutter_util_matrix_decompose:
- * @src: the matrix to decompose
- * @scale_p: (out caller-allocates): return location for a vertex containing
- *   the scaling factors
- * @shear_p: (out) (array length=3): return location for an array of 3
- *   elements containing the skew factors (XY, XZ, and YZ respectively)
- * @rotate_p: (out caller-allocates): return location for a vertex containing
- *   the Euler angles
- * @translate_p: (out caller-allocates): return location for a vertex
- *   containing the translation vector
- * @perspective_p: (out caller-allocates: return location for a 4D vertex
- *   containing the perspective
- *
- * Decomposes a #ClutterMatrix into the transformations that compose it.
- *
- * This code is based on the matrix decomposition algorithm as published in
- * the CSS Transforms specification by the W3C CSS working group, available
- * at http://www.w3.org/TR/css3-transforms/.
- *
- * The algorithm, in turn, is based on the "unmatrix" method published in
- * "Graphics Gems II, edited by Jim Arvo", which is available at:
- * http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c
- *
- * Return value: %TRUE if the decomposition was successful, and %FALSE
- *   if the matrix is singular
- */
-gboolean
-_clutter_util_matrix_decompose (const ClutterMatrix *src,
-                                graphene_point3d_t  *scale_p,
-                                float                shear_p[3],
-                                graphene_point3d_t  *rotate_p,
-                                graphene_point3d_t  *translate_p,
-                                ClutterVertex4      *perspective_p)
-{
-  CoglMatrix matrix = *src;
-  CoglMatrix perspective;
-  ClutterVertex4 vertex_tmp;
-  graphene_point3d_t row[3], pdum;
-  int i, j;
-
-#define XY_SHEAR        0
-#define XZ_SHEAR        1
-#define YZ_SHEAR        2
-#define MAT(m,r,c)      ((float *)(m))[(c) * 4 + (r)]
-
-  /* normalize the matrix */
-  if (matrix.ww == 0.f)
-    return FALSE;
-
-  for (i = 0; i < 4; i++)
-    {
-      for (j = 0; j < 4; j++)
-        {
-          MAT (&matrix, j, i) /= MAT (&matrix, 3, 3);
-        }
-    }
-
-  /* perspective is used to solve for perspective, but it also provides
-   * an easy way to test for singularity of the upper 3x3 component
-   */
-  perspective = matrix;
-
-  /* transpose */
-  MAT (&perspective, 3, 0) = 0.f;
-  MAT (&perspective, 3, 1) = 0.f;
-  MAT (&perspective, 3, 2) = 0.f;
-  MAT (&perspective, 3, 3) = 1.f;
-
-  if (_clutter_util_matrix_determinant (&perspective) == 0.f)
-    return FALSE;
-
-  if (MAT (&matrix, 3, 0) != 0.f ||
-      MAT (&matrix, 3, 1) != 0.f ||
-      MAT (&matrix, 3, 2) != 0.f)
-    {
-      CoglMatrix perspective_inv;
-      ClutterVertex4 p;
-
-      vertex_tmp.x = MAT (&matrix, 3, 0);
-      vertex_tmp.y = MAT (&matrix, 3, 1);
-      vertex_tmp.z = MAT (&matrix, 3, 2);
-      vertex_tmp.w = MAT (&matrix, 3, 3);
-
-      /* solve the equation by inverting perspective... */
-      cogl_matrix_get_inverse (&perspective, &perspective_inv);
-
-      /* ... and multiplying vertex_tmp by the inverse */
-      _clutter_util_matrix_transpose_vector4_transform (&perspective_inv,
-                                                        &vertex_tmp,
-                                                        &p);
-
-      *perspective_p = p;
-
-      /* clear the perspective part */
-      MAT (&matrix, 3, 0) = 0.0f;
-      MAT (&matrix, 3, 1) = 0.0f;
-      MAT (&matrix, 3, 2) = 0.0f;
-      MAT (&matrix, 3, 3) = 1.0f;
-    }
-  else
-    {
-      /* no perspective */
-      perspective_p->x = 0.0f;
-      perspective_p->y = 0.0f;
-      perspective_p->z = 0.0f;
-      perspective_p->w = 1.0f;
-    }
-
-  /* translation */
-  translate_p->x = MAT (&matrix, 0, 3);
-  MAT (&matrix, 0, 3) = 0.f;
-  translate_p->y = MAT (&matrix, 1, 3);
-  MAT (&matrix, 1, 3) = 0.f;
-  translate_p->z = MAT (&matrix, 2, 3);
-  MAT (&matrix, 2, 3) = 0.f;
-
-  /* scale and shear; we split the upper 3x3 matrix into rows */
-  for (i = 0; i < 3; i++)
-    {
-      row[i].x = MAT (&matrix, i, 0);
-      row[i].y = MAT (&matrix, i, 1);
-      row[i].z = MAT (&matrix, i, 2);
-    }
-
-  /* compute scale.x and normalize the first row */
-  scale_p->x = graphene_point3d_length (&row[0]);
-  graphene_point3d_normalize (&row[0], &row[0]);
-
-  /* compute XY shear and make the second row orthogonal to the first */
-  shear_p[XY_SHEAR] = graphene_point3d_dot (&row[0], &row[1]);
-  _clutter_util_vertex_combine (&row[1], &row[0],
-                                1.0, -shear_p[XY_SHEAR],
-                                &row[1]);
-
-  /* compute the Y scale and normalize the second row */
-  scale_p->y = graphene_point3d_length (&row[1]);
-  graphene_point3d_normalize (&row[1], &row[1]);
-  shear_p[XY_SHEAR] /= scale_p->y;
-
-  /* compute XZ and YZ shears, orthogonalize the third row */
-  shear_p[XZ_SHEAR] = graphene_point3d_dot (&row[0], &row[2]);
-  _clutter_util_vertex_combine (&row[2], &row[0],
-                                1.0, -shear_p[XZ_SHEAR],
-                                &row[2]);
-
-  shear_p[YZ_SHEAR] = graphene_point3d_dot (&row[1], &row[2]);
-  _clutter_util_vertex_combine (&row[2], &row[1],
-                                1.0, -shear_p[YZ_SHEAR],
-                                &row[2]);
-
-  /* get the Z scale and normalize the third row*/
-  scale_p->z = graphene_point3d_length (&row[2]);
-  graphene_point3d_normalize (&row[2], &row[2]);
-  shear_p[XZ_SHEAR] /= scale_p->z;
-  shear_p[YZ_SHEAR] /= scale_p->z;
-
-  /* at this point, the matrix (inside row[]) is orthonormal.
-   * check for a coordinate system flip; if the determinant
-   * is -1, then negate the matrix and scaling factors
-   */
-  graphene_point3d_cross (&row[1], &row[2], &pdum);
-  if (graphene_point3d_dot (&row[0], &pdum) < 0.f)
-    {
-      scale_p->x *= -1.f;
-
-      for (i = 0; i < 3; i++)
-        {
-          row[i].x *= -1.f;
-          row[i].y *= -1.f;
-          row[i].z *= -1.f;
-        }
-    }
-
-  /* now get the rotations out */
-  rotate_p->y = asinf (-row[0].z);
-  if (cosf (rotate_p->y) != 0.f)
-    {
-      rotate_p->x = atan2f (row[1].z, row[2].z);
-      rotate_p->z = atan2f (row[0].y, row[0].x);
-    }
-  else
-    {
-      rotate_p->x = atan2f (-row[2].x, row[1].y);
-      rotate_p->z = 0.f;
-    }
-
-#undef XY_SHEAR
-#undef XZ_SHEAR
-#undef YZ_SHEAR
-#undef MAT
-
-  return TRUE;
-}
-
 typedef struct
 {
   GType value_type;
diff --git a/clutter/clutter/cogl/clutter-stage-cogl.c b/clutter/clutter/cogl/clutter-stage-cogl.c
index b682662003482486ab2b5d5289ed2ebb24a3963d..6483973e40fe3ad0caf54df5952763a9b2a4dc0a 100644
--- a/clutter/clutter/cogl/clutter-stage-cogl.c
+++ b/clutter/clutter/cogl/clutter-stage-cogl.c
@@ -165,7 +165,7 @@ paint_damage_region (ClutterStageWindow *stage_window,
   static CoglPipeline *overlay_blue = NULL;
   ClutterStageCogl *stage_cogl = CLUTTER_STAGE_COGL (stage_window);
   ClutterActor *actor = CLUTTER_ACTOR (stage_cogl->wrapper);
-  CoglMatrix transform;
+  graphene_matrix_t transform;
   int n_rects, i;
 
   cogl_framebuffer_push_matrix (framebuffer);
diff --git a/cogl/cogl/cogl-clip-stack.c b/cogl/cogl/cogl-clip-stack.c
index aa3172e2e983ab1c26d7392525e0a5de076b9475..e1581872132271f73059d44ebbd5d190b200797a 100644
--- a/cogl/cogl/cogl-clip-stack.c
+++ b/cogl/cogl/cogl-clip-stack.c
@@ -40,7 +40,6 @@
 #include "cogl-framebuffer-private.h"
 #include "cogl-journal-private.h"
 #include "cogl-util.h"
-#include "cogl-matrix-private.h"
 #include "cogl-primitives-private.h"
 #include "cogl-private.h"
 #include "cogl-attribute-private.h"
@@ -69,14 +68,14 @@ _cogl_clip_stack_push_entry (CoglClipStack *clip_stack,
 }
 
 static void
-get_transformed_corners (float x_1,
-                         float y_1,
-                         float x_2,
-                         float y_2,
-                         CoglMatrix *modelview,
-                         CoglMatrix *projection,
-                         const float *viewport,
-                         float *transformed_corners)
+get_transformed_corners (float              x_1,
+                         float              y_1,
+                         float              x_2,
+                         float              y_2,
+                         graphene_matrix_t *modelview,
+                         graphene_matrix_t *projection,
+                         const float       *viewport,
+                         float             *transformed_corners)
 {
   int i;
 
@@ -160,9 +159,9 @@ _cogl_clip_stack_push_rectangle (CoglClipStack *stack,
                                  const float *viewport)
 {
   CoglClipStackRect *entry;
-  CoglMatrix modelview;
-  CoglMatrix projection;
-  CoglMatrix modelview_projection;
+  graphene_matrix_t modelview;
+  graphene_matrix_t projection;
+  graphene_matrix_t modelview_projection;
 
   /* Corners of the given rectangle in an clockwise order:
    *  (0, 1)     (2, 3)
@@ -193,9 +192,7 @@ _cogl_clip_stack_push_rectangle (CoglClipStack *stack,
   cogl_matrix_entry_get (modelview_entry, &modelview);
   cogl_matrix_entry_get (projection_entry, &projection);
 
-  cogl_matrix_multiply (&modelview_projection,
-                        &projection,
-                        &modelview);
+  graphene_matrix_multiply (&modelview, &projection, &modelview_projection);
 
   /* Technically we could avoid the viewport transform at this point
    * if we want to make this a bit faster. */
@@ -260,8 +257,8 @@ _cogl_clip_stack_push_primitive (CoglClipStack *stack,
                                  const float *viewport)
 {
   CoglClipStackPrimitive *entry;
-  CoglMatrix modelview;
-  CoglMatrix projection;
+  graphene_matrix_t modelview;
+  graphene_matrix_t projection;
   float transformed_corners[8];
 
   entry = _cogl_clip_stack_push_entry (stack,
diff --git a/cogl/cogl/cogl-clip-stack.h b/cogl/cogl/cogl-clip-stack.h
index 62d65bcd39547d795410fafee7ae444802a07897..2efaa2777457d3767d4a23c5e0f70bdb23421f03 100644
--- a/cogl/cogl/cogl-clip-stack.h
+++ b/cogl/cogl/cogl-clip-stack.h
@@ -31,7 +31,6 @@
 #ifndef __COGL_CLIP_STACK_H
 #define __COGL_CLIP_STACK_H
 
-#include "cogl-matrix.h"
 #include "cogl-primitive.h"
 #include "cogl-framebuffer.h"
 #include "cogl-matrix-stack.h"
diff --git a/cogl/cogl/cogl-context-private.h b/cogl/cogl/cogl-context-private.h
index 74206a4449b3b5499242f0534fe72b968748938e..3bccd51d8e57b18fecbe85d59bd51ec81ce8d016 100644
--- a/cogl/cogl/cogl-context-private.h
+++ b/cogl/cogl/cogl-context-private.h
@@ -111,8 +111,8 @@ struct _CoglContext
   gboolean          legacy_backface_culling_enabled;
 
   /* A few handy matrix constants */
-  CoglMatrix        identity_matrix;
-  CoglMatrix        y_flip_matrix;
+  graphene_matrix_t identity_matrix;
+  graphene_matrix_t y_flip_matrix;
 
   /* The matrix stack entries that should be flushed during the next
    * pipeline state flush */
diff --git a/cogl/cogl/cogl-context.c b/cogl/cogl/cogl-context.c
index 1275439b6534b537706c6eb7f4d872c44fdc8fbd..85002cdec2f4a791d4c1e71ff937b9d843175ab5 100644
--- a/cogl/cogl/cogl-context.c
+++ b/cogl/cogl/cogl-context.c
@@ -221,9 +221,9 @@ cogl_context_new (CoglDisplay *display,
 
   context->legacy_backface_culling_enabled = FALSE;
 
-  cogl_matrix_init_identity (&context->identity_matrix);
-  cogl_matrix_init_identity (&context->y_flip_matrix);
-  cogl_matrix_scale (&context->y_flip_matrix, 1, -1, 1);
+  graphene_matrix_init_identity (&context->identity_matrix);
+  graphene_matrix_init_identity (&context->y_flip_matrix);
+  graphene_matrix_scale (&context->y_flip_matrix, 1, -1, 1);
 
   context->opaque_color_pipeline = cogl_pipeline_new (context);
 
diff --git a/cogl/cogl/cogl-framebuffer.c b/cogl/cogl/cogl-framebuffer.c
index a2ad821ae2e2f6781bd742fd7257a66085355478..b4991900ba6b490540a96696f22011ad56f4b533 100644
--- a/cogl/cogl/cogl-framebuffer.c
+++ b/cogl/cogl/cogl-framebuffer.c
@@ -45,7 +45,6 @@
 #include "cogl-clip-stack.h"
 #include "cogl-journal-private.h"
 #include "cogl-pipeline-state-private.h"
-#include "cogl-matrix-private.h"
 #include "cogl-primitive-private.h"
 #include "cogl-offscreen.h"
 #include "cogl1-context.h"
@@ -1503,8 +1502,8 @@ cogl_framebuffer_rotate_euler (CoglFramebuffer *framebuffer,
 }
 
 void
-cogl_framebuffer_transform (CoglFramebuffer *framebuffer,
-                            const CoglMatrix *matrix)
+cogl_framebuffer_transform (CoglFramebuffer         *framebuffer,
+                            const graphene_matrix_t *matrix)
 {
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
@@ -1577,7 +1576,7 @@ cogl_framebuffer_orthographic (CoglFramebuffer *framebuffer,
                                float near,
                                float far)
 {
-  CoglMatrix ortho;
+  graphene_matrix_t ortho;
   CoglMatrixStack *projection_stack =
     _cogl_framebuffer_get_projection_stack (framebuffer);
 
@@ -1585,8 +1584,7 @@ cogl_framebuffer_orthographic (CoglFramebuffer *framebuffer,
    * so we need to flush all journaled primitives first... */
   _cogl_framebuffer_flush_journal (framebuffer);
 
-  cogl_matrix_init_identity (&ortho);
-  cogl_matrix_orthographic (&ortho, x_1, y_1, x_2, y_2, near, far);
+  graphene_matrix_init_ortho (&ortho, x_1, x_2, y_2, y_1, near, far);
   cogl_matrix_stack_set (projection_stack, &ortho);
 
   if (framebuffer->context->current_draw_buffer == framebuffer)
@@ -1595,18 +1593,17 @@ cogl_framebuffer_orthographic (CoglFramebuffer *framebuffer,
 }
 
 void
-cogl_framebuffer_get_modelview_matrix (CoglFramebuffer *framebuffer,
-                                       CoglMatrix *matrix)
+cogl_framebuffer_get_modelview_matrix (CoglFramebuffer   *framebuffer,
+                                       graphene_matrix_t *matrix)
 {
   CoglMatrixEntry *modelview_entry =
     _cogl_framebuffer_get_modelview_entry (framebuffer);
   cogl_matrix_entry_get (modelview_entry, matrix);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
 }
 
 void
-cogl_framebuffer_set_modelview_matrix (CoglFramebuffer *framebuffer,
-                                       const CoglMatrix *matrix)
+cogl_framebuffer_set_modelview_matrix (CoglFramebuffer         *framebuffer,
+                                       const graphene_matrix_t *matrix)
 {
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
@@ -1615,23 +1612,20 @@ cogl_framebuffer_set_modelview_matrix (CoglFramebuffer *framebuffer,
   if (framebuffer->context->current_draw_buffer == framebuffer)
     framebuffer->context->current_draw_buffer_changes |=
       COGL_FRAMEBUFFER_STATE_MODELVIEW;
-
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
 }
 
 void
-cogl_framebuffer_get_projection_matrix (CoglFramebuffer *framebuffer,
-                                        CoglMatrix *matrix)
+cogl_framebuffer_get_projection_matrix (CoglFramebuffer   *framebuffer,
+                                        graphene_matrix_t *matrix)
 {
   CoglMatrixEntry *projection_entry =
     _cogl_framebuffer_get_projection_entry (framebuffer);
   cogl_matrix_entry_get (projection_entry, matrix);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
 }
 
 void
-cogl_framebuffer_set_projection_matrix (CoglFramebuffer *framebuffer,
-                                        const CoglMatrix *matrix)
+cogl_framebuffer_set_projection_matrix (CoglFramebuffer         *framebuffer,
+                                        const graphene_matrix_t *matrix)
 {
   CoglMatrixStack *projection_stack =
     _cogl_framebuffer_get_projection_stack (framebuffer);
@@ -1645,8 +1639,6 @@ cogl_framebuffer_set_projection_matrix (CoglFramebuffer *framebuffer,
   if (framebuffer->context->current_draw_buffer == framebuffer)
     framebuffer->context->current_draw_buffer_changes |=
       COGL_FRAMEBUFFER_STATE_PROJECTION;
-
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
 }
 
 void
diff --git a/cogl/cogl/cogl-framebuffer.h b/cogl/cogl/cogl-framebuffer.h
index 209c4d379c1e5dbeedd5b12c1a1734334f7eddfa..22af34fa040f699dd9a72f741cd51e6a25098f7b 100644
--- a/cogl/cogl/cogl-framebuffer.h
+++ b/cogl/cogl/cogl-framebuffer.h
@@ -390,8 +390,8 @@ cogl_framebuffer_rotate_euler (CoglFramebuffer *framebuffer,
  * Stability: unstable
  */
 COGL_EXPORT void
-cogl_framebuffer_transform (CoglFramebuffer *framebuffer,
-                            const CoglMatrix *matrix);
+cogl_framebuffer_transform (CoglFramebuffer         *framebuffer,
+                            const graphene_matrix_t *matrix);
 
 /**
  * cogl_framebuffer_get_modelview_matrix:
@@ -404,8 +404,8 @@ cogl_framebuffer_transform (CoglFramebuffer *framebuffer,
  * Stability: unstable
  */
 COGL_EXPORT void
-cogl_framebuffer_get_modelview_matrix (CoglFramebuffer *framebuffer,
-                                       CoglMatrix *matrix);
+cogl_framebuffer_get_modelview_matrix (CoglFramebuffer   *framebuffer,
+                                       graphene_matrix_t *matrix);
 
 /**
  * cogl_framebuffer_set_modelview_matrix:
@@ -418,8 +418,8 @@ cogl_framebuffer_get_modelview_matrix (CoglFramebuffer *framebuffer,
  * Stability: unstable
  */
 COGL_EXPORT void
-cogl_framebuffer_set_modelview_matrix (CoglFramebuffer *framebuffer,
-                                       const CoglMatrix *matrix);
+cogl_framebuffer_set_modelview_matrix (CoglFramebuffer         *framebuffer,
+                                       const graphene_matrix_t *matrix);
 
 /**
  * cogl_framebuffer_perspective:
@@ -518,8 +518,8 @@ cogl_framebuffer_orthographic (CoglFramebuffer *framebuffer,
  * Stability: unstable
  */
 COGL_EXPORT void
-cogl_framebuffer_get_projection_matrix (CoglFramebuffer *framebuffer,
-                                        CoglMatrix *matrix);
+cogl_framebuffer_get_projection_matrix (CoglFramebuffer   *framebuffer,
+                                        graphene_matrix_t *matrix);
 
 /**
  * cogl_framebuffer_set_projection_matrix:
@@ -532,8 +532,8 @@ cogl_framebuffer_get_projection_matrix (CoglFramebuffer *framebuffer,
  * Stability: unstable
  */
 COGL_EXPORT void
-cogl_framebuffer_set_projection_matrix (CoglFramebuffer *framebuffer,
-                                        const CoglMatrix *matrix);
+cogl_framebuffer_set_projection_matrix (CoglFramebuffer         *framebuffer,
+                                        const graphene_matrix_t *matrix);
 
 /**
  * cogl_framebuffer_push_scissor_clip:
diff --git a/cogl/cogl/cogl-graphene.c b/cogl/cogl/cogl-graphene.c
new file mode 100644
index 0000000000000000000000000000000000000000..90e1f5b86b1563013fe540bea9191bbb40dc5948
--- /dev/null
+++ b/cogl/cogl/cogl-graphene.c
@@ -0,0 +1,311 @@
+/* cogl-graphene.c
+ *
+ * Copyright 2020 Georges Basile Stavracas Neto <georges.stavracas@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#include "cogl/cogl-graphene.h"
+
+typedef struct _Point2f
+{
+  float x;
+  float y;
+} Point2f;
+
+typedef struct _Point3f
+{
+  float x;
+  float y;
+  float z;
+} Point3f;
+
+typedef struct _Point4f
+{
+  float x;
+  float y;
+  float z;
+  float w;
+} Point4f;
+
+static void
+init_matrix_rows (const graphene_matrix_t *matrix,
+                  unsigned int             n_rows,
+                  graphene_vec4_t         *rows)
+{
+  graphene_matrix_t m;
+  unsigned int i;
+
+  graphene_matrix_transpose (matrix, &m);
+
+  for (i = 0; i < n_rows; i++)
+    graphene_matrix_get_row (&m, i, &rows[i]);
+}
+
+static void
+transform_points_f2 (const graphene_matrix_t *matrix,
+                     size_t                   stride_in,
+                     const void              *points_in,
+                     size_t                   stride_out,
+                     void                    *points_out,
+                     int                      n_points)
+{
+  graphene_vec4_t rows[3];
+  int i;
+
+  init_matrix_rows (matrix, G_N_ELEMENTS (rows), rows);
+
+  for (i = 0; i < n_points; i++)
+    {
+      Point2f p = *(Point2f *)((uint8_t *)points_in + i * stride_in);
+      Point3f *o = (Point3f *)((uint8_t *)points_out + i * stride_out);
+      graphene_vec4_t point;
+
+      graphene_vec4_init (&point, p.x, p.y, 0.f, 1.f);
+
+      o->x = graphene_vec4_dot (&rows[0], &point);
+      o->y = graphene_vec4_dot (&rows[1], &point);
+      o->z = graphene_vec4_dot (&rows[2], &point);
+    }
+}
+
+static void
+project_points_f2 (const graphene_matrix_t *matrix,
+                   size_t                   stride_in,
+                   const void              *points_in,
+                   size_t                   stride_out,
+                   void                    *points_out,
+                   int                      n_points)
+{
+  graphene_vec4_t rows[4];
+  int i;
+
+  init_matrix_rows (matrix, G_N_ELEMENTS (rows), rows);
+
+  for (i = 0; i < n_points; i++)
+    {
+      Point2f p = *(Point2f *)((uint8_t *)points_in + i * stride_in);
+      Point4f *o = (Point4f *)((uint8_t *)points_out + i * stride_out);
+      graphene_vec4_t point;
+
+      graphene_vec4_init (&point, p.x, p.y, 0.f, 1.f);
+
+      o->x = graphene_vec4_dot (&rows[0], &point);
+      o->y = graphene_vec4_dot (&rows[1], &point);
+      o->z = graphene_vec4_dot (&rows[2], &point);
+      o->w = graphene_vec4_dot (&rows[3], &point);
+    }
+}
+
+static void
+transform_points_f3 (const graphene_matrix_t *matrix,
+                     size_t                   stride_in,
+                     const void              *points_in,
+                     size_t                   stride_out,
+                     void                    *points_out,
+                     int                      n_points)
+{
+  graphene_vec4_t rows[3];
+  int i;
+
+  init_matrix_rows (matrix, G_N_ELEMENTS (rows), rows);
+
+  for (i = 0; i < n_points; i++)
+    {
+      Point3f p = *(Point3f *)((uint8_t *)points_in + i * stride_in);
+      Point3f *o = (Point3f *)((uint8_t *)points_out + i * stride_out);
+      graphene_vec4_t point;
+
+      graphene_vec4_init (&point, p.x, p.y, p.z, 1.f);
+
+      o->x = graphene_vec4_dot (&rows[0], &point);
+      o->y = graphene_vec4_dot (&rows[1], &point);
+      o->z = graphene_vec4_dot (&rows[2], &point);
+    }
+}
+
+static void
+project_points_f3 (const graphene_matrix_t *matrix,
+                   size_t                   stride_in,
+                   const void              *points_in,
+                   size_t                   stride_out,
+                   void                    *points_out,
+                   int                      n_points)
+{
+  graphene_vec4_t rows[4];
+  int i;
+
+  init_matrix_rows (matrix, G_N_ELEMENTS (rows), rows);
+
+  for (i = 0; i < n_points; i++)
+    {
+      Point3f p = *(Point3f *)((uint8_t *)points_in + i * stride_in);
+      Point4f *o = (Point4f *)((uint8_t *)points_out + i * stride_out);
+      graphene_vec4_t point;
+
+      graphene_vec4_init (&point, p.x, p.y, p.z, 1.f);
+
+      o->x = graphene_vec4_dot (&rows[0], &point);
+      o->y = graphene_vec4_dot (&rows[1], &point);
+      o->z = graphene_vec4_dot (&rows[2], &point);
+      o->w = graphene_vec4_dot (&rows[3], &point);
+    }
+}
+
+static void
+project_points_f4 (const graphene_matrix_t *matrix,
+                   size_t                   stride_in,
+                   const void              *points_in,
+                   size_t                   stride_out,
+                   void                    *points_out,
+                   int                      n_points)
+{
+  graphene_vec4_t rows[4];
+  int i;
+
+  init_matrix_rows (matrix, G_N_ELEMENTS (rows), rows);
+
+  for (i = 0; i < n_points; i++)
+    {
+      Point4f p = *(Point4f *)((uint8_t *)points_in + i * stride_in);
+      Point4f *o = (Point4f *)((uint8_t *)points_out + i * stride_out);
+      graphene_vec4_t point;
+
+      graphene_vec4_init (&point, p.x, p.y, p.z, p.w);
+
+      o->x = graphene_vec4_dot (&rows[0], &point);
+      o->y = graphene_vec4_dot (&rows[1], &point);
+      o->z = graphene_vec4_dot (&rows[2], &point);
+      o->w = graphene_vec4_dot (&rows[3], &point);
+    }
+}
+
+void
+cogl_graphene_matrix_project_point (const graphene_matrix_t *matrix,
+                                    float                   *x,
+                                    float                   *y,
+                                    float                   *z,
+                                    float                   *w)
+{
+  graphene_vec4_t p;
+
+  graphene_vec4_init (&p, *x, *y, *z, *w);
+  graphene_matrix_transform_vec4 (matrix, &p, &p);
+
+  *x = graphene_vec4_get_x (&p);
+  *y = graphene_vec4_get_y (&p);
+  *z = graphene_vec4_get_z (&p);
+  *w = graphene_vec4_get_w (&p);
+}
+
+void
+cogl_graphene_matrix_transform_points (const graphene_matrix_t *matrix,
+                                       int                      n_components,
+                                       size_t                   stride_in,
+                                       const void              *points_in,
+                                       size_t                   stride_out,
+                                       void                    *points_out,
+                                       int                      n_points)
+{
+  /* The results of transforming always have three components... */
+  g_return_if_fail (stride_out >= sizeof (Point3f));
+
+  if (n_components == 2)
+    {
+      transform_points_f2 (matrix,
+                           stride_in, points_in,
+                           stride_out, points_out,
+                           n_points);
+    }
+  else
+    {
+      g_return_if_fail (n_components == 3);
+
+      transform_points_f3 (matrix,
+                           stride_in, points_in,
+                           stride_out, points_out,
+                           n_points);
+    }
+}
+
+void
+cogl_graphene_matrix_project_points (const graphene_matrix_t *matrix,
+                                     int                      n_components,
+                                     size_t                   stride_in,
+                                     const void              *points_in,
+                                     size_t                   stride_out,
+                                     void                    *points_out,
+                                     int                      n_points)
+{
+  if (n_components == 2)
+    {
+      project_points_f2 (matrix,
+                         stride_in, points_in,
+                         stride_out, points_out,
+                         n_points);
+    }
+  else if (n_components == 3)
+    {
+      project_points_f3 (matrix,
+                         stride_in, points_in,
+                         stride_out, points_out,
+                         n_points);
+    }
+  else
+    {
+      g_return_if_fail (n_components == 4);
+
+      project_points_f4 (matrix,
+                         stride_in, points_in,
+                         stride_out, points_out,
+                         n_points);
+    }
+}
+
+gboolean
+cogl_graphene_matrix_get_inverse (const graphene_matrix_t *matrix,
+                                  graphene_matrix_t       *inverse)
+{
+  graphene_matrix_t scaled;
+  graphene_matrix_t m;
+  gboolean invertible;
+  float pivot = G_MAXFLOAT;
+  float v[16];
+  float scale;
+
+  graphene_matrix_init_from_matrix (&m, matrix);
+  graphene_matrix_to_float (&m, v);
+
+  pivot = MIN (pivot, v[0]);
+  pivot = MIN (pivot, v[5]);
+  pivot = MIN (pivot, v[10]);
+  pivot = MIN (pivot, v[15]);
+  scale = 1.f / pivot;
+
+  graphene_matrix_init_scale (&scaled, scale, scale, scale);
+
+  /* Float precision is a limiting factor */
+  graphene_matrix_multiply (&m, &scaled, &m);
+
+  invertible = graphene_matrix_inverse (&m, inverse);
+
+  if (invertible)
+    graphene_matrix_multiply (&scaled, inverse, inverse);
+  else
+    graphene_matrix_init_identity (inverse);
+
+  return invertible;
+}
diff --git a/cogl/cogl/cogl-graphene.h b/cogl/cogl/cogl-graphene.h
new file mode 100644
index 0000000000000000000000000000000000000000..4a561f6d84bd282a6af69ce365291d6c97407f4f
--- /dev/null
+++ b/cogl/cogl/cogl-graphene.h
@@ -0,0 +1,184 @@
+/* cogl-graphene.h
+ *
+ * Copyright 2020 Georges Basile Stavracas Neto <georges.stavracas@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#ifndef COGL_GRAPHENE_H
+#define COGL_GRAPHENE_H
+
+#include <cogl/cogl-defines.h>
+#include <cogl/cogl-macros.h>
+#include <cogl/cogl-types.h>
+
+#include <glib.h>
+
+#include <graphene.h>
+
+G_BEGIN_DECLS
+
+
+/**
+ * cogl_graphene_matrix_project_point:
+ * @matrix: A 4x4 transformation matrix
+ * @x: (inout): The X component of your points position
+ * @y: (inout): The Y component of your points position
+ * @z: (inout): The Z component of your points position
+ * @w: (inout): The W component of your points position
+ *
+ * Transforms a point whose position is given and returned as four float
+ * components.
+ */
+COGL_EXPORT void
+cogl_graphene_matrix_project_point (const graphene_matrix_t *matrix,
+                                    float                   *x,
+                                    float                   *y,
+                                    float                   *z,
+                                    float                   *w);
+
+/**
+ * cogl_graphene_matrix_transform_points:
+ * @matrix: A transformation matrix
+ * @n_components: The number of position components for each input point.
+ *                (either 2 or 3)
+ * @stride_in: The stride in bytes between input points.
+ * @points_in: A pointer to the first component of the first input point.
+ * @stride_out: The stride in bytes between output points.
+ * @points_out: A pointer to the first component of the first output point.
+ * @n_points: The number of points to transform.
+ *
+ * Transforms an array of input points and writes the result to
+ * another array of output points. The input points can either have 2
+ * or 3 components each. The output points always have 3 components.
+ * The output array can simply point to the input array to do the
+ * transform in-place.
+ *
+ * If you need to transform 4 component points see
+ * cogl_graphene_matrix_project_points().
+ *
+ * Here's an example with differing input/output strides:
+ * |[
+ * typedef struct {
+ *   float x,y;
+ *   uint8_t r,g,b,a;
+ *   float s,t,p;
+ * } MyInVertex;
+ * typedef struct {
+ *   uint8_t r,g,b,a;
+ *   float x,y,z;
+ * } MyOutVertex;
+ * MyInVertex vertices[N_VERTICES];
+ * MyOutVertex results[N_VERTICES];
+ * graphene_matrix_t matrix;
+ *
+ * my_load_vertices (vertices);
+ * my_get_matrix (&matrix);
+ *
+ * cogl_graphene_matrix_transform_points (&matrix,
+ *                               2,
+ *                               sizeof (MyInVertex),
+ *                               &vertices[0].x,
+ *                               sizeof (MyOutVertex),
+ *                               &results[0].x,
+ *                               N_VERTICES);
+ * ]|
+ *
+ * Stability: unstable
+ */
+COGL_EXPORT void
+cogl_graphene_matrix_transform_points (const graphene_matrix_t *matrix,
+                                       int                      n_components,
+                                       size_t                   stride_in,
+                                       const void              *points_in,
+                                       size_t                   stride_out,
+                                       void                    *points_out,
+                                       int                      n_points);
+
+/**
+ * cogl_graphene_matrix_project_points:
+ * @matrix: A projection matrix
+ * @n_components: The number of position components for each input point.
+ *                (either 2, 3 or 4)
+ * @stride_in: The stride in bytes between input points.
+ * @points_in: A pointer to the first component of the first input point.
+ * @stride_out: The stride in bytes between output points.
+ * @points_out: A pointer to the first component of the first output point.
+ * @n_points: The number of points to transform.
+ *
+ * Projects an array of input points and writes the result to another
+ * array of output points. The input points can either have 2, 3 or 4
+ * components each. The output points always have 4 components (known
+ * as homogeneous coordinates). The output array can simply point to
+ * the input array to do the transform in-place.
+ *
+ * Here's an example with differing input/output strides:
+ * |[
+ * typedef struct {
+ *   float x,y;
+ *   uint8_t r,g,b,a;
+ *   float s,t,p;
+ * } MyInVertex;
+ * typedef struct {
+ *   uint8_t r,g,b,a;
+ *   float x,y,z;
+ * } MyOutVertex;
+ * MyInVertex vertices[N_VERTICES];
+ * MyOutVertex results[N_VERTICES];
+ * graphene_matrix_t matrix;
+ *
+ * my_load_vertices (vertices);
+ * my_get_matrix (&matrix);
+ *
+ * cogl_graphene_matrix_project_points (&matrix,
+ *                             2,
+ *                             sizeof (MyInVertex),
+ *                             &vertices[0].x,
+ *                             sizeof (MyOutVertex),
+ *                             &results[0].x,
+ *                             N_VERTICES);
+ * ]|
+ *
+ * Stability: unstable
+ */
+COGL_EXPORT void
+cogl_graphene_matrix_project_points (const graphene_matrix_t *matrix,
+                                     int                      n_components,
+                                     size_t                   stride_in,
+                                     const void              *points_in,
+                                     size_t                   stride_out,
+                                     void                    *points_out,
+                                     int                      n_points);
+
+/**
+ * cogl_graphene_matrix_get_inverse:
+ * @matrix: A 4x4 transformation matrix
+ * @inverse: (out): The destination for a 4x4 inverse transformation matrix
+ *
+ * Gets the inverse transform of a given matrix and uses it to initialize
+ * a new #graphene_matrix_t.
+ *
+ * Return value: %TRUE if the inverse was successfully calculated or %FALSE
+ *   for degenerate transformations that can't be inverted (in this case the
+ *   @inverse matrix will simply be initialized with the identity matrix)
+ */
+COGL_EXPORT gboolean
+cogl_graphene_matrix_get_inverse (const graphene_matrix_t *matrix,
+                                  graphene_matrix_t       *inverse);
+
+G_END_DECLS
+
+#endif /* COGL_GRAPHENE_H */
diff --git a/cogl/cogl/cogl-journal.c b/cogl/cogl/cogl-journal.c
index 418fd9895487de2579bf005726b8dd3dcd6320a4..498e4d877b33d8e62e8a9a5a4b8a6d5b9c57e3d6 100644
--- a/cogl/cogl/cogl-journal.c
+++ b/cogl/cogl/cogl-journal.c
@@ -32,6 +32,7 @@
 
 #include "cogl-debug.h"
 #include "cogl-context-private.h"
+#include "cogl-graphene.h"
 #include "cogl-journal-private.h"
 #include "cogl-texture-private.h"
 #include "cogl-pipeline-private.h"
@@ -1160,7 +1161,7 @@ upload_vertices (CoglJournal *journal,
   int entry_num;
   int i;
   CoglMatrixEntry *last_modelview_entry = NULL;
-  CoglMatrix modelview;
+  graphene_matrix_t modelview;
 
   g_assert (needed_vbo_len);
 
@@ -1212,14 +1213,14 @@ upload_vertices (CoglJournal *journal,
 
           if (entry->modelview_entry != last_modelview_entry)
             cogl_matrix_entry_get (entry->modelview_entry, &modelview);
-          cogl_matrix_transform_points (&modelview,
-                                        2, /* n_components */
-                                        sizeof (float) * 2, /* stride_in */
-                                        v, /* points_in */
-                                        /* strideout */
-                                        vb_stride * sizeof (float),
-                                        vout, /* points_out */
-                                        4 /* n_points */);
+          cogl_graphene_matrix_transform_points (&modelview,
+                                                 2, /* n_components */
+                                                 sizeof (float) * 2, /* stride_in */
+                                                 v, /* points_in */
+                                                 /* strideout */
+                                                 vb_stride * sizeof (float),
+                                                 vout, /* points_out */
+                                                 4 /* n_points */);
         }
 
       for (i = 0; i < entry->n_layers; i++)
@@ -1642,8 +1643,8 @@ entry_to_screen_polygon (CoglFramebuffer *framebuffer,
   size_t array_stride =
     GET_JOURNAL_ARRAY_STRIDE_FOR_N_LAYERS (entry->n_layers);
   CoglMatrixStack *projection_stack;
-  CoglMatrix projection;
-  CoglMatrix modelview;
+  graphene_matrix_t projection;
+  graphene_matrix_t modelview;
   int i;
   const float *viewport = entry->viewport;
 
@@ -1672,27 +1673,27 @@ entry_to_screen_polygon (CoglFramebuffer *framebuffer,
    */
 
   cogl_matrix_entry_get (entry->modelview_entry, &modelview);
-  cogl_matrix_transform_points (&modelview,
-                                2, /* n_components */
-                                sizeof (float) * 4, /* stride_in */
-                                poly, /* points_in */
-                                /* strideout */
-                                sizeof (float) * 4,
-                                poly, /* points_out */
-                                4 /* n_points */);
+  cogl_graphene_matrix_transform_points (&modelview,
+                                         2, /* n_components */
+                                         sizeof (float) * 4, /* stride_in */
+                                         poly, /* points_in */
+                                         /* strideout */
+                                         sizeof (float) * 4,
+                                         poly, /* points_out */
+                                         4 /* n_points */);
 
   projection_stack =
     _cogl_framebuffer_get_projection_stack (framebuffer);
   cogl_matrix_stack_get (projection_stack, &projection);
 
-  cogl_matrix_project_points (&projection,
-                              3, /* n_components */
-                              sizeof (float) * 4, /* stride_in */
-                              poly, /* points_in */
-                              /* strideout */
-                              sizeof (float) * 4,
-                              poly, /* points_out */
-                              4 /* n_points */);
+  cogl_graphene_matrix_transform_points (&projection,
+                                         3, /* n_components */
+                                         sizeof (float) * 4, /* stride_in */
+                                         poly, /* points_in */
+                                         /* strideout */
+                                         sizeof (float) * 4,
+                                         poly, /* points_out */
+                                         4 /* n_points */);
 
 /* Scale from OpenGL normalized device coordinates (ranging from -1 to 1)
  * to Cogl window/framebuffer coordinates (ranging from 0 to buffer-size) with
diff --git a/cogl/cogl/cogl-matrix-private.h b/cogl/cogl/cogl-matrix-private.h
deleted file mode 100644
index 0add3e4c2b142d6c81b4e08ac2e28e3f8225e53a..0000000000000000000000000000000000000000
--- a/cogl/cogl/cogl-matrix-private.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Cogl
- *
- * A Low Level GPU Graphics and Utilities API
- *
- * Copyright (C) 2008,2009 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- *
- *
- * Authors:
- *   Robert Bragg <robert@linux.intel.com>
- */
-
-#ifndef __COGL_MATRIX_PRIVATE_H
-#define __COGL_MATRIX_PRIVATE_H
-
-#include <glib.h>
-
-G_BEGIN_DECLS
-
-#define _COGL_MATRIX_DEBUG_PRINT(MATRIX) \
-  if (G_UNLIKELY (COGL_DEBUG_ENABLED (COGL_DEBUG_MATRICES))) \
-    { \
-      g_print ("%s:\n", G_STRFUNC); \
-      cogl_debug_matrix_print (MATRIX); \
-    }
-
-void
-_cogl_matrix_prefix_print (const char *prefix, const CoglMatrix *matrix);
-
-void
-_cogl_matrix_init_from_matrix_without_inverse (CoglMatrix *matrix,
-                                               const CoglMatrix *src);
-
-G_END_DECLS
-
-#endif /* __COGL_MATRIX_PRIVATE_H */
-
diff --git a/cogl/cogl/cogl-matrix-stack-private.h b/cogl/cogl/cogl-matrix-stack-private.h
index 7a6e8b587d74c2f359770008a8d45e4f266f8fda..cb0885199fa47ec13349d093bea0e490f079e17f 100644
--- a/cogl/cogl/cogl-matrix-stack-private.h
+++ b/cogl/cogl/cogl-matrix-stack-private.h
@@ -102,7 +102,7 @@ typedef struct _CoglMatrixEntryMultiply
 {
   CoglMatrixEntry _parent_data;
 
-  CoglMatrix *matrix;
+  graphene_matrix_t matrix;
 
 } CoglMatrixEntryMultiply;
 
@@ -110,7 +110,7 @@ typedef struct _CoglMatrixEntryLoad
 {
   CoglMatrixEntry _parent_data;
 
-  CoglMatrix *matrix;
+  graphene_matrix_t matrix;
 
 } CoglMatrixEntryLoad;
 
@@ -118,7 +118,7 @@ typedef struct _CoglMatrixEntrySave
 {
   CoglMatrixEntry _parent_data;
 
-  CoglMatrix *cache;
+  graphene_matrix_t cache;
   gboolean cache_valid;
 
 } CoglMatrixEntrySave;
diff --git a/cogl/cogl/cogl-matrix-stack.c b/cogl/cogl/cogl-matrix-stack.c
index 1c878c09f05ac035f85665e404daf05d9fcbc072..3f688306813b0843017f8343e984624fa2cc18b1 100644
--- a/cogl/cogl/cogl-matrix-stack.c
+++ b/cogl/cogl/cogl-matrix-stack.c
@@ -34,11 +34,11 @@
 #include "cogl-config.h"
 
 #include "cogl-context-private.h"
+#include "cogl-graphene.h"
 #include "cogl-matrix-stack.h"
 #include "cogl-framebuffer-private.h"
 #include "cogl-object-private.h"
 #include "cogl-offscreen.h"
-#include "cogl-matrix-private.h"
 #include "cogl-magazine-private.h"
 #include "cogl-gtype-private.h"
 
@@ -51,7 +51,6 @@ COGL_GTYPE_DEFINE_BOXED (MatrixEntry, matrix_entry,
                          cogl_matrix_entry_unref);
 
 static CoglMagazine *cogl_matrix_stack_magazine;
-static CoglMagazine *cogl_matrix_stack_matrices_magazine;
 
 /* XXX: Note: this leaves entry->parent uninitialized! */
 static CoglMatrixEntry *
@@ -202,33 +201,25 @@ cogl_matrix_stack_scale (CoglMatrixStack *stack,
 }
 
 void
-cogl_matrix_stack_multiply (CoglMatrixStack *stack,
-                            const CoglMatrix *matrix)
+cogl_matrix_stack_multiply (CoglMatrixStack         *stack,
+                            const graphene_matrix_t *matrix)
 {
   CoglMatrixEntryMultiply *entry;
 
   entry = _cogl_matrix_stack_push_operation (stack, COGL_MATRIX_OP_MULTIPLY);
-
-  entry->matrix =
-    _cogl_magazine_chunk_alloc (cogl_matrix_stack_matrices_magazine);
-
-  cogl_matrix_init_from_array (entry->matrix, (float *)matrix);
+  graphene_matrix_init_from_matrix (&entry->matrix, matrix);
 }
 
 void
-cogl_matrix_stack_set (CoglMatrixStack *stack,
-                       const CoglMatrix *matrix)
+cogl_matrix_stack_set (CoglMatrixStack         *stack,
+                       const graphene_matrix_t *matrix)
 {
   CoglMatrixEntryLoad *entry;
 
   entry =
     _cogl_matrix_stack_push_replacement_entry (stack,
                                                COGL_MATRIX_OP_LOAD);
-
-  entry->matrix =
-    _cogl_magazine_chunk_alloc (cogl_matrix_stack_matrices_magazine);
-
-  cogl_matrix_init_from_array (entry->matrix, (float *)matrix);
+  graphene_matrix_init_from_matrix (&entry->matrix, matrix);
 }
 
 void
@@ -246,13 +237,10 @@ cogl_matrix_stack_frustum (CoglMatrixStack *stack,
     _cogl_matrix_stack_push_replacement_entry (stack,
                                                COGL_MATRIX_OP_LOAD);
 
-  entry->matrix =
-    _cogl_magazine_chunk_alloc (cogl_matrix_stack_matrices_magazine);
-
-  cogl_matrix_init_identity (entry->matrix);
-  cogl_matrix_frustum (entry->matrix,
-                       left, right, bottom, top,
-                       z_near, z_far);
+  graphene_matrix_init_frustum (&entry->matrix,
+                                left, right,
+                                bottom, top,
+                                z_near, z_far);
 }
 
 void
@@ -267,13 +255,9 @@ cogl_matrix_stack_perspective (CoglMatrixStack *stack,
   entry =
     _cogl_matrix_stack_push_replacement_entry (stack,
                                                COGL_MATRIX_OP_LOAD);
-
-  entry->matrix =
-    _cogl_magazine_chunk_alloc (cogl_matrix_stack_matrices_magazine);
-
-  cogl_matrix_init_identity (entry->matrix);
-  cogl_matrix_perspective (entry->matrix,
-                           fov_y, aspect, z_near, z_far);
+  graphene_matrix_init_perspective (&entry->matrix,
+                                    fov_y, aspect,
+                                    z_near, z_far);
 }
 
 void
@@ -290,13 +274,10 @@ cogl_matrix_stack_orthographic (CoglMatrixStack *stack,
   entry =
     _cogl_matrix_stack_push_replacement_entry (stack,
                                                COGL_MATRIX_OP_LOAD);
-
-  entry->matrix =
-    _cogl_magazine_chunk_alloc (cogl_matrix_stack_matrices_magazine);
-
-  cogl_matrix_init_identity (entry->matrix);
-  cogl_matrix_orthographic (entry->matrix,
-                            x_1, y_1, x_2, y_2, near, far);
+  graphene_matrix_init_ortho (&entry->matrix,
+                              x_1, x_2,
+                              y_2, y_1,
+                              near, far);
 }
 
 void
@@ -328,40 +309,6 @@ cogl_matrix_entry_unref (CoglMatrixEntry *entry)
   for (; entry && --entry->ref_count <= 0; entry = parent)
     {
       parent = entry->parent;
-
-      switch (entry->op)
-        {
-        case COGL_MATRIX_OP_LOAD_IDENTITY:
-        case COGL_MATRIX_OP_TRANSLATE:
-        case COGL_MATRIX_OP_ROTATE:
-        case COGL_MATRIX_OP_ROTATE_EULER:
-        case COGL_MATRIX_OP_SCALE:
-          break;
-        case COGL_MATRIX_OP_MULTIPLY:
-          {
-            CoglMatrixEntryMultiply *multiply =
-              (CoglMatrixEntryMultiply *)entry;
-            _cogl_magazine_chunk_free (cogl_matrix_stack_matrices_magazine,
-                                       multiply->matrix);
-            break;
-          }
-        case COGL_MATRIX_OP_LOAD:
-          {
-            CoglMatrixEntryLoad *load = (CoglMatrixEntryLoad *)entry;
-            _cogl_magazine_chunk_free (cogl_matrix_stack_matrices_magazine,
-                                       load->matrix);
-            break;
-          }
-        case COGL_MATRIX_OP_SAVE:
-          {
-            CoglMatrixEntrySave *save = (CoglMatrixEntrySave *)entry;
-            if (save->cache_valid)
-              _cogl_magazine_chunk_free (cogl_matrix_stack_matrices_magazine,
-                                         save->cache);
-            break;
-          }
-        }
-
       _cogl_magazine_chunk_free (cogl_matrix_stack_magazine, entry);
     }
 }
@@ -404,16 +351,16 @@ cogl_matrix_stack_pop (CoglMatrixStack *stack)
 }
 
 gboolean
-cogl_matrix_stack_get_inverse (CoglMatrixStack *stack,
-                                CoglMatrix *inverse)
+cogl_matrix_stack_get_inverse (CoglMatrixStack   *stack,
+                               graphene_matrix_t *inverse)
 {
-  CoglMatrix matrix;
-  CoglMatrix *internal = cogl_matrix_stack_get (stack, &matrix);
+  graphene_matrix_t matrix;
+  graphene_matrix_t *internal = cogl_matrix_stack_get (stack, &matrix);
 
   if (internal)
-    return cogl_matrix_get_inverse (internal, inverse);
+    return cogl_graphene_matrix_get_inverse (internal, inverse);
   else
-    return cogl_matrix_get_inverse (&matrix, inverse);
+    return cogl_graphene_matrix_get_inverse (&matrix, inverse);
 }
 
 /* In addition to writing the stack matrix into the give @matrix
@@ -421,79 +368,82 @@ cogl_matrix_stack_get_inverse (CoglMatrixStack *stack,
  * to a matrix too so if we are querying the inverse matrix we
  * should query from the return matrix so that the result can
  * be cached within the stack. */
-CoglMatrix *
-cogl_matrix_entry_get (CoglMatrixEntry *entry,
-                        CoglMatrix *matrix)
+graphene_matrix_t *
+cogl_matrix_entry_get (CoglMatrixEntry   *entry,
+                       graphene_matrix_t *matrix)
 {
-  int depth;
   CoglMatrixEntry *current;
-  CoglMatrixEntry **children;
-  int i;
+  int depth;
+
+  graphene_matrix_init_identity (matrix);
 
-  for (depth = 0, current = entry;
+  for (current = entry, depth = 0;
        current;
        current = current->parent, depth++)
     {
       switch (current->op)
         {
-        case COGL_MATRIX_OP_LOAD_IDENTITY:
-          cogl_matrix_init_identity (matrix);
-          goto initialized;
-        case COGL_MATRIX_OP_LOAD:
+        case COGL_MATRIX_OP_TRANSLATE:
           {
-            CoglMatrixEntryLoad *load = (CoglMatrixEntryLoad *)current;
-            _cogl_matrix_init_from_matrix_without_inverse (matrix,
-                                                           load->matrix);
-            goto initialized;
+            CoglMatrixEntryTranslate *translate =
+              (CoglMatrixEntryTranslate *) current;
+            graphene_matrix_translate (matrix, &translate->translate);
+            break;
           }
-        case COGL_MATRIX_OP_SAVE:
+        case COGL_MATRIX_OP_ROTATE:
           {
-            CoglMatrixEntrySave *save = (CoglMatrixEntrySave *)current;
-            if (!save->cache_valid)
-              {
-                CoglMagazine *matrices_magazine =
-                  cogl_matrix_stack_matrices_magazine;
-                save->cache = _cogl_magazine_chunk_alloc (matrices_magazine);
-                cogl_matrix_entry_get (current->parent, save->cache);
-                save->cache_valid = TRUE;
-              }
-            _cogl_matrix_init_from_matrix_without_inverse (matrix, save->cache);
-            goto initialized;
+            CoglMatrixEntryRotate *rotate =
+              (CoglMatrixEntryRotate *) current;
+            graphene_matrix_rotate (matrix, rotate->angle, &rotate->axis);
+            break;
           }
-        default:
-          continue;
-        }
-    }
-
-initialized:
-
-  if (depth == 0)
-    {
-      switch (entry->op)
-        {
-        case COGL_MATRIX_OP_LOAD_IDENTITY:
-        case COGL_MATRIX_OP_TRANSLATE:
-        case COGL_MATRIX_OP_ROTATE:
         case COGL_MATRIX_OP_ROTATE_EULER:
+          {
+            CoglMatrixEntryRotateEuler *rotate =
+              (CoglMatrixEntryRotateEuler *) current;
+            graphene_matrix_rotate_euler (matrix, &rotate->euler);
+            break;
+          }
         case COGL_MATRIX_OP_SCALE:
+          {
+            CoglMatrixEntryScale *scale =
+              (CoglMatrixEntryScale *) current;
+            graphene_matrix_scale (matrix, scale->x, scale->y, scale->z);
+            break;
+          }
         case COGL_MATRIX_OP_MULTIPLY:
-          return NULL;
+          {
+            CoglMatrixEntryMultiply *multiply =
+              (CoglMatrixEntryMultiply *) current;
+            graphene_matrix_multiply (matrix, &multiply->matrix, matrix);
+            break;
+          }
+
+        case COGL_MATRIX_OP_LOAD_IDENTITY:
+          goto applied;
 
         case COGL_MATRIX_OP_LOAD:
           {
-            CoglMatrixEntryLoad *load = (CoglMatrixEntryLoad *)entry;
-            return load->matrix;
+            CoglMatrixEntryLoad *load = (CoglMatrixEntryLoad *) current;
+            graphene_matrix_multiply (matrix, &load->matrix, matrix);
+            goto applied;
           }
         case COGL_MATRIX_OP_SAVE:
           {
-            CoglMatrixEntrySave *save = (CoglMatrixEntrySave *)entry;
-            return save->cache;
+            CoglMatrixEntrySave *save = (CoglMatrixEntrySave *) current;
+            if (!save->cache_valid)
+              {
+                cogl_matrix_entry_get (current->parent, &save->cache);
+                save->cache_valid = TRUE;
+              }
+            graphene_matrix_multiply (matrix, &save->cache, matrix);
+            goto applied;
           }
         }
-      g_warn_if_reached ();
-      return NULL;
     }
 
+applied:
+
 #ifdef COGL_ENABLE_DEBUG
   if (!current)
     {
@@ -502,22 +452,7 @@ initialized:
     }
 
   entry->composite_gets++;
-#endif
-
-  children = g_alloca (sizeof (CoglMatrixEntry) * depth);
-
-  /* We need walk the list of entries from the init/load/save entry
-   * back towards the leaf node but the nodes don't link to their
-   * children so we need to re-walk them here to add to a separate
-   * array. */
-  for (i = depth - 1, current = entry;
-       i >= 0 && current;
-       i--, current = current->parent)
-    {
-      children[i] = current;
-    }
 
-#ifdef COGL_ENABLE_DEBUG
   if (COGL_DEBUG_ENABLED (COGL_DEBUG_PERFORMANCE) &&
       entry->composite_gets >= 2)
     {
@@ -526,63 +461,31 @@ initialized:
     }
 #endif
 
-  for (i = 0; i < depth; i++)
+  if (depth == 0)
     {
-      switch (children[i]->op)
+      switch (entry->op)
         {
+        case COGL_MATRIX_OP_LOAD_IDENTITY:
         case COGL_MATRIX_OP_TRANSLATE:
-          {
-            CoglMatrixEntryTranslate *translate =
-              (CoglMatrixEntryTranslate *)children[i];
-            cogl_matrix_translate (matrix,
-                                   translate->translate.x,
-                                   translate->translate.y,
-                                   translate->translate.z);
-            continue;
-          }
         case COGL_MATRIX_OP_ROTATE:
-          {
-            CoglMatrixEntryRotate *rotate=
-              (CoglMatrixEntryRotate *)children[i];
-            cogl_matrix_rotate (matrix,
-                                rotate->angle,
-                                graphene_vec3_get_x (&rotate->axis),
-                                graphene_vec3_get_y (&rotate->axis),
-                                graphene_vec3_get_z (&rotate->axis));
-            continue;
-          }
         case COGL_MATRIX_OP_ROTATE_EULER:
-          {
-            CoglMatrixEntryRotateEuler *rotate =
-              (CoglMatrixEntryRotateEuler *)children[i];
-            cogl_matrix_rotate_euler (matrix,
-                                      &rotate->euler);
-            continue;
-          }
         case COGL_MATRIX_OP_SCALE:
-          {
-            CoglMatrixEntryScale *scale =
-              (CoglMatrixEntryScale *)children[i];
-            cogl_matrix_scale (matrix,
-                               scale->x,
-                               scale->y,
-                               scale->z);
-            continue;
-          }
         case COGL_MATRIX_OP_MULTIPLY:
-          {
-            CoglMatrixEntryMultiply *multiply =
-              (CoglMatrixEntryMultiply *)children[i];
-            cogl_matrix_multiply (matrix, matrix, multiply->matrix);
-            continue;
-          }
+          return NULL;
 
-        case COGL_MATRIX_OP_LOAD_IDENTITY:
         case COGL_MATRIX_OP_LOAD:
+          {
+            CoglMatrixEntryLoad *load = (CoglMatrixEntryLoad *)entry;
+            return &load->matrix;
+          }
         case COGL_MATRIX_OP_SAVE:
-          g_warn_if_reached ();
-          continue;
+          {
+            CoglMatrixEntrySave *save = (CoglMatrixEntrySave *)entry;
+            return &save->cache;
+          }
         }
+      g_warn_if_reached ();
+      return NULL;
     }
 
   return NULL;
@@ -599,9 +502,9 @@ cogl_matrix_stack_get_entry (CoglMatrixStack *stack)
  * to a matrix too so if we are querying the inverse matrix we
  * should query from the return matrix so that the result can
  * be cached within the stack. */
-CoglMatrix *
-cogl_matrix_stack_get (CoglMatrixStack *stack,
-                       CoglMatrix *matrix)
+graphene_matrix_t *
+cogl_matrix_stack_get (CoglMatrixStack   *stack,
+                       graphene_matrix_t *matrix)
 {
   return cogl_matrix_entry_get (stack->last_entry, matrix);
 }
@@ -622,8 +525,6 @@ cogl_matrix_stack_new (CoglContext *ctx)
     {
       cogl_matrix_stack_magazine =
         _cogl_magazine_new (sizeof (CoglMatrixEntryFull), 20);
-      cogl_matrix_stack_matrices_magazine =
-        _cogl_magazine_new (sizeof (CoglMatrix), 20);
     }
 
   stack->context = ctx;
@@ -851,7 +752,7 @@ cogl_matrix_entry_equal (CoglMatrixEntry *entry0,
           {
             CoglMatrixEntryMultiply *mult0 = (CoglMatrixEntryMultiply *)entry0;
             CoglMatrixEntryMultiply *mult1 = (CoglMatrixEntryMultiply *)entry1;
-            if (!cogl_matrix_equal (mult0->matrix, mult1->matrix))
+            if (!graphene_matrix_equal (&mult0->matrix, &mult1->matrix))
               return FALSE;
           }
           break;
@@ -862,7 +763,7 @@ cogl_matrix_entry_equal (CoglMatrixEntry *entry0,
             /* There's no need to check any further since an
              * _OP_LOAD makes all the ancestors redundant as far as
              * the final matrix value is concerned. */
-            return cogl_matrix_equal (load0->matrix, load1->matrix);
+            return graphene_matrix_equal (&load0->matrix, &load1->matrix);
           }
         case COGL_MATRIX_OP_SAVE:
           /* We skip over saves above so we shouldn't see save entries */
@@ -948,14 +849,14 @@ cogl_debug_matrix_entry_print (CoglMatrixEntry *entry)
           {
             CoglMatrixEntryMultiply *mult = (CoglMatrixEntryMultiply *)entry;
             g_print ("  MULT:\n");
-            _cogl_matrix_prefix_print ("    ", mult->matrix);
+            graphene_matrix_print (&mult->matrix);
             continue;
           }
         case COGL_MATRIX_OP_LOAD:
           {
             CoglMatrixEntryLoad *load = (CoglMatrixEntryLoad *)entry;
             g_print ("  LOAD:\n");
-            _cogl_matrix_prefix_print ("    ", load->matrix);
+            graphene_matrix_print (&load->matrix);
             continue;
           }
         case COGL_MATRIX_OP_SAVE:
diff --git a/cogl/cogl/cogl-matrix-stack.h b/cogl/cogl/cogl-matrix-stack.h
index 0cda12790239727255b3ed118aaadc3760e1b840..3e330916fb72df1a98608da80830caa0b226ce1d 100644
--- a/cogl/cogl/cogl-matrix-stack.h
+++ b/cogl/cogl/cogl-matrix-stack.h
@@ -39,7 +39,6 @@
 #error "Only <cogl/cogl.h> can be included directly."
 #endif
 
-#include "cogl-matrix.h"
 #include "cogl-context.h"
 
 #include <graphene.h>
@@ -53,11 +52,11 @@
  * transforms of objects, texture transforms, and projective
  * transforms.
  *
- * The #CoglMatrix api provides a good way to manipulate individual
+ * The #graphene_matrix_t api provides a good way to manipulate individual
  * matrices representing a single transformation but if you need to
  * track many-many such transformations for many objects that are
  * organized in a scenegraph for example then using a separate
- * #CoglMatrix for each object may not be the most efficient way.
+ * #graphene_matrix_t for each object may not be the most efficient way.
  *
  * A #CoglMatrixStack enables applications to track lots of
  * transformations that are related to each other in some kind of
@@ -70,7 +69,7 @@
  * transformation. The #CoglMatrixStack API is suited to tracking lots
  * of transformations that fit this kind of model.
  *
- * Compared to using the #CoglMatrix api directly to track many
+ * Compared to using the #graphene_matrix_t api directly to track many
  * related transforms, these can be some advantages to using a
  * #CoglMatrixStack:
  * <itemizedlist>
@@ -83,14 +82,14 @@
  * </itemizedlist>
  *
  * For reference (to give an idea of when a #CoglMatrixStack can
- * provide a space saving) a #CoglMatrix can be expected to take 72
+ * provide a space saving) a #graphene_matrix_t can be expected to take 72
  * bytes whereas a single #CoglMatrixEntry in a #CoglMatrixStack is
  * currently around 32 bytes on a 32bit CPU or 36 bytes on a 64bit
  * CPU. An entry is needed for each individual operation applied to
  * the stack (such as rotate, scale, translate) so if most of your
  * leaf node transformations only need one or two simple operations
  * relative to their parent then a matrix stack will likely take less
- * space than having a #CoglMatrix for each node.
+ * space than having a #graphene_matrix_t for each node.
  *
  * Even without any space saving though the ability to perform fast
  * comparisons and avoid redundant arithmetic (especially sine and
@@ -329,8 +328,8 @@ cogl_matrix_stack_rotate_euler (CoglMatrixStack *stack,
  * Multiplies the current matrix by the given matrix.
  */
 COGL_EXPORT void
-cogl_matrix_stack_multiply (CoglMatrixStack *stack,
-                            const CoglMatrix *matrix);
+cogl_matrix_stack_multiply (CoglMatrixStack         *stack,
+                            const graphene_matrix_t *matrix);
 
 /**
  * cogl_matrix_stack_frustum:
@@ -414,15 +413,15 @@ cogl_matrix_stack_orthographic (CoglMatrixStack *stack,
  * @inverse: (out): The destination for a 4x4 inverse transformation matrix
  *
  * Gets the inverse transform of the current matrix and uses it to
- * initialize a new #CoglMatrix.
+ * initialize a new #graphene_matrix_t.
  *
  * Return value: %TRUE if the inverse was successfully calculated or %FALSE
  *   for degenerate transformations that can't be inverted (in this case the
  *   @inverse matrix will simply be initialized with the identity matrix)
  */
 COGL_EXPORT gboolean
-cogl_matrix_stack_get_inverse (CoglMatrixStack *stack,
-                               CoglMatrix *inverse);
+cogl_matrix_stack_get_inverse (CoglMatrixStack   *stack,
+                               graphene_matrix_t *inverse);
 
 /**
  * cogl_matrix_stack_get_entry:
@@ -450,13 +449,13 @@ cogl_matrix_stack_get_entry (CoglMatrixStack *stack);
  * @stack: A #CoglMatrixStack
  * @matrix: (out): The potential destination for the current matrix
  *
- * Resolves the current @stack transform into a #CoglMatrix by
+ * Resolves the current @stack transform into a #graphene_matrix_t by
  * combining the operations that have been applied to build up the
  * current transform.
  *
  * There are two possible ways that this function may return its
  * result depending on whether the stack is able to directly point
- * to an internal #CoglMatrix or whether the result needs to be
+ * to an internal #graphene_matrix_t or whether the result needs to be
  * composed of multiple operations.
  *
  * If an internal matrix contains the required result then this
@@ -471,9 +470,9 @@ cogl_matrix_stack_get_entry (CoglMatrixStack *stack);
  *               and in that case @matrix will be initialized with
  *               the value of the current transform.
  */
-COGL_EXPORT CoglMatrix *
-cogl_matrix_stack_get (CoglMatrixStack *stack,
-                       CoglMatrix *matrix);
+COGL_EXPORT graphene_matrix_t *
+cogl_matrix_stack_get (CoglMatrixStack   *stack,
+                       graphene_matrix_t *matrix);
 
 /**
  * cogl_matrix_entry_get:
@@ -481,13 +480,13 @@ cogl_matrix_stack_get (CoglMatrixStack *stack,
  * @matrix: (out): The potential destination for the transform as
  *                 a matrix
  *
- * Resolves the current @entry transform into a #CoglMatrix by
+ * Resolves the current @entry transform into a #graphene_matrix_t by
  * combining the sequence of operations that have been applied to
  * build up the current transform.
  *
  * There are two possible ways that this function may return its
  * result depending on whether it's possible to directly point
- * to an internal #CoglMatrix or whether the result needs to be
+ * to an internal #graphene_matrix_t or whether the result needs to be
  * composed of multiple operations.
  *
  * If an internal matrix contains the required result then this
@@ -498,18 +497,18 @@ cogl_matrix_stack_get (CoglMatrixStack *stack,
  * <note>@matrix will be left untouched if a direct pointer is
  * returned.</note>
  *
- * Return value: A direct pointer to a #CoglMatrix transform or %NULL
+ * Return value: A direct pointer to a #graphene_matrix_t transform or %NULL
  *               and in that case @matrix will be initialized with
  *               the effective transform represented by @entry.
  */
-COGL_EXPORT CoglMatrix *
-cogl_matrix_entry_get (CoglMatrixEntry *entry,
-                       CoglMatrix *matrix);
+COGL_EXPORT graphene_matrix_t *
+cogl_matrix_entry_get (CoglMatrixEntry   *entry,
+                       graphene_matrix_t *matrix);
 
 /**
  * cogl_matrix_stack_set:
  * @stack: A #CoglMatrixStack
- * @matrix: A #CoglMatrix replace the current matrix value with
+ * @matrix: A #graphene_matrix_t replace the current matrix value with
  *
  * Replaces the current @stack matrix value with the value of @matrix.
  * This effectively discards any other operations that were applied
@@ -517,8 +516,8 @@ cogl_matrix_entry_get (CoglMatrixEntry *entry,
  * the stack was initialized.
  */
 COGL_EXPORT void
-cogl_matrix_stack_set (CoglMatrixStack *stack,
-                       const CoglMatrix *matrix);
+cogl_matrix_stack_set (CoglMatrixStack         *stack,
+                       const graphene_matrix_t *matrix);
 
 /**
  * cogl_is_matrix_stack:
diff --git a/cogl/cogl/cogl-matrix.c b/cogl/cogl/cogl-matrix.c
deleted file mode 100644
index 695887a70a7e1e2b24ec5987339d6e9537faa9d1..0000000000000000000000000000000000000000
--- a/cogl/cogl/cogl-matrix.c
+++ /dev/null
@@ -1,2241 +0,0 @@
-/*
- * Cogl
- *
- * A Low Level GPU Graphics and Utilities API
- *
- * Copyright (C) 2009,2010,2011 Intel Corporation.
- * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- * Authors:
- *   Robert Bragg <robert@linux.intel.com>
- */
-/*
- * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
- * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Note: a lot of this code is based on code that was taken from Mesa.
- *
- * Changes compared to the original code from Mesa:
- *
- * - instead of allocating matrix->m and matrix->inv using malloc, our
- *   public CoglMatrix typedef is large enough to directly contain the
- *   matrix, its inverse, a type and a set of flags.
- * - instead of having a _cogl_matrix_analyse which updates the type,
- *   flags and inverse, we have _cogl_matrix_update_inverse which
- *   essentially does the same thing (internally making use of
- *   _cogl_matrix_update_type_and_flags()) but with additional guards in
- *   place to bail out when the inverse matrix is still valid.
- * - when initializing a matrix with the identity matrix we don't
- *   immediately initialize the inverse matrix; rather we just set the
- *   dirty flag for the inverse (since it's likely the user won't request
- *   the inverse of the identity matrix)
- */
-
-#include "cogl-config.h"
-
-#include <cogl-util.h>
-#include <cogl-debug.h>
-#include <cogl-matrix.h>
-#include <cogl-matrix-private.h>
-
-#include <glib.h>
-#include <math.h>
-#include <string.h>
-
-#include <cogl-gtype-private.h>
-COGL_GTYPE_DEFINE_BOXED (Matrix, matrix,
-                         cogl_matrix_copy,
-                         cogl_matrix_free);
-
-/*
- * Symbolic names to some of the entries in the matrix
- *
- * These are handy for the viewport mapping, which is expressed as a matrix.
- */
-#define MAT_SX 0
-#define MAT_SY 5
-#define MAT_SZ 10
-#define MAT_TX 12
-#define MAT_TY 13
-#define MAT_TZ 14
-
-/*
- * These identify different kinds of 4x4 transformation matrices and we use
- * this information to find fast-paths when available.
- */
-enum CoglMatrixType {
-   COGL_MATRIX_TYPE_GENERAL,	/**< general 4x4 matrix */
-   COGL_MATRIX_TYPE_IDENTITY,	/**< identity matrix */
-   COGL_MATRIX_TYPE_3D_NO_ROT,	/**< orthogonal projection and others... */
-   COGL_MATRIX_TYPE_PERSPECTIVE,	/**< perspective projection matrix */
-   COGL_MATRIX_TYPE_2D,		/**< 2-D transformation */
-   COGL_MATRIX_TYPE_2D_NO_ROT,	/**< 2-D scale & translate only */
-   COGL_MATRIX_TYPE_3D,		/**< 3-D transformation */
-   COGL_MATRIX_N_TYPES
-} ;
-
-#define DEG2RAD (G_PI/180.0)
-
-/* Dot product of two 2-element vectors */
-#define DOT2(A,B)  ( (A)[0]*(B)[0] + (A)[1]*(B)[1] )
-
-/* Dot product of two 3-element vectors */
-#define DOT3(A,B)  ( (A)[0]*(B)[0] + (A)[1]*(B)[1] + (A)[2]*(B)[2] )
-
-#define CROSS3(N, U, V) \
-do { \
-    (N)[0] = (U)[1]*(V)[2] - (U)[2]*(V)[1]; \
-    (N)[1] = (U)[2]*(V)[0] - (U)[0]*(V)[2]; \
-    (N)[2] = (U)[0]*(V)[1] - (U)[1]*(V)[0]; \
-} while (0)
-
-#define SUB_3V(DST, SRCA, SRCB) \
-do { \
-    (DST)[0] = (SRCA)[0] - (SRCB)[0]; \
-    (DST)[1] = (SRCA)[1] - (SRCB)[1]; \
-    (DST)[2] = (SRCA)[2] - (SRCB)[2]; \
-} while (0)
-
-#define LEN_SQUARED_3FV( V ) ((V)[0]*(V)[0]+(V)[1]*(V)[1]+(V)[2]*(V)[2])
-
-/*
- * \defgroup MatFlags MAT_FLAG_XXX-flags
- *
- * Bitmasks to indicate different kinds of 4x4 matrices in CoglMatrix::flags
- */
-#define MAT_FLAG_IDENTITY       0     /*< is an identity matrix flag.
-                                       *   (Not actually used - the identity
-                                       *   matrix is identified by the absence
-                                       *   of all other flags.)
-                                       */
-#define MAT_FLAG_GENERAL        0x1   /*< is a general matrix flag */
-#define MAT_FLAG_ROTATION       0x2   /*< is a rotation matrix flag */
-#define MAT_FLAG_TRANSLATION    0x4   /*< is a translation matrix flag */
-#define MAT_FLAG_UNIFORM_SCALE  0x8   /*< is an uniform scaling matrix flag */
-#define MAT_FLAG_GENERAL_SCALE  0x10  /*< is a general scaling matrix flag */
-#define MAT_FLAG_GENERAL_3D     0x20  /*< general 3D matrix flag */
-#define MAT_FLAG_PERSPECTIVE    0x40  /*< is a perspective proj matrix flag */
-#define MAT_FLAG_SINGULAR       0x80  /*< is a singular matrix flag */
-#define MAT_DIRTY_TYPE          0x100  /*< matrix type is dirty */
-#define MAT_DIRTY_FLAGS         0x200  /*< matrix flags are dirty */
-#define MAT_DIRTY_INVERSE       0x400  /*< matrix inverse is dirty */
-
-/* angle preserving matrix flags mask */
-#define MAT_FLAGS_ANGLE_PRESERVING (MAT_FLAG_ROTATION | \
-				    MAT_FLAG_TRANSLATION | \
-				    MAT_FLAG_UNIFORM_SCALE)
-
-/* geometry related matrix flags mask */
-#define MAT_FLAGS_GEOMETRY (MAT_FLAG_GENERAL | \
-			    MAT_FLAG_ROTATION | \
-			    MAT_FLAG_TRANSLATION | \
-			    MAT_FLAG_UNIFORM_SCALE | \
-			    MAT_FLAG_GENERAL_SCALE | \
-			    MAT_FLAG_GENERAL_3D | \
-			    MAT_FLAG_PERSPECTIVE | \
-	                    MAT_FLAG_SINGULAR)
-
-/* length preserving matrix flags mask */
-#define MAT_FLAGS_LENGTH_PRESERVING (MAT_FLAG_ROTATION | \
-				     MAT_FLAG_TRANSLATION)
-
-
-/* 3D (non-perspective) matrix flags mask */
-#define MAT_FLAGS_3D (MAT_FLAG_ROTATION | \
-		      MAT_FLAG_TRANSLATION | \
-		      MAT_FLAG_UNIFORM_SCALE | \
-		      MAT_FLAG_GENERAL_SCALE | \
-		      MAT_FLAG_GENERAL_3D)
-
-/* dirty matrix flags mask */
-#define MAT_DIRTY_ALL      (MAT_DIRTY_TYPE | \
-			    MAT_DIRTY_FLAGS | \
-			    MAT_DIRTY_INVERSE)
-
-
-/*
- * Test geometry related matrix flags.
- *
- * @mat a pointer to a CoglMatrix structure.
- * @a flags mask.
- *
- * Returns: non-zero if all geometry related matrix flags are contained within
- * the mask, or zero otherwise.
- */
-#define TEST_MAT_FLAGS(mat, a)  \
-    ((MAT_FLAGS_GEOMETRY & (~(a)) & ((mat)->flags) ) == 0)
-
-
-
-/*
- * Names of the corresponding CoglMatrixType values.
- */
-static const char *types[] = {
-   "COGL_MATRIX_TYPE_GENERAL",
-   "COGL_MATRIX_TYPE_IDENTITY",
-   "COGL_MATRIX_TYPE_3D_NO_ROT",
-   "COGL_MATRIX_TYPE_PERSPECTIVE",
-   "COGL_MATRIX_TYPE_2D",
-   "COGL_MATRIX_TYPE_2D_NO_ROT",
-   "COGL_MATRIX_TYPE_3D"
-};
-
-
-/*
- * Identity matrix.
- */
-static float identity[16] = {
-   1.0, 0.0, 0.0, 0.0,
-   0.0, 1.0, 0.0, 0.0,
-   0.0, 0.0, 1.0, 0.0,
-   0.0, 0.0, 0.0, 1.0
-};
-
-
-#define A(row,col)  a[(col<<2)+row]
-#define B(row,col)  b[(col<<2)+row]
-#define R(row,col)  result[(col<<2)+row]
-
-/*
- * Perform a full 4x4 matrix multiplication.
- *
- * <note>It's assumed that @result != @b. @product == @a is allowed.</note>
- *
- * <note>KW: 4*16 = 64 multiplications</note>
- */
-static void
-matrix_multiply4x4 (float *result, const float *a, const float *b)
-{
-  int i;
-  for (i = 0; i < 4; i++)
-    {
-      const float ai0 = A(i,0),  ai1=A(i,1),  ai2=A(i,2),  ai3=A(i,3);
-      R(i,0) = ai0 * B(0,0) + ai1 * B(1,0) + ai2 * B(2,0) + ai3 * B(3,0);
-      R(i,1) = ai0 * B(0,1) + ai1 * B(1,1) + ai2 * B(2,1) + ai3 * B(3,1);
-      R(i,2) = ai0 * B(0,2) + ai1 * B(1,2) + ai2 * B(2,2) + ai3 * B(3,2);
-      R(i,3) = ai0 * B(0,3) + ai1 * B(1,3) + ai2 * B(2,3) + ai3 * B(3,3);
-    }
-}
-
-/*
- * Multiply two matrices known to occupy only the top three rows, such
- * as typical model matrices, and orthogonal matrices.
- *
- * @a matrix.
- * @b matrix.
- * @product will receive the product of \p a and \p b.
- */
-static void
-matrix_multiply3x4 (float *result, const float *a, const float *b)
-{
-  int i;
-  for (i = 0; i < 3; i++)
-    {
-      const float ai0 = A(i,0), ai1 = A(i,1), ai2 = A(i,2), ai3 = A(i,3);
-      R(i,0) = ai0 * B(0,0) + ai1 * B(1,0) + ai2 * B(2,0);
-      R(i,1) = ai0 * B(0,1) + ai1 * B(1,1) + ai2 * B(2,1);
-      R(i,2) = ai0 * B(0,2) + ai1 * B(1,2) + ai2 * B(2,2);
-      R(i,3) = ai0 * B(0,3) + ai1 * B(1,3) + ai2 * B(2,3) + ai3;
-    }
-  R(3,0) = 0;
-  R(3,1) = 0;
-  R(3,2) = 0;
-  R(3,3) = 1;
-}
-
-#undef A
-#undef B
-#undef R
-
-/*
- * Multiply a matrix by an array of floats with known properties.
- *
- * @mat pointer to a CoglMatrix structure containing the left multiplication
- * matrix, and that will receive the product result.
- * @m right multiplication matrix array.
- * @flags flags of the matrix \p m.
- *
- * Joins both flags and marks the type and inverse as dirty.  Calls
- * matrix_multiply3x4() if both matrices are 3D, or matrix_multiply4x4()
- * otherwise.
- */
-static void
-matrix_multiply_array_with_flags (CoglMatrix *result,
-                                  const float *array,
-                                  unsigned int flags)
-{
-  result->flags |= (flags | MAT_DIRTY_TYPE | MAT_DIRTY_INVERSE);
-
-  if (TEST_MAT_FLAGS (result, MAT_FLAGS_3D))
-    matrix_multiply3x4 ((float *)result, (float *)result, array);
-  else
-    matrix_multiply4x4 ((float *)result, (float *)result, array);
-}
-
-/* Joins both flags and marks the type and inverse as dirty.  Calls
- * matrix_multiply3x4() if both matrices are 3D, or matrix_multiply4x4()
- * otherwise.
- */
-static void
-_cogl_matrix_multiply (CoglMatrix *result,
-                       const CoglMatrix *a,
-                       const CoglMatrix *b)
-{
-  result->flags = (a->flags |
-                   b->flags |
-                   MAT_DIRTY_TYPE |
-                   MAT_DIRTY_INVERSE);
-
-  if (TEST_MAT_FLAGS(result, MAT_FLAGS_3D))
-    matrix_multiply3x4 ((float *)result, (float *)a, (float *)b);
-  else
-    matrix_multiply4x4 ((float *)result, (float *)a, (float *)b);
-}
-
-void
-cogl_matrix_multiply (CoglMatrix *result,
-		      const CoglMatrix *a,
-		      const CoglMatrix *b)
-{
-  _cogl_matrix_multiply (result, a, b);
-  _COGL_MATRIX_DEBUG_PRINT (result);
-}
-
-#if 0
-/* Marks the matrix flags with general flag, and type and inverse dirty flags.
- * Calls matrix_multiply4x4() for the multiplication.
- */
-static void
-_cogl_matrix_multiply_array (CoglMatrix *result, const float *array)
-{
-  result->flags |= (MAT_FLAG_GENERAL |
-                  MAT_DIRTY_TYPE |
-                  MAT_DIRTY_INVERSE |
-                  MAT_DIRTY_FLAGS);
-
-  matrix_multiply4x4 ((float *)result, (float *)result, (float *)array);
-}
-#endif
-
-/*
- * Print a matrix array.
- *
- * Called by _cogl_matrix_print() to print a matrix or its inverse.
- */
-static void
-print_matrix_floats (const char *prefix, const float m[16])
-{
-  int i;
-  for (i = 0;i < 4; i++)
-    g_print ("%s\t%f %f %f %f\n", prefix, m[i], m[4+i], m[8+i], m[12+i] );
-}
-
-void
-_cogl_matrix_prefix_print (const char *prefix, const CoglMatrix *matrix)
-{
-  if (!(matrix->flags & MAT_DIRTY_TYPE))
-    {
-      g_return_if_fail (matrix->type < COGL_MATRIX_N_TYPES);
-      g_print ("%sMatrix type: %s, flags: %x\n",
-               prefix, types[matrix->type], (int)matrix->flags);
-    }
-  else
-    g_print ("%sMatrix type: DIRTY, flags: %x\n",
-             prefix, (int)matrix->flags);
-
-  print_matrix_floats (prefix, (float *)matrix);
-  g_print ("%sInverse: \n", prefix);
-  if (!(matrix->flags & MAT_DIRTY_INVERSE))
-    {
-      float prod[16];
-      print_matrix_floats (prefix, matrix->inv);
-      matrix_multiply4x4 (prod, (float *)matrix, matrix->inv);
-      g_print ("%sMat * Inverse:\n", prefix);
-      print_matrix_floats (prefix, prod);
-    }
-  else
-    g_print ("%s  - not available\n", prefix);
-}
-
-/*
- * Dumps the contents of a CoglMatrix structure.
- */
-void
-cogl_debug_matrix_print (const CoglMatrix *matrix)
-{
-  _cogl_matrix_prefix_print ("", matrix);
-}
-
-/*
- * References an element of 4x4 matrix.
- *
- * @m matrix array.
- * @c column of the desired element.
- * @r row of the desired element.
- *
- * Returns: value of the desired element.
- *
- * Calculate the linear storage index of the element and references it.
- */
-#define MAT(m,r,c) (m)[(c)*4+(r)]
-
-/*
- * Swaps the values of two floating pointer variables.
- *
- * Used by invert_matrix_general() to swap the row pointers.
- */
-#define SWAP_ROWS(a, b) { float *_tmp = a; (a)=(b); (b)=_tmp; }
-
-/*
- * Compute inverse of 4x4 transformation matrix.
- *
- * @mat pointer to a CoglMatrix structure. The matrix inverse will be
- * stored in the CoglMatrix::inv attribute.
- *
- * Returns: %TRUE for success, %FALSE for failure (\p singular matrix).
- *
- * \author
- * Code contributed by Jacques Leroy jle@star.be
- *
- * Calculates the inverse matrix by performing the gaussian matrix reduction
- * with partial pivoting followed by back/substitution with the loops manually
- * unrolled.
- */
-static gboolean
-invert_matrix_general (CoglMatrix *matrix)
-{
-  const float *m = (float *)matrix;
-  float *out = matrix->inv;
-  float wtmp[4][8];
-  float m0, m1, m2, m3, s;
-  float *r0, *r1, *r2, *r3;
-
-  r0 = wtmp[0], r1 = wtmp[1], r2 = wtmp[2], r3 = wtmp[3];
-
-  r0[0] = MAT (m, 0, 0), r0[1] = MAT (m, 0, 1),
-    r0[2] = MAT (m, 0, 2), r0[3] = MAT (m, 0, 3),
-    r0[4] = 1.0, r0[5] = r0[6] = r0[7] = 0.0,
-
-    r1[0] = MAT (m, 1, 0), r1[1] = MAT (m, 1, 1),
-    r1[2] = MAT (m, 1, 2), r1[3] = MAT (m, 1, 3),
-    r1[5] = 1.0, r1[4] = r1[6] = r1[7] = 0.0,
-
-    r2[0] = MAT (m, 2, 0), r2[1] = MAT (m, 2, 1),
-    r2[2] = MAT (m, 2, 2), r2[3] = MAT (m, 2, 3),
-    r2[6] = 1.0, r2[4] = r2[5] = r2[7] = 0.0,
-
-    r3[0] = MAT (m, 3, 0), r3[1] = MAT (m, 3, 1),
-    r3[2] = MAT (m, 3, 2), r3[3] = MAT (m, 3, 3),
-    r3[7] = 1.0, r3[4] = r3[5] = r3[6] = 0.0;
-
-  /* choose pivot - or die */
-  if (fabsf (r3[0]) > fabsf (r2[0]))
-    SWAP_ROWS (r3, r2);
-  if (fabsf (r2[0]) > fabsf (r1[0]))
-    SWAP_ROWS (r2, r1);
-  if (fabsf (r1[0]) > fabsf (r0[0]))
-    SWAP_ROWS (r1, r0);
-  if (0.0 == r0[0])
-    return FALSE;
-
-  /* eliminate first variable     */
-  m1 = r1[0]/r0[0]; m2 = r2[0]/r0[0]; m3 = r3[0]/r0[0];
-  s = r0[1]; r1[1] -= m1 * s; r2[1] -= m2 * s; r3[1] -= m3 * s;
-  s = r0[2]; r1[2] -= m1 * s; r2[2] -= m2 * s; r3[2] -= m3 * s;
-  s = r0[3]; r1[3] -= m1 * s; r2[3] -= m2 * s; r3[3] -= m3 * s;
-  s = r0[4];
-  if (s != 0.0) { r1[4] -= m1 * s; r2[4] -= m2 * s; r3[4] -= m3 * s; }
-  s = r0[5];
-  if (s != 0.0) { r1[5] -= m1 * s; r2[5] -= m2 * s; r3[5] -= m3 * s; }
-  s = r0[6];
-  if (s != 0.0) { r1[6] -= m1 * s; r2[6] -= m2 * s; r3[6] -= m3 * s; }
-  s = r0[7];
-  if (s != 0.0) { r1[7] -= m1 * s; r2[7] -= m2 * s; r3[7] -= m3 * s; }
-
-  /* choose pivot - or die */
-  if (fabsf (r3[1]) > fabsf (r2[1]))
-    SWAP_ROWS (r3, r2);
-  if (fabsf (r2[1]) > fabsf (r1[1]))
-    SWAP_ROWS (r2, r1);
-  if (0.0 == r1[1])
-    return FALSE;
-
-  /* eliminate second variable */
-  m2 = r2[1] / r1[1]; m3 = r3[1] / r1[1];
-  r2[2] -= m2 * r1[2]; r3[2] -= m3 * r1[2];
-  r2[3] -= m2 * r1[3]; r3[3] -= m3 * r1[3];
-  s = r1[4]; if (0.0 != s) { r2[4] -= m2 * s; r3[4] -= m3 * s; }
-  s = r1[5]; if (0.0 != s) { r2[5] -= m2 * s; r3[5] -= m3 * s; }
-  s = r1[6]; if (0.0 != s) { r2[6] -= m2 * s; r3[6] -= m3 * s; }
-  s = r1[7]; if (0.0 != s) { r2[7] -= m2 * s; r3[7] -= m3 * s; }
-
-  /* choose pivot - or die */
-  if (fabsf (r3[2]) > fabsf (r2[2]))
-    SWAP_ROWS (r3, r2);
-  if (0.0 == r2[2])
-    return FALSE;
-
-  /* eliminate third variable */
-  m3 = r3[2] / r2[2];
-  r3[3] -= m3 * r2[3], r3[4] -= m3 * r2[4],
-    r3[5] -= m3 * r2[5], r3[6] -= m3 * r2[6],
-    r3[7] -= m3 * r2[7];
-
-  /* last check */
-  if (0.0 == r3[3])
-    return FALSE;
-
-  s = 1.0f / r3[3];             /* now back substitute row 3 */
-  r3[4] *= s; r3[5] *= s; r3[6] *= s; r3[7] *= s;
-
-  m2 = r2[3];                 /* now back substitute row 2 */
-  s  = 1.0f / r2[2];
-  r2[4] = s * (r2[4] - r3[4] * m2), r2[5] = s * (r2[5] - r3[5] * m2),
-    r2[6] = s * (r2[6] - r3[6] * m2), r2[7] = s * (r2[7] - r3[7] * m2);
-  m1 = r1[3];
-  r1[4] -= r3[4] * m1, r1[5] -= r3[5] * m1,
-    r1[6] -= r3[6] * m1, r1[7] -= r3[7] * m1;
-  m0 = r0[3];
-  r0[4] -= r3[4] * m0, r0[5] -= r3[5] * m0,
-    r0[6] -= r3[6] * m0, r0[7] -= r3[7] * m0;
-
-  m1 = r1[2];                 /* now back substitute row 1 */
-  s  = 1.0f / r1[1];
-  r1[4] = s * (r1[4] - r2[4] * m1), r1[5] = s * (r1[5] - r2[5] * m1),
-    r1[6] = s * (r1[6] - r2[6] * m1), r1[7] = s * (r1[7] - r2[7] * m1);
-  m0 = r0[2];
-  r0[4] -= r2[4] * m0, r0[5] -= r2[5] * m0,
-    r0[6] -= r2[6] * m0, r0[7] -= r2[7] * m0;
-
-  m0 = r0[1];                 /* now back substitute row 0 */
-  s  = 1.0f / r0[0];
-  r0[4] = s * (r0[4] - r1[4] * m0), r0[5] = s * (r0[5] - r1[5] * m0),
-    r0[6] = s * (r0[6] - r1[6] * m0), r0[7] = s * (r0[7] - r1[7] * m0);
-
-  MAT (out, 0, 0) = r0[4]; MAT (out, 0, 1) = r0[5],
-    MAT (out, 0, 2) = r0[6]; MAT (out, 0, 3) = r0[7],
-    MAT (out, 1, 0) = r1[4]; MAT (out, 1, 1) = r1[5],
-    MAT (out, 1, 2) = r1[6]; MAT (out, 1, 3) = r1[7],
-    MAT (out, 2, 0) = r2[4]; MAT (out, 2, 1) = r2[5],
-    MAT (out, 2, 2) = r2[6]; MAT (out, 2, 3) = r2[7],
-    MAT (out, 3, 0) = r3[4]; MAT (out, 3, 1) = r3[5],
-    MAT (out, 3, 2) = r3[6]; MAT (out, 3, 3) = r3[7];
-
-  return TRUE;
-}
-#undef SWAP_ROWS
-
-/*
- * Compute inverse of a general 3d transformation matrix.
- *
- * @mat pointer to a CoglMatrix structure. The matrix inverse will be
- * stored in the CoglMatrix::inv attribute.
- *
- * Returns: %TRUE for success, %FALSE for failure (\p singular matrix).
- *
- * \author Adapted from graphics gems II.
- *
- * Calculates the inverse of the upper left by first calculating its
- * determinant and multiplying it to the symmetric adjust matrix of each
- * element. Finally deals with the translation part by transforming the
- * original translation vector using by the calculated submatrix inverse.
- */
-static gboolean
-invert_matrix_3d_general (CoglMatrix *matrix)
-{
-  const float *in = (float *)matrix;
-  float *out = matrix->inv;
-  float pos, neg, t;
-  float det;
-
-  /* Calculate the determinant of upper left 3x3 submatrix and
-   * determine if the matrix is singular.
-   */
-  pos = neg = 0.0;
-  t =  MAT (in,0,0) * MAT (in,1,1) * MAT (in,2,2);
-  if (t >= 0.0) pos += t; else neg += t;
-
-  t =  MAT (in,1,0) * MAT (in,2,1) * MAT (in,0,2);
-  if (t >= 0.0) pos += t; else neg += t;
-
-  t =  MAT (in,2,0) * MAT (in,0,1) * MAT (in,1,2);
-  if (t >= 0.0) pos += t; else neg += t;
-
-  t = -MAT (in,2,0) * MAT (in,1,1) * MAT (in,0,2);
-  if (t >= 0.0) pos += t; else neg += t;
-
-  t = -MAT (in,1,0) * MAT (in,0,1) * MAT (in,2,2);
-  if (t >= 0.0) pos += t; else neg += t;
-
-  t = -MAT (in,0,0) * MAT (in,2,1) * MAT (in,1,2);
-  if (t >= 0.0) pos += t; else neg += t;
-
-  det = pos + neg;
-
-  if (det*det < 1e-25)
-    return FALSE;
-
-  det = 1.0f / det;
-  MAT (out,0,0) =
-    (  (MAT (in, 1, 1)*MAT (in, 2, 2) - MAT (in, 2, 1)*MAT (in, 1, 2) )*det);
-  MAT (out,0,1) =
-    (- (MAT (in, 0, 1)*MAT (in, 2, 2) - MAT (in, 2, 1)*MAT (in, 0, 2) )*det);
-  MAT (out,0,2) =
-    (  (MAT (in, 0, 1)*MAT (in, 1, 2) - MAT (in, 1, 1)*MAT (in, 0, 2) )*det);
-  MAT (out,1,0) =
-    (- (MAT (in,1,0)*MAT (in,2,2) - MAT (in,2,0)*MAT (in,1,2) )*det);
-  MAT (out,1,1) =
-    (  (MAT (in,0,0)*MAT (in,2,2) - MAT (in,2,0)*MAT (in,0,2) )*det);
-  MAT (out,1,2) =
-    (- (MAT (in,0,0)*MAT (in,1,2) - MAT (in,1,0)*MAT (in,0,2) )*det);
-  MAT (out,2,0) =
-    (  (MAT (in,1,0)*MAT (in,2,1) - MAT (in,2,0)*MAT (in,1,1) )*det);
-  MAT (out,2,1) =
-    (- (MAT (in,0,0)*MAT (in,2,1) - MAT (in,2,0)*MAT (in,0,1) )*det);
-  MAT (out,2,2) =
-    (  (MAT (in,0,0)*MAT (in,1,1) - MAT (in,1,0)*MAT (in,0,1) )*det);
-
-  /* Do the translation part */
-  MAT (out,0,3) = - (MAT (in, 0, 3) * MAT (out, 0, 0) +
-                    MAT (in, 1, 3) * MAT (out, 0, 1) +
-                    MAT (in, 2, 3) * MAT (out, 0, 2) );
-  MAT (out,1,3) = - (MAT (in, 0, 3) * MAT (out, 1, 0) +
-                    MAT (in, 1, 3) * MAT (out, 1, 1) +
-                    MAT (in, 2, 3) * MAT (out, 1, 2) );
-  MAT (out,2,3) = - (MAT (in, 0, 3) * MAT (out, 2 ,0) +
-                    MAT (in, 1, 3) * MAT (out, 2, 1) +
-                    MAT (in, 2, 3) * MAT (out, 2, 2) );
-
-  return TRUE;
-}
-
-/*
- * Compute inverse of a 3d transformation matrix.
- *
- * @mat pointer to a CoglMatrix structure. The matrix inverse will be
- * stored in the CoglMatrix::inv attribute.
- *
- * Returns: %TRUE for success, %FALSE for failure (\p singular matrix).
- *
- * If the matrix is not an angle preserving matrix then calls
- * invert_matrix_3d_general for the actual calculation. Otherwise calculates
- * the inverse matrix analyzing and inverting each of the scaling, rotation and
- * translation parts.
- */
-static gboolean
-invert_matrix_3d (CoglMatrix *matrix)
-{
-  const float *in = (float *)matrix;
-  float *out = matrix->inv;
-
-  memcpy (out, identity, 16 * sizeof (float));
-
-  if (!TEST_MAT_FLAGS(matrix, MAT_FLAGS_ANGLE_PRESERVING))
-    return invert_matrix_3d_general (matrix);
-
-  if (matrix->flags & MAT_FLAG_UNIFORM_SCALE)
-    {
-      float scale = (MAT (in, 0, 0) * MAT (in, 0, 0) +
-                     MAT (in, 0, 1) * MAT (in, 0, 1) +
-                     MAT (in, 0, 2) * MAT (in, 0, 2));
-
-      if (scale == 0.0)
-        return FALSE;
-
-      scale = 1.0f / scale;
-
-      /* Transpose and scale the 3 by 3 upper-left submatrix. */
-      MAT (out, 0, 0) = scale * MAT (in, 0, 0);
-      MAT (out, 1, 0) = scale * MAT (in, 0, 1);
-      MAT (out, 2, 0) = scale * MAT (in, 0, 2);
-      MAT (out, 0, 1) = scale * MAT (in, 1, 0);
-      MAT (out, 1, 1) = scale * MAT (in, 1, 1);
-      MAT (out, 2, 1) = scale * MAT (in, 1, 2);
-      MAT (out, 0, 2) = scale * MAT (in, 2, 0);
-      MAT (out, 1, 2) = scale * MAT (in, 2, 1);
-      MAT (out, 2, 2) = scale * MAT (in, 2, 2);
-    }
-  else if (matrix->flags & MAT_FLAG_ROTATION)
-    {
-      /* Transpose the 3 by 3 upper-left submatrix. */
-      MAT (out, 0, 0) = MAT (in, 0, 0);
-      MAT (out, 1, 0) = MAT (in, 0, 1);
-      MAT (out, 2, 0) = MAT (in, 0, 2);
-      MAT (out, 0, 1) = MAT (in, 1, 0);
-      MAT (out, 1, 1) = MAT (in, 1, 1);
-      MAT (out, 2, 1) = MAT (in, 1, 2);
-      MAT (out, 0, 2) = MAT (in, 2, 0);
-      MAT (out, 1, 2) = MAT (in, 2, 1);
-      MAT (out, 2, 2) = MAT (in, 2, 2);
-    }
-  else
-    {
-      /* pure translation */
-      memcpy (out, identity, 16 * sizeof (float));
-      MAT (out, 0, 3) = - MAT (in, 0, 3);
-      MAT (out, 1, 3) = - MAT (in, 1, 3);
-      MAT (out, 2, 3) = - MAT (in, 2, 3);
-      return TRUE;
-    }
-
-  if (matrix->flags & MAT_FLAG_TRANSLATION)
-    {
-      /* Do the translation part */
-      MAT (out,0,3) = - (MAT (in, 0, 3) * MAT (out, 0, 0) +
-                        MAT (in, 1, 3) * MAT (out, 0, 1) +
-                        MAT (in, 2, 3) * MAT (out, 0, 2) );
-      MAT (out,1,3) = - (MAT (in, 0, 3) * MAT (out, 1, 0) +
-                        MAT (in, 1, 3) * MAT (out, 1, 1) +
-                        MAT (in, 2, 3) * MAT (out, 1, 2) );
-      MAT (out,2,3) = - (MAT (in, 0, 3) * MAT (out, 2, 0) +
-                        MAT (in, 1, 3) * MAT (out, 2, 1) +
-                        MAT (in, 2, 3) * MAT (out, 2, 2) );
-    }
-  else
-    MAT (out, 0, 3) = MAT (out, 1, 3) = MAT (out, 2, 3) = 0.0;
-
-  return TRUE;
-}
-
-/*
- * Compute inverse of an identity transformation matrix.
- *
- * @mat pointer to a CoglMatrix structure. The matrix inverse will be
- * stored in the CoglMatrix::inv attribute.
- *
- * Returns: always %TRUE.
- *
- * Simply copies identity into CoglMatrix::inv.
- */
-static gboolean
-invert_matrix_identity (CoglMatrix *matrix)
-{
-  memcpy (matrix->inv, identity, 16 * sizeof (float));
-  return TRUE;
-}
-
-/*
- * Compute inverse of a no-rotation 3d transformation matrix.
- *
- * @mat pointer to a CoglMatrix structure. The matrix inverse will be
- * stored in the CoglMatrix::inv attribute.
- *
- * Returns: %TRUE for success, %FALSE for failure (\p singular matrix).
- *
- * Calculates the
- */
-static gboolean
-invert_matrix_3d_no_rotation (CoglMatrix *matrix)
-{
-  const float *in = (float *)matrix;
-  float *out = matrix->inv;
-
-  if (MAT (in,0,0) == 0 || MAT (in,1,1) == 0 || MAT (in,2,2) == 0)
-    return FALSE;
-
-  memcpy (out, identity, 16 * sizeof (float));
-  MAT (out,0,0) = 1.0f / MAT (in,0,0);
-  MAT (out,1,1) = 1.0f / MAT (in,1,1);
-  MAT (out,2,2) = 1.0f / MAT (in,2,2);
-
-  if (matrix->flags & MAT_FLAG_TRANSLATION)
-    {
-      MAT (out,0,3) = - (MAT (in,0,3) * MAT (out,0,0));
-      MAT (out,1,3) = - (MAT (in,1,3) * MAT (out,1,1));
-      MAT (out,2,3) = - (MAT (in,2,3) * MAT (out,2,2));
-    }
-
-  return TRUE;
-}
-
-/*
- * Compute inverse of a no-rotation 2d transformation matrix.
- *
- * @mat pointer to a CoglMatrix structure. The matrix inverse will be
- * stored in the CoglMatrix::inv attribute.
- *
- * Returns: %TRUE for success, %FALSE for failure (\p singular matrix).
- *
- * Calculates the inverse matrix by applying the inverse scaling and
- * translation to the identity matrix.
- */
-static gboolean
-invert_matrix_2d_no_rotation (CoglMatrix *matrix)
-{
-  const float *in = (float *)matrix;
-  float *out = matrix->inv;
-
-  if (MAT (in, 0, 0) == 0 || MAT (in, 1, 1) == 0)
-    return FALSE;
-
-  memcpy (out, identity, 16 * sizeof (float));
-  MAT (out, 0, 0) = 1.0f / MAT (in, 0, 0);
-  MAT (out, 1, 1) = 1.0f / MAT (in, 1, 1);
-
-  if (matrix->flags & MAT_FLAG_TRANSLATION)
-    {
-      MAT (out, 0, 3) = - (MAT (in, 0, 3) * MAT (out, 0, 0));
-      MAT (out, 1, 3) = - (MAT (in, 1, 3) * MAT (out, 1, 1));
-    }
-
-  return TRUE;
-}
-
-#if 0
-/* broken */
-static gboolean
-invert_matrix_perspective (CoglMatrix *matrix)
-{
-  const float *in = matrix;
-  float *out = matrix->inv;
-
-  if (MAT (in,2,3) == 0)
-    return FALSE;
-
-  memcpy( out, identity, 16 * sizeof(float) );
-
-  MAT (out, 0, 0) = 1.0f / MAT (in, 0, 0);
-  MAT (out, 1, 1) = 1.0f / MAT (in, 1, 1);
-
-  MAT (out, 0, 3) = MAT (in, 0, 2);
-  MAT (out, 1, 3) = MAT (in, 1, 2);
-
-  MAT (out,2,2) = 0;
-  MAT (out,2,3) = -1;
-
-  MAT (out,3,2) = 1.0f / MAT (in,2,3);
-  MAT (out,3,3) = MAT (in,2,2) * MAT (out,3,2);
-
-  return TRUE;
-}
-#endif
-
-/*
- * Matrix inversion function pointer type.
- */
-typedef gboolean (*inv_mat_func)(CoglMatrix *matrix);
-
-/*
- * Table of the matrix inversion functions according to the matrix type.
- */
-static inv_mat_func inv_mat_tab[7] = {
-    invert_matrix_general,
-    invert_matrix_identity,
-    invert_matrix_3d_no_rotation,
-#if 0
-    /* Don't use this function for now - it fails when the projection matrix
-     * is premultiplied by a translation (ala Chromium's tilesort SPU).
-     */
-    invert_matrix_perspective,
-#else
-    invert_matrix_general,
-#endif
-    invert_matrix_3d,		/* lazy! */
-    invert_matrix_2d_no_rotation,
-    invert_matrix_3d
-};
-
-#define ZERO(x) (1<<x)
-#define ONE(x)  (1<<(x+16))
-
-#define MASK_NO_TRX      (ZERO(12) | ZERO(13) | ZERO(14))
-#define MASK_NO_2D_SCALE ( ONE(0)  | ONE(5))
-
-#define MASK_IDENTITY    ( ONE(0)  | ZERO(4)  | ZERO(8)  | ZERO(12) |\
-                          ZERO(1)  |  ONE(5)  | ZERO(9)  | ZERO(13) |\
-                          ZERO(2)  | ZERO(6)  |  ONE(10) | ZERO(14) |\
-                          ZERO(3)  | ZERO(7)  | ZERO(11) |  ONE(15) )
-
-#define MASK_2D_NO_ROT   (           ZERO(4)  | ZERO(8)  |           \
-                          ZERO(1)  |            ZERO(9)  |           \
-                          ZERO(2)  | ZERO(6)  |  ONE(10) | ZERO(14) |\
-                          ZERO(3)  | ZERO(7)  | ZERO(11) |  ONE(15) )
-
-#define MASK_2D          (                      ZERO(8)  |           \
-                          ZERO(9)  |           \
-                          ZERO(2)  | ZERO(6)  |  ONE(10) | ZERO(14) |\
-                          ZERO(3)  | ZERO(7)  | ZERO(11) |  ONE(15) )
-
-
-#define MASK_3D_NO_ROT   (           ZERO(4)  | ZERO(8)  |           \
-                          ZERO(1)  |            ZERO(9)  |           \
-                          ZERO(2)  | ZERO(6)  |                      \
-                          ZERO(3)  | ZERO(7)  | ZERO(11) |  ONE(15) )
-
-#define MASK_3D          (                                           \
-                          \
-                          \
-                          ZERO(3)  | ZERO(7)  | ZERO(11) |  ONE(15) )
-
-
-#define MASK_PERSPECTIVE (           ZERO(4)  |            ZERO(12) |\
-                          ZERO(1)  |                       ZERO(13) |\
-                          ZERO(2)  | ZERO(6)  |                      \
-                          ZERO(3)  | ZERO(7)  |            ZERO(15) )
-
-#define SQ(x) ((x)*(x))
-
-/*
- * Determine type and flags from scratch.
- *
- * This is expensive enough to only want to do it once.
- */
-static void
-analyse_from_scratch (CoglMatrix *matrix)
-{
-  const float *m = (float *)matrix;
-  unsigned int mask = 0;
-  unsigned int i;
-
-  for (i = 0 ; i < 16 ; i++)
-    {
-      if (m[i] == 0.0) mask |= (1<<i);
-    }
-
-  if (m[0] == 1.0f) mask |= (1<<16);
-  if (m[5] == 1.0f) mask |= (1<<21);
-  if (m[10] == 1.0f) mask |= (1<<26);
-  if (m[15] == 1.0f) mask |= (1<<31);
-
-  matrix->flags &= ~MAT_FLAGS_GEOMETRY;
-
-  /* Check for translation - no-one really cares
-  */
-  if ((mask & MASK_NO_TRX) != MASK_NO_TRX)
-    matrix->flags |= MAT_FLAG_TRANSLATION;
-
-  /* Do the real work
-  */
-  if (mask == (unsigned int) MASK_IDENTITY)
-    matrix->type = COGL_MATRIX_TYPE_IDENTITY;
-  else if ((mask & MASK_2D_NO_ROT) == (unsigned int) MASK_2D_NO_ROT)
-    {
-      matrix->type = COGL_MATRIX_TYPE_2D_NO_ROT;
-
-      if ((mask & MASK_NO_2D_SCALE) != MASK_NO_2D_SCALE)
-        matrix->flags |= MAT_FLAG_GENERAL_SCALE;
-    }
-  else if ((mask & MASK_2D) == (unsigned int) MASK_2D)
-    {
-      float mm = DOT2 (m, m);
-      float m4m4 = DOT2 (m+4,m+4);
-      float mm4 = DOT2 (m,m+4);
-
-      matrix->type = COGL_MATRIX_TYPE_2D;
-
-      /* Check for scale */
-      if (SQ (mm-1) > SQ (1e-6) ||
-          SQ (m4m4-1) > SQ (1e-6))
-        matrix->flags |= MAT_FLAG_GENERAL_SCALE;
-
-      /* Check for rotation */
-      if (SQ (mm4) > SQ (1e-6))
-        matrix->flags |= MAT_FLAG_GENERAL_3D;
-      else
-        matrix->flags |= MAT_FLAG_ROTATION;
-
-    }
-  else if ((mask & MASK_3D_NO_ROT) == (unsigned int) MASK_3D_NO_ROT)
-    {
-      matrix->type = COGL_MATRIX_TYPE_3D_NO_ROT;
-
-      /* Check for scale */
-      if (SQ (m[0]-m[5]) < SQ (1e-6) &&
-          SQ (m[0]-m[10]) < SQ (1e-6))
-        {
-          if (SQ (m[0]-1.0) > SQ (1e-6))
-            matrix->flags |= MAT_FLAG_UNIFORM_SCALE;
-        }
-      else
-        matrix->flags |= MAT_FLAG_GENERAL_SCALE;
-    }
-  else if ((mask & MASK_3D) == (unsigned int) MASK_3D)
-    {
-      float c1 = DOT3 (m,m);
-      float c2 = DOT3 (m+4,m+4);
-      float c3 = DOT3 (m+8,m+8);
-      float d1 = DOT3 (m, m+4);
-      float cp[3];
-
-      matrix->type = COGL_MATRIX_TYPE_3D;
-
-      /* Check for scale */
-      if (SQ (c1-c2) < SQ (1e-6) && SQ (c1-c3) < SQ (1e-6))
-        {
-          if (SQ (c1-1.0) > SQ (1e-6))
-            matrix->flags |= MAT_FLAG_UNIFORM_SCALE;
-          /* else no scale at all */
-        }
-      else
-        matrix->flags |= MAT_FLAG_GENERAL_SCALE;
-
-      /* Check for rotation */
-      if (SQ (d1) < SQ (1e-6))
-        {
-          CROSS3 ( cp, m, m+4);
-          SUB_3V ( cp, cp, (m+8));
-          if (LEN_SQUARED_3FV(cp) < SQ(1e-6))
-            matrix->flags |= MAT_FLAG_ROTATION;
-          else
-            matrix->flags |= MAT_FLAG_GENERAL_3D;
-        }
-      else
-        matrix->flags |= MAT_FLAG_GENERAL_3D; /* shear, etc */
-    }
-  else if ((mask & MASK_PERSPECTIVE) == MASK_PERSPECTIVE && m[11]==-1.0f)
-    {
-      matrix->type = COGL_MATRIX_TYPE_PERSPECTIVE;
-      matrix->flags |= MAT_FLAG_GENERAL;
-    }
-  else
-    {
-      matrix->type = COGL_MATRIX_TYPE_GENERAL;
-      matrix->flags |= MAT_FLAG_GENERAL;
-    }
-}
-
-/*
- * Analyze a matrix given that its flags are accurate.
- *
- * This is the more common operation, hopefully.
- */
-static void
-analyse_from_flags (CoglMatrix *matrix)
-{
-  const float *m = (float *)matrix;
-
-  if (TEST_MAT_FLAGS(matrix, 0))
-    matrix->type = COGL_MATRIX_TYPE_IDENTITY;
-  else if (TEST_MAT_FLAGS(matrix, (MAT_FLAG_TRANSLATION |
-                                   MAT_FLAG_UNIFORM_SCALE |
-                                   MAT_FLAG_GENERAL_SCALE)))
-    {
-      if ( m[10] == 1.0f && m[14] == 0.0f )
-        matrix->type = COGL_MATRIX_TYPE_2D_NO_ROT;
-      else
-        matrix->type = COGL_MATRIX_TYPE_3D_NO_ROT;
-    }
-  else if (TEST_MAT_FLAGS (matrix, MAT_FLAGS_3D))
-    {
-      if (                               m[ 8]==0.0f
-          &&                             m[ 9]==0.0f
-          && m[2]==0.0f && m[6]==0.0f && m[10]==1.0f && m[14]==0.0f)
-        {
-          matrix->type = COGL_MATRIX_TYPE_2D;
-        }
-      else
-        matrix->type = COGL_MATRIX_TYPE_3D;
-    }
-  else if (                 m[4]==0.0f                 && m[12]==0.0f
-           && m[1]==0.0f                               && m[13]==0.0f
-           && m[2]==0.0f && m[6]==0.0f
-           && m[3]==0.0f && m[7]==0.0f && m[11]==-1.0f && m[15]==0.0f)
-    {
-      matrix->type = COGL_MATRIX_TYPE_PERSPECTIVE;
-    }
-  else
-    matrix->type = COGL_MATRIX_TYPE_GENERAL;
-}
-
-/*
- * Analyze and update the type and flags of a matrix.
- *
- * If the matrix type is dirty then calls either analyse_from_scratch() or
- * analyse_from_flags() to determine its type, according to whether the flags
- * are dirty or not, respectively. If the matrix has an inverse and it's dirty
- * then calls matrix_invert(). Finally clears the dirty flags.
- */
-static void
-_cogl_matrix_update_type_and_flags (CoglMatrix *matrix)
-{
-  if (matrix->flags & MAT_DIRTY_TYPE)
-    {
-      if (matrix->flags & MAT_DIRTY_FLAGS)
-        analyse_from_scratch (matrix);
-      else
-        analyse_from_flags (matrix);
-    }
-
-  matrix->flags &= ~(MAT_DIRTY_FLAGS | MAT_DIRTY_TYPE);
-}
-
-/*
- * Compute inverse of a transformation matrix.
- *
- * @mat pointer to a CoglMatrix structure. The matrix inverse will be
- * stored in the CoglMatrix::inv attribute.
- *
- * Returns: %TRUE for success, %FALSE for failure (\p singular matrix).
- *
- * Calls the matrix inversion function in inv_mat_tab corresponding to the
- * given matrix type.  In case of failure, updates the MAT_FLAG_SINGULAR flag,
- * and copies the identity matrix into CoglMatrix::inv.
- */
-static gboolean
-_cogl_matrix_update_inverse (CoglMatrix *matrix)
-{
-  if (matrix->flags & MAT_DIRTY_FLAGS ||
-      matrix->flags & MAT_DIRTY_INVERSE)
-    {
-      _cogl_matrix_update_type_and_flags (matrix);
-
-      if (inv_mat_tab[matrix->type](matrix))
-        matrix->flags &= ~MAT_FLAG_SINGULAR;
-      else
-        {
-          matrix->flags |= MAT_FLAG_SINGULAR;
-          memcpy (matrix->inv, identity, 16 * sizeof (float));
-        }
-
-      matrix->flags &= ~MAT_DIRTY_INVERSE;
-    }
-
-  if (matrix->flags & MAT_FLAG_SINGULAR)
-    return FALSE;
-  else
-    return TRUE;
-}
-
-gboolean
-cogl_matrix_get_inverse (const CoglMatrix *matrix, CoglMatrix *inverse)
-{
-  if (_cogl_matrix_update_inverse ((CoglMatrix *)matrix))
-    {
-      cogl_matrix_init_from_array (inverse, matrix->inv);
-      return TRUE;
-    }
-  else
-    {
-      cogl_matrix_init_identity (inverse);
-      return FALSE;
-    }
-}
-
-/*
- * Generate a 4x4 transformation matrix from glRotate parameters, and
- * post-multiply the input matrix by it.
- *
- * \author
- * This function was contributed by Erich Boleyn (erich@uruk.org).
- * Optimizations contributed by Rudolf Opalla (rudi@khm.de).
- */
-static void
-_cogl_matrix_rotate (CoglMatrix *matrix,
-                     float angle,
-                     float x,
-                     float y,
-                     float z)
-{
-  float xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c, s, c;
-  float m[16];
-  gboolean optimized;
-
-  s = sinf (angle * DEG2RAD);
-  c = cosf (angle * DEG2RAD);
-
-  memcpy (m, identity, 16 * sizeof (float));
-  optimized = FALSE;
-
-#define M(row,col)  m[col*4+row]
-
-  if (x == 0.0f)
-    {
-      if (y == 0.0f)
-        {
-          if (z != 0.0f)
-            {
-              optimized = TRUE;
-              /* rotate only around z-axis */
-              M (0,0) = c;
-              M (1,1) = c;
-              if (z < 0.0f)
-                {
-                  M (0,1) = s;
-                  M (1,0) = -s;
-                }
-              else
-                {
-                  M (0,1) = -s;
-                  M (1,0) = s;
-                }
-            }
-        }
-      else if (z == 0.0f)
-        {
-          optimized = TRUE;
-          /* rotate only around y-axis */
-          M (0,0) = c;
-          M (2,2) = c;
-          if (y < 0.0f)
-            {
-              M (0,2) = -s;
-              M (2,0) = s;
-            }
-          else
-            {
-              M (0,2) = s;
-              M (2,0) = -s;
-            }
-        }
-    }
-  else if (y == 0.0f)
-    {
-      if (z == 0.0f)
-        {
-          optimized = TRUE;
-          /* rotate only around x-axis */
-          M (1,1) = c;
-          M (2,2) = c;
-          if (x < 0.0f)
-            {
-              M (1,2) = s;
-              M (2,1) = -s;
-            }
-          else
-            {
-              M (1,2) = -s;
-              M (2,1) = s;
-            }
-        }
-    }
-
-  if (!optimized)
-    {
-      const float mag = sqrtf (x * x + y * y + z * z);
-
-      if (mag <= 1.0e-4)
-        {
-          /* no rotation, leave mat as-is */
-          return;
-        }
-
-      x /= mag;
-      y /= mag;
-      z /= mag;
-
-
-      /*
-       *     Arbitrary axis rotation matrix.
-       *
-       *  This is composed of 5 matrices, Rz, Ry, T, Ry', Rz', multiplied
-       *  like so:  Rz * Ry * T * Ry' * Rz'.  T is the final rotation
-       *  (which is about the X-axis), and the two composite transforms
-       *  Ry' * Rz' and Rz * Ry are (respectively) the rotations necessary
-       *  from the arbitrary axis to the X-axis then back.  They are
-       *  all elementary rotations.
-       *
-       *  Rz' is a rotation about the Z-axis, to bring the axis vector
-       *  into the x-z plane.  Then Ry' is applied, rotating about the
-       *  Y-axis to bring the axis vector parallel with the X-axis.  The
-       *  rotation about the X-axis is then performed.  Ry and Rz are
-       *  simply the respective inverse transforms to bring the arbitrary
-       *  axis back to it's original orientation.  The first transforms
-       *  Rz' and Ry' are considered inverses, since the data from the
-       *  arbitrary axis gives you info on how to get to it, not how
-       *  to get away from it, and an inverse must be applied.
-       *
-       *  The basic calculation used is to recognize that the arbitrary
-       *  axis vector (x, y, z), since it is of unit length, actually
-       *  represents the sines and cosines of the angles to rotate the
-       *  X-axis to the same orientation, with theta being the angle about
-       *  Z and phi the angle about Y (in the order described above)
-       *  as follows:
-       *
-       *  cos ( theta ) = x / sqrt ( 1 - z^2 )
-       *  sin ( theta ) = y / sqrt ( 1 - z^2 )
-       *
-       *  cos ( phi ) = sqrt ( 1 - z^2 )
-       *  sin ( phi ) = z
-       *
-       *  Note that cos ( phi ) can further be inserted to the above
-       *  formulas:
-       *
-       *  cos ( theta ) = x / cos ( phi )
-       *  sin ( theta ) = y / sin ( phi )
-       *
-       *  ...etc.  Because of those relations and the standard trigonometric
-       *  relations, it is pssible to reduce the transforms down to what
-       *  is used below.  It may be that any primary axis chosen will give the
-       *  same results (modulo a sign convention) using this method.
-       *
-       *  Particularly nice is to notice that all divisions that might
-       *  have caused trouble when parallel to certain planes or
-       *  axis go away with care paid to reducing the expressions.
-       *  After checking, it does perform correctly under all cases, since
-       *  in all the cases of division where the denominator would have
-       *  been zero, the numerator would have been zero as well, giving
-       *  the expected result.
-       */
-
-      xx = x * x;
-      yy = y * y;
-      zz = z * z;
-      xy = x * y;
-      yz = y * z;
-      zx = z * x;
-      xs = x * s;
-      ys = y * s;
-      zs = z * s;
-      one_c = 1.0f - c;
-
-      /* We already hold the identity-matrix so we can skip some statements */
-      M (0,0) = (one_c * xx) + c;
-      M (0,1) = (one_c * xy) - zs;
-      M (0,2) = (one_c * zx) + ys;
-      /*    M (0,3) = 0.0f; */
-
-      M (1,0) = (one_c * xy) + zs;
-      M (1,1) = (one_c * yy) + c;
-      M (1,2) = (one_c * yz) - xs;
-      /*    M (1,3) = 0.0f; */
-
-      M (2,0) = (one_c * zx) - ys;
-      M (2,1) = (one_c * yz) + xs;
-      M (2,2) = (one_c * zz) + c;
-      /*    M (2,3) = 0.0f; */
-
-      /*
-         M (3,0) = 0.0f;
-         M (3,1) = 0.0f;
-         M (3,2) = 0.0f;
-         M (3,3) = 1.0f;
-         */
-    }
-#undef M
-
-  matrix_multiply_array_with_flags (matrix, m, MAT_FLAG_ROTATION);
-}
-
-void
-cogl_matrix_rotate (CoglMatrix *matrix,
-		    float angle,
-		    float x,
-		    float y,
-		    float z)
-{
-  _cogl_matrix_rotate (matrix, angle, x, y, z);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-void
-cogl_matrix_rotate_euler (CoglMatrix *matrix,
-                          const graphene_euler_t *euler)
-{
-  CoglMatrix rotation_transform;
-
-  cogl_matrix_init_from_euler (&rotation_transform, euler);
-  cogl_matrix_multiply (matrix, matrix, &rotation_transform);
-}
-
-/*
- * Apply a perspective projection matrix.
- *
- * Creates the projection matrix and multiplies it with matrix, marking the
- * MAT_FLAG_PERSPECTIVE flag.
- */
-static void
-_cogl_matrix_frustum (CoglMatrix *matrix,
-                      float left,
-                      float right,
-                      float bottom,
-                      float top,
-                      float nearval,
-                      float farval)
-{
-  float x, y, a, b, c, d;
-  float m[16];
-
-  x = (2.0f * nearval) / (right - left);
-  y = (2.0f * nearval) / (top - bottom);
-  a = (right + left) / (right - left);
-  b = (top + bottom) / (top - bottom);
-  c = -(farval + nearval) / ( farval - nearval);
-  d = -(2.0f * farval * nearval) / (farval - nearval);  /* error? */
-
-#define M(row,col)  m[col*4+row]
-  M (0,0) = x;     M (0,1) = 0.0f;  M (0,2) = a;      M (0,3) = 0.0f;
-  M (1,0) = 0.0f;  M (1,1) = y;     M (1,2) = b;      M (1,3) = 0.0f;
-  M (2,0) = 0.0f;  M (2,1) = 0.0f;  M (2,2) = c;      M (2,3) = d;
-  M (3,0) = 0.0f;  M (3,1) = 0.0f;  M (3,2) = -1.0f;  M (3,3) = 0.0f;
-#undef M
-
-  matrix_multiply_array_with_flags (matrix, m, MAT_FLAG_PERSPECTIVE);
-}
-
-void
-cogl_matrix_frustum (CoglMatrix *matrix,
-                     float       left,
-                     float       right,
-                     float       bottom,
-                     float       top,
-                     float       z_near,
-                     float       z_far)
-{
-  _cogl_matrix_frustum (matrix, left, right, bottom, top, z_near, z_far);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-void
-cogl_matrix_perspective (CoglMatrix *matrix,
-                         float       fov_y,
-                         float       aspect,
-                         float       z_near,
-                         float       z_far)
-{
-  float ymax = z_near * tan (fov_y * G_PI / 360.0);
-
-  cogl_matrix_frustum (matrix,
-                       -ymax * aspect,  /* left */
-                       ymax * aspect,   /* right */
-                       -ymax,           /* bottom */
-                       ymax,            /* top */
-                       z_near,
-                       z_far);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-/*
- * Apply an orthographic projection matrix.
- *
- * Creates the projection matrix and multiplies it with matrix, marking the
- * MAT_FLAG_GENERAL_SCALE and MAT_FLAG_TRANSLATION flags.
- */
-static void
-_cogl_matrix_orthographic (CoglMatrix *matrix,
-                           float x_1,
-                           float y_1,
-                           float x_2,
-                           float y_2,
-                           float nearval,
-                           float farval)
-{
-  float m[16];
-
-#define M(row, col)  m[col * 4 + row]
-  M (0,0) = 2.0f / (x_2 - x_1);
-  M (0,1) = 0.0f;
-  M (0,2) = 0.0f;
-  M (0,3) = -(x_2 + x_1) / (x_2 - x_1);
-
-  M (1,0) = 0.0f;
-  M (1,1) = 2.0f / (y_1 - y_2);
-  M (1,2) = 0.0f;
-  M (1,3) = -(y_1 + y_2) / (y_1 - y_2);
-
-  M (2,0) = 0.0f;
-  M (2,1) = 0.0f;
-  M (2,2) = -2.0f / (farval - nearval);
-  M (2,3) = -(farval + nearval) / (farval - nearval);
-
-  M (3,0) = 0.0f;
-  M (3,1) = 0.0f;
-  M (3,2) = 0.0f;
-  M (3,3) = 1.0f;
-#undef M
-
-  matrix_multiply_array_with_flags (matrix, m,
-                                    (MAT_FLAG_GENERAL_SCALE |
-                                     MAT_FLAG_TRANSLATION));
-}
-
-void
-cogl_matrix_orthographic (CoglMatrix *matrix,
-                          float x_1,
-                          float y_1,
-                          float x_2,
-                          float y_2,
-                          float near,
-                          float far)
-{
-  _cogl_matrix_orthographic (matrix, x_1, y_1, x_2, y_2, near, far);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-/*
- * Multiply a matrix with a general scaling matrix.
- *
- * Multiplies in-place the elements of matrix by the scale factors. Checks if
- * the scales factors are roughly the same, marking the MAT_FLAG_UNIFORM_SCALE
- * flag, or MAT_FLAG_GENERAL_SCALE. Marks the MAT_DIRTY_TYPE and
- * MAT_DIRTY_INVERSE dirty flags.
- */
-static void
-_cogl_matrix_scale (CoglMatrix *matrix, float x, float y, float z)
-{
-  float *m = (float *)matrix;
-  m[0] *= x;   m[4] *= y;   m[8]  *= z;
-  m[1] *= x;   m[5] *= y;   m[9]  *= z;
-  m[2] *= x;   m[6] *= y;   m[10] *= z;
-  m[3] *= x;   m[7] *= y;   m[11] *= z;
-
-  if (fabsf (x - y) < 1e-8 && fabsf (x - z) < 1e-8)
-    matrix->flags |= MAT_FLAG_UNIFORM_SCALE;
-  else
-    matrix->flags |= MAT_FLAG_GENERAL_SCALE;
-
-  matrix->flags |= (MAT_DIRTY_TYPE | MAT_DIRTY_INVERSE);
-}
-
-void
-cogl_matrix_scale (CoglMatrix *matrix,
-		   float sx,
-		   float sy,
-		   float sz)
-{
-  _cogl_matrix_scale (matrix, sx, sy, sz);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-/*
- * Multiply a matrix with a translation matrix.
- *
- * Adds the translation coordinates to the elements of matrix in-place.  Marks
- * the MAT_FLAG_TRANSLATION flag, and the MAT_DIRTY_TYPE and MAT_DIRTY_INVERSE
- * dirty flags.
- */
-static void
-_cogl_matrix_translate (CoglMatrix *matrix, float x, float y, float z)
-{
-  float *m = (float *)matrix;
-  m[12] = m[0] * x + m[4] * y + m[8]  * z + m[12];
-  m[13] = m[1] * x + m[5] * y + m[9]  * z + m[13];
-  m[14] = m[2] * x + m[6] * y + m[10] * z + m[14];
-  m[15] = m[3] * x + m[7] * y + m[11] * z + m[15];
-
-  matrix->flags |= (MAT_FLAG_TRANSLATION |
-                    MAT_DIRTY_TYPE |
-                    MAT_DIRTY_INVERSE);
-}
-
-void
-cogl_matrix_translate (CoglMatrix *matrix,
-		       float x,
-		       float y,
-		       float z)
-{
-  _cogl_matrix_translate (matrix, x, y, z);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-#if 0
-/*
- * Set matrix to do viewport and depthrange mapping.
- * Transforms Normalized Device Coords to window/Z values.
- */
-static void
-_cogl_matrix_viewport (CoglMatrix *matrix,
-                       float x, float y,
-                       float width, float height,
-                       float zNear, float zFar, float depthMax)
-{
-  float *m = (float *)matrix;
-  m[MAT_SX] = width / 2.0f;
-  m[MAT_TX] = m[MAT_SX] + x;
-  m[MAT_SY] = height / 2.0f;
-  m[MAT_TY] = m[MAT_SY] + y;
-  m[MAT_SZ] = depthMax * ((zFar - zNear) / 2.0f);
-  m[MAT_TZ] = depthMax * ((zFar - zNear) / 2.0f + zNear);
-  matrix->flags = MAT_FLAG_GENERAL_SCALE | MAT_FLAG_TRANSLATION;
-  matrix->type = COGL_MATRIX_TYPE_3D_NO_ROT;
-}
-#endif
-
-/*
- * Set a matrix to the identity matrix.
- *
- * @mat matrix.
- *
- * Copies ::identity into \p CoglMatrix::m, and into CoglMatrix::inv if
- * not NULL. Sets the matrix type to identity, resets the flags. It
- * doesn't initialize the inverse matrix, it just marks it dirty.
- */
-static void
-_cogl_matrix_init_identity (CoglMatrix *matrix)
-{
-  memcpy (matrix, identity, 16 * sizeof (float));
-
-  matrix->type = COGL_MATRIX_TYPE_IDENTITY;
-  matrix->flags = MAT_DIRTY_INVERSE;
-}
-
-void
-cogl_matrix_init_identity (CoglMatrix *matrix)
-{
-  _cogl_matrix_init_identity (matrix);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-/*
- * Set a matrix to the (tx, ty, tz) translation matrix.
- *
- * @matrix matrix.
- * @tx x coordinate of the translation vector
- * @ty y coordinate of the translation vector
- * @tz z coordinate of the translation vector
- */
-static void
-_cogl_matrix_init_translation (CoglMatrix *matrix,
-                               float       tx,
-                               float       ty,
-                               float       tz)
-{
-  memcpy (matrix, identity, 16 * sizeof (float));
-
-  matrix->xw = tx;
-  matrix->yw = ty;
-  matrix->zw = tz;
-
-  matrix->type = COGL_MATRIX_TYPE_3D;
-  matrix->flags = MAT_FLAG_TRANSLATION | MAT_DIRTY_INVERSE;
-}
-
-void
-cogl_matrix_init_translation (CoglMatrix *matrix,
-                              float       tx,
-                              float       ty,
-                              float       tz)
-{
-  _cogl_matrix_init_translation (matrix, tx, ty, tz);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-#if 0
-/*
- * Test if the given matrix preserves vector lengths.
- */
-static gboolean
-_cogl_matrix_is_length_preserving (const CoglMatrix *m)
-{
-  return TEST_MAT_FLAGS (m, MAT_FLAGS_LENGTH_PRESERVING);
-}
-
-/*
- * Test if the given matrix does any rotation.
- * (or perhaps if the upper-left 3x3 is non-identity)
- */
-static gboolean
-_cogl_matrix_has_rotation (const CoglMatrix *matrix)
-{
-  if (matrix->flags & (MAT_FLAG_GENERAL |
-                       MAT_FLAG_ROTATION |
-                       MAT_FLAG_GENERAL_3D |
-                       MAT_FLAG_PERSPECTIVE))
-    return TRUE;
-  else
-    return FALSE;
-}
-
-static gboolean
-_cogl_matrix_is_general_scale (const CoglMatrix *matrix)
-{
-  return (matrix->flags & MAT_FLAG_GENERAL_SCALE) ? TRUE : FALSE;
-}
-
-static gboolean
-_cogl_matrix_is_dirty (const CoglMatrix *matrix)
-{
-  return (matrix->flags & MAT_DIRTY_ALL) ? TRUE : FALSE;
-}
-#endif
-
-/*
- * Loads a matrix array into CoglMatrix.
- *
- * @m matrix array.
- * @mat matrix.
- *
- * Copies \p m into CoglMatrix::m and marks the MAT_FLAG_GENERAL and
- * MAT_DIRTY_ALL
- * flags.
- */
-static void
-_cogl_matrix_init_from_array (CoglMatrix *matrix, const float *array)
-{
-  memcpy (matrix, array, 16 * sizeof (float));
-  matrix->flags = (MAT_FLAG_GENERAL | MAT_DIRTY_ALL);
-}
-
-void
-cogl_matrix_init_from_array (CoglMatrix *matrix, const float *array)
-{
-  _cogl_matrix_init_from_array (matrix, array);
-  _COGL_MATRIX_DEBUG_PRINT (matrix);
-}
-
-void
-_cogl_matrix_init_from_matrix_without_inverse (CoglMatrix *matrix,
-                                               const CoglMatrix *src)
-{
-  memcpy (matrix, src, 16 * sizeof (float));
-  matrix->type = src->type;
-  matrix->flags = src->flags | MAT_DIRTY_INVERSE;
-}
-
-void
-cogl_matrix_init_from_euler (CoglMatrix *matrix,
-                             const graphene_euler_t *euler)
-{
-  /* Convert angles to radians */
-  float heading_rad = graphene_euler_get_y (euler) / 180.0f * G_PI;
-  float pitch_rad = graphene_euler_get_x (euler) / 180.0f * G_PI;
-  float roll_rad = graphene_euler_get_z (euler) / 180.0f * G_PI;
-  /* Pre-calculate the sin and cos */
-  float sin_heading = sinf (heading_rad);
-  float cos_heading = cosf (heading_rad);
-  float sin_pitch = sinf (pitch_rad);
-  float cos_pitch = cosf (pitch_rad);
-  float sin_roll = sinf (roll_rad);
-  float cos_roll = cosf (roll_rad);
-
-  /* These calculations are based on the following website but they
-   * use a different order for the rotations so it has been modified
-   * slightly.
-   * http://www.euclideanspace.com/maths/geometry/
-   *        rotations/conversions/eulerToMatrix/index.htm
-   */
-
-  /* Heading rotation x=0, y=1, z=0 gives:
-   *
-   * [ ch   0   sh   0 ]
-   * [ 0    1   0    0 ]
-   * [ -sh  0   ch   0 ]
-   * [ 0    0   0    1 ]
-   *
-   * Pitch rotation x=1, y=0, z=0 gives:
-   * [ 1    0   0    0 ]
-   * [ 0    cp  -sp  0 ]
-   * [ 0    sp  cp   0 ]
-   * [ 0    0   0    1 ]
-   *
-   * Roll rotation x=0, y=0, z=1 gives:
-   * [ cr   -sr 0    0 ]
-   * [ sr   cr  0    0 ]
-   * [ 0    0   1    0 ]
-   * [ 0    0   0    1 ]
-   *
-   * Heading matrix * pitch matrix =
-   * [ ch   sh*sp    cp*sh   0  ]
-   * [ 0    cp       -sp     0  ]
-   * [ -sh  ch*sp    ch*cp   0  ]
-   * [ 0    0        0       1  ]
-   *
-   * That matrix * roll matrix =
-   * [ ch*cr + sh*sp*sr   sh*sp*cr - ch*sr       sh*cp       0 ]
-   * [     cp*sr                cp*cr             -sp        0 ]
-   * [ ch*sp*sr - sh*cr   sh*sr + ch*sp*cr       ch*cp       0 ]
-   * [       0                    0                0         1 ]
-   */
-
-  matrix->xx = cos_heading * cos_roll + sin_heading * sin_pitch * sin_roll;
-  matrix->yx = cos_pitch * sin_roll;
-  matrix->zx = cos_heading * sin_pitch * sin_roll - sin_heading * cos_roll;
-  matrix->wx = 0.0f;
-
-  matrix->xy = sin_heading * sin_pitch * cos_roll - cos_heading * sin_roll;
-  matrix->yy = cos_pitch * cos_roll;
-  matrix->zy = sin_heading * sin_roll + cos_heading * sin_pitch * cos_roll;
-  matrix->wy = 0.0f;
-
-  matrix->xz = sin_heading * cos_pitch;
-  matrix->yz = -sin_pitch;
-  matrix->zz = cos_heading * cos_pitch;
-  matrix->wz = 0;
-
-  matrix->xw = 0;
-  matrix->yw = 0;
-  matrix->zw = 0;
-  matrix->ww = 1;
-
-  matrix->flags = (MAT_FLAG_GENERAL | MAT_DIRTY_ALL);
-}
-
-/*
- * Transpose a float matrix.
- */
-static void
-_cogl_matrix_util_transposef (float to[16], const float from[16])
-{
-  to[0] = from[0];
-  to[1] = from[4];
-  to[2] = from[8];
-  to[3] = from[12];
-  to[4] = from[1];
-  to[5] = from[5];
-  to[6] = from[9];
-  to[7] = from[13];
-  to[8] = from[2];
-  to[9] = from[6];
-  to[10] = from[10];
-  to[11] = from[14];
-  to[12] = from[3];
-  to[13] = from[7];
-  to[14] = from[11];
-  to[15] = from[15];
-}
-
-void
-cogl_matrix_view_2d_in_frustum (CoglMatrix *matrix,
-                                float left,
-                                float right,
-                                float bottom,
-                                float top,
-                                float z_near,
-                                float z_2d,
-                                float width_2d,
-                                float height_2d)
-{
-  float left_2d_plane = left / z_near * z_2d;
-  float right_2d_plane = right / z_near * z_2d;
-  float bottom_2d_plane = bottom / z_near * z_2d;
-  float top_2d_plane = top / z_near * z_2d;
-
-  float width_2d_start = right_2d_plane - left_2d_plane;
-  float height_2d_start = top_2d_plane - bottom_2d_plane;
-
-  /* Factors to scale from framebuffer geometry to frustum
-   * cross-section geometry. */
-  float width_scale = width_2d_start / width_2d;
-  float height_scale = height_2d_start / height_2d;
-
-  cogl_matrix_translate (matrix,
-                         left_2d_plane, top_2d_plane, -z_2d);
-
-  cogl_matrix_scale (matrix, width_scale, -height_scale, width_scale);
-}
-
-/* Assuming a symmetric perspective matrix is being used for your
- * projective transform this convenience function lets you compose a
- * view transform such that geometry on the z=0 plane will map to
- * screen coordinates with a top left origin of (0,0) and with the
- * given width and height.
- */
-void
-cogl_matrix_view_2d_in_perspective (CoglMatrix *matrix,
-                                    float fov_y,
-                                    float aspect,
-                                    float z_near,
-                                    float z_2d,
-                                    float width_2d,
-                                    float height_2d)
-{
-  float top = z_near * tan (fov_y * G_PI / 360.0);
-  cogl_matrix_view_2d_in_frustum (matrix,
-                                  -top * aspect,
-                                  top * aspect,
-                                  -top,
-                                  top,
-                                  z_near,
-                                  z_2d,
-                                  width_2d,
-                                  height_2d);
-}
-
-gboolean
-cogl_matrix_equal (const void *v1, const void *v2)
-{
-  const CoglMatrix *a = v1;
-  const CoglMatrix *b = v2;
-
-  g_return_val_if_fail (v1 != NULL, FALSE);
-  g_return_val_if_fail (v2 != NULL, FALSE);
-
-  /* We want to avoid having a fuzzy _equal() function (e.g. that uses
-   * an arbitrary epsilon value) since this function notably conforms
-   * to the prototype suitable for use with g_hash_table_new() and a
-   * fuzzy hash function isn't really appropriate for comparing hash
-   * table keys since it's possible that you could end up fetching
-   * different values if you end up with multiple similar keys in use
-   * at the same time. If you consider that fuzzyness allows cases
-   * such as A == B == C but A != C then you could also end up losing
-   * values in a hash table.
-   *
-   * We do at least use the == operator to compare values though so
-   * that -0 is considered equal to 0.
-   */
-
-  /* XXX: We don't compare the flags, inverse matrix or padding */
-  if (a->xx == b->xx &&
-      a->xy == b->xy &&
-      a->xz == b->xz &&
-      a->xw == b->xw &&
-      a->yx == b->yx &&
-      a->yy == b->yy &&
-      a->yz == b->yz &&
-      a->yw == b->yw &&
-      a->zx == b->zx &&
-      a->zy == b->zy &&
-      a->zz == b->zz &&
-      a->zw == b->zw &&
-      a->wx == b->wx &&
-      a->wy == b->wy &&
-      a->wz == b->wz &&
-      a->ww == b->ww)
-    return TRUE;
-  else
-    return FALSE;
-}
-
-CoglMatrix *
-cogl_matrix_copy (const CoglMatrix *matrix)
-{
-  if (G_LIKELY (matrix))
-    return g_slice_dup (CoglMatrix, matrix);
-
-  return NULL;
-}
-
-void
-cogl_matrix_free (CoglMatrix *matrix)
-{
-  g_slice_free (CoglMatrix, matrix);
-}
-
-const float *
-cogl_matrix_get_array (const CoglMatrix *matrix)
-{
-  return (float *)matrix;
-}
-
-void
-cogl_matrix_transform_point (const CoglMatrix *matrix,
-                             float *x,
-                             float *y,
-                             float *z,
-                             float *w)
-{
-  float _x = *x, _y = *y, _z = *z, _w = *w;
-
-  *x = matrix->xx * _x + matrix->xy * _y + matrix->xz * _z + matrix->xw * _w;
-  *y = matrix->yx * _x + matrix->yy * _y + matrix->yz * _z + matrix->yw * _w;
-  *z = matrix->zx * _x + matrix->zy * _y + matrix->zz * _z + matrix->zw * _w;
-  *w = matrix->wx * _x + matrix->wy * _y + matrix->wz * _z + matrix->ww * _w;
-}
-
-typedef struct _Point2f
-{
-  float x;
-  float y;
-} Point2f;
-
-typedef struct _Point3f
-{
-  float x;
-  float y;
-  float z;
-} Point3f;
-
-typedef struct _Point4f
-{
-  float x;
-  float y;
-  float z;
-  float w;
-} Point4f;
-
-static void
-_cogl_matrix_transform_points_f2 (const CoglMatrix *matrix,
-                                  size_t stride_in,
-                                  const void *points_in,
-                                  size_t stride_out,
-                                  void *points_out,
-                                  int n_points)
-{
-  int i;
-
-  for (i = 0; i < n_points; i++)
-    {
-      Point2f p = *(Point2f *)((uint8_t *)points_in + i * stride_in);
-      Point3f *o = (Point3f *)((uint8_t *)points_out + i * stride_out);
-
-      o->x = matrix->xx * p.x + matrix->xy * p.y + matrix->xw;
-      o->y = matrix->yx * p.x + matrix->yy * p.y + matrix->yw;
-      o->z = matrix->zx * p.x + matrix->zy * p.y + matrix->zw;
-    }
-}
-
-static void
-_cogl_matrix_project_points_f2 (const CoglMatrix *matrix,
-                                size_t stride_in,
-                                const void *points_in,
-                                size_t stride_out,
-                                void *points_out,
-                                int n_points)
-{
-  int i;
-
-  for (i = 0; i < n_points; i++)
-    {
-      Point2f p = *(Point2f *)((uint8_t *)points_in + i * stride_in);
-      Point4f *o = (Point4f *)((uint8_t *)points_out + i * stride_out);
-
-      o->x = matrix->xx * p.x + matrix->xy * p.y + matrix->xw;
-      o->y = matrix->yx * p.x + matrix->yy * p.y + matrix->yw;
-      o->z = matrix->zx * p.x + matrix->zy * p.y + matrix->zw;
-      o->w = matrix->wx * p.x + matrix->wy * p.y + matrix->ww;
-    }
-}
-
-static void
-_cogl_matrix_transform_points_f3 (const CoglMatrix *matrix,
-                                  size_t stride_in,
-                                  const void *points_in,
-                                  size_t stride_out,
-                                  void *points_out,
-                                  int n_points)
-{
-  int i;
-
-  for (i = 0; i < n_points; i++)
-    {
-      Point3f p = *(Point3f *)((uint8_t *)points_in + i * stride_in);
-      Point3f *o = (Point3f *)((uint8_t *)points_out + i * stride_out);
-
-      o->x = matrix->xx * p.x + matrix->xy * p.y +
-             matrix->xz * p.z + matrix->xw;
-      o->y = matrix->yx * p.x + matrix->yy * p.y +
-             matrix->yz * p.z + matrix->yw;
-      o->z = matrix->zx * p.x + matrix->zy * p.y +
-             matrix->zz * p.z + matrix->zw;
-    }
-}
-
-static void
-_cogl_matrix_project_points_f3 (const CoglMatrix *matrix,
-                                size_t stride_in,
-                                const void *points_in,
-                                size_t stride_out,
-                                void *points_out,
-                                int n_points)
-{
-  int i;
-
-  for (i = 0; i < n_points; i++)
-    {
-      Point3f p = *(Point3f *)((uint8_t *)points_in + i * stride_in);
-      Point4f *o = (Point4f *)((uint8_t *)points_out + i * stride_out);
-
-      o->x = matrix->xx * p.x + matrix->xy * p.y +
-             matrix->xz * p.z + matrix->xw;
-      o->y = matrix->yx * p.x + matrix->yy * p.y +
-             matrix->yz * p.z + matrix->yw;
-      o->z = matrix->zx * p.x + matrix->zy * p.y +
-             matrix->zz * p.z + matrix->zw;
-      o->w = matrix->wx * p.x + matrix->wy * p.y +
-             matrix->wz * p.z + matrix->ww;
-    }
-}
-
-static void
-_cogl_matrix_project_points_f4 (const CoglMatrix *matrix,
-                                size_t stride_in,
-                                const void *points_in,
-                                size_t stride_out,
-                                void *points_out,
-                                int n_points)
-{
-  int i;
-
-  for (i = 0; i < n_points; i++)
-    {
-      Point4f p = *(Point4f *)((uint8_t *)points_in + i * stride_in);
-      Point4f *o = (Point4f *)((uint8_t *)points_out + i * stride_out);
-
-      o->x = matrix->xx * p.x + matrix->xy * p.y +
-             matrix->xz * p.z + matrix->xw * p.w;
-      o->y = matrix->yx * p.x + matrix->yy * p.y +
-             matrix->yz * p.z + matrix->yw * p.w;
-      o->z = matrix->zx * p.x + matrix->zy * p.y +
-             matrix->zz * p.z + matrix->zw * p.w;
-      o->w = matrix->wx * p.x + matrix->wy * p.y +
-             matrix->wz * p.z + matrix->ww * p.w;
-    }
-}
-
-void
-cogl_matrix_transform_points (const CoglMatrix *matrix,
-                              int n_components,
-                              size_t stride_in,
-                              const void *points_in,
-                              size_t stride_out,
-                              void *points_out,
-                              int n_points)
-{
-  /* The results of transforming always have three components... */
-  g_return_if_fail (stride_out >= sizeof (Point3f));
-
-  if (n_components == 2)
-    _cogl_matrix_transform_points_f2 (matrix,
-                                      stride_in, points_in,
-                                      stride_out, points_out,
-                                      n_points);
-  else
-    {
-      g_return_if_fail (n_components == 3);
-
-      _cogl_matrix_transform_points_f3 (matrix,
-                                        stride_in, points_in,
-                                        stride_out, points_out,
-                                        n_points);
-    }
-}
-
-void
-cogl_matrix_project_points (const CoglMatrix *matrix,
-                            int n_components,
-                            size_t stride_in,
-                            const void *points_in,
-                            size_t stride_out,
-                            void *points_out,
-                            int n_points)
-{
-  if (n_components == 2)
-    _cogl_matrix_project_points_f2 (matrix,
-                                    stride_in, points_in,
-                                    stride_out, points_out,
-                                    n_points);
-  else if (n_components == 3)
-    _cogl_matrix_project_points_f3 (matrix,
-                                    stride_in, points_in,
-                                    stride_out, points_out,
-                                    n_points);
-  else
-    {
-      g_return_if_fail (n_components == 4);
-
-      _cogl_matrix_project_points_f4 (matrix,
-                                      stride_in, points_in,
-                                      stride_out, points_out,
-                                      n_points);
-    }
-}
-
-gboolean
-cogl_matrix_is_identity (const CoglMatrix *matrix)
-{
-  if (!(matrix->flags & MAT_DIRTY_TYPE) &&
-      matrix->type == COGL_MATRIX_TYPE_IDENTITY)
-    return TRUE;
-  else
-    return memcmp (matrix, identity, sizeof (float) * 16) == 0;
-}
-
-void
-cogl_matrix_look_at (CoglMatrix *matrix,
-                     float eye_position_x,
-                     float eye_position_y,
-                     float eye_position_z,
-                     float object_x,
-                     float object_y,
-                     float object_z,
-                     float world_up_x,
-                     float world_up_y,
-                     float world_up_z)
-{
-  CoglMatrix tmp;
-  graphene_vec3_t forward;
-  graphene_vec3_t side;
-  graphene_vec3_t up;
-
-  /* Get a unit viewing direction vector */
-  graphene_vec3_init (&forward,
-                      object_x - eye_position_x,
-                      object_y - eye_position_y,
-                      object_z - eye_position_z);
-  graphene_vec3_normalize (&forward, &forward);
-
-  graphene_vec3_init (&up, world_up_x, world_up_y, world_up_z);
-
-  /* Take the sideways direction as being perpendicular to the viewing
-   * direction and the word up vector. */
-  graphene_vec3_cross (&forward, &up, &side);
-  graphene_vec3_normalize (&side, &side);
-
-  /* Now we have unit sideways and forward-direction vectors calculate
-   * a new mutually perpendicular up vector. */
-  graphene_vec3_cross (&side, &forward, &up);
-
-  tmp.xx = graphene_vec3_get_x (&side);
-  tmp.yx = graphene_vec3_get_y (&side);
-  tmp.zx = graphene_vec3_get_z (&side);
-  tmp.wx = 0;
-
-  tmp.xy = graphene_vec3_get_x (&up);
-  tmp.yy = graphene_vec3_get_y (&up);
-  tmp.zy = graphene_vec3_get_z (&up);
-  tmp.wy = 0;
-
-  tmp.xz = -graphene_vec3_get_x (&forward);
-  tmp.yz = -graphene_vec3_get_y (&forward);
-  tmp.zz = -graphene_vec3_get_z (&forward);
-  tmp.wz = 0;
-
-  tmp.xw = 0;
-  tmp.yw = 0;
-  tmp.zw = 0;
-  tmp.ww = 1;
-
-  tmp.flags = (MAT_FLAG_GENERAL_3D | MAT_DIRTY_TYPE | MAT_DIRTY_INVERSE);
-
-  cogl_matrix_translate (&tmp, -eye_position_x, -eye_position_y, -eye_position_z);
-
-  cogl_matrix_multiply (matrix, matrix, &tmp);
-}
-
-void
-cogl_matrix_transpose (CoglMatrix *matrix)
-{
-  float new_values[16];
-
-  /* We don't need to do anything if the matrix is the identity matrix */
-  if (!(matrix->flags & MAT_DIRTY_TYPE) &&
-      matrix->type == COGL_MATRIX_TYPE_IDENTITY)
-    return;
-
-  _cogl_matrix_util_transposef (new_values, cogl_matrix_get_array (matrix));
-
-  cogl_matrix_init_from_array (matrix, new_values);
-}
-
-GType
-cogl_gtype_matrix_get_type (void)
-{
-  return cogl_matrix_get_gtype ();
-}
diff --git a/cogl/cogl/cogl-matrix.h b/cogl/cogl/cogl-matrix.h
deleted file mode 100644
index 5e0a5498eaf09517c72f011ec60b4d649b950830..0000000000000000000000000000000000000000
--- a/cogl/cogl/cogl-matrix.h
+++ /dev/null
@@ -1,748 +0,0 @@
-/*
- * Cogl
- *
- * A Low Level GPU Graphics and Utilities API
- *
- * Copyright (C) 2008,2009 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- *
- *
- * Authors:
- *   Robert Bragg <robert@linux.intel.com>
- */
-
-#ifndef __COGL_MATRIX_H
-#define __COGL_MATRIX_H
-
-#include <cogl/cogl-defines.h>
-
-#include <glib-object.h>
-
-#include <cogl/cogl-types.h>
-#include <cogl/cogl-macros.h>
-
-#include <glib-object.h>
-
-#include <graphene.h>
-
-G_BEGIN_DECLS
-
-/**
- * SECTION:cogl-matrix
- * @short_description: Functions for initializing and manipulating 4x4 matrices
- *
- * Matrices are used in Cogl to describe affine model-view transforms, texture
- * transforms, and projective transforms. This exposes a utility API that can
- * be used for direct manipulation of these matrices.
- */
-
-/**
- * CoglMatrix:
- *
- * A CoglMatrix holds a 4x4 transform matrix. This is a single precision,
- * column-major matrix which means it is compatible with what OpenGL expects.
- *
- * A CoglMatrix can represent transforms such as, rotations, scaling,
- * translation, sheering, and linear projections. You can combine these
- * transforms by multiplying multiple matrices in the order you want them
- * applied.
- *
- * The transformation of a vertex (x, y, z, w) by a CoglMatrix is given by:
- *
- * |[
- *   x_new = xx * x + xy * y + xz * z + xw * w
- *   y_new = yx * x + yy * y + yz * z + yw * w
- *   z_new = zx * x + zy * y + zz * z + zw * w
- *   w_new = wx * x + wy * y + wz * z + ww * w
- * ]|
- *
- * Where w is normally 1
- *
- * <note>You must consider the members of the CoglMatrix structure read only,
- * and all matrix modifications must be done via the cogl_matrix API. This
- * allows Cogl to annotate the matrices internally. Violation of this will give
- * undefined results. If you need to initialize a matrix with a constant other
- * than the identity matrix you can use cogl_matrix_init_from_array().</note>
- */
-struct _CoglMatrix
-{
-  /* column 0 */
-  float xx;
-  float yx;
-  float zx;
-  float wx;
-
-  /* column 1 */
-  float xy;
-  float yy;
-  float zy;
-  float wy;
-
-  /* column 2 */
-  float xz;
-  float yz;
-  float zz;
-  float wz;
-
-  /* column 3 */
-  float xw;
-  float yw;
-  float zw;
-  float ww;
-
-  /*< private >*/
-
-  /* Note: we may want to extend this later with private flags
-   * and a cache of the inverse transform matrix. */
-  float          COGL_PRIVATE (inv)[16];
-  unsigned long  COGL_PRIVATE (type);
-  unsigned long  COGL_PRIVATE (flags);
-  unsigned long  COGL_PRIVATE (_padding3);
-};
-COGL_STRUCT_SIZE_ASSERT (CoglMatrix, 128 + sizeof (unsigned long) * 3);
-
-
-/**
- * cogl_matrix_init_identity:
- * @matrix: A 4x4 transformation matrix
- *
- * Resets matrix to the identity matrix:
- *
- * |[
- *   .xx=1; .xy=0; .xz=0; .xw=0;
- *   .yx=0; .yy=1; .yz=0; .yw=0;
- *   .zx=0; .zy=0; .zz=1; .zw=0;
- *   .wx=0; .wy=0; .wz=0; .ww=1;
- * ]|
- */
-COGL_EXPORT void
-cogl_matrix_init_identity (CoglMatrix *matrix);
-
-/**
- * cogl_matrix_init_translation:
- * @matrix: A 4x4 transformation matrix
- * @tx: x coordinate of the translation vector
- * @ty: y coordinate of the translation vector
- * @tz: z coordinate of the translation vector
- *
- * Resets matrix to the (tx, ty, tz) translation matrix:
- *
- * |[
- *   .xx=1; .xy=0; .xz=0; .xw=tx;
- *   .yx=0; .yy=1; .yz=0; .yw=ty;
- *   .zx=0; .zy=0; .zz=1; .zw=tz;
- *   .wx=0; .wy=0; .wz=0; .ww=1;
- * ]|
- *
- * Since: 2.0
- */
-COGL_EXPORT void
-cogl_matrix_init_translation (CoglMatrix *matrix,
-                              float       tx,
-                              float       ty,
-                              float       tz);
-
-/**
- * cogl_matrix_multiply:
- * @result: The address of a 4x4 matrix to store the result in
- * @a: A 4x4 transformation matrix
- * @b: A 4x4 transformation matrix
- *
- * Multiplies the two supplied matrices together and stores
- * the resulting matrix inside @result.
- *
- * <note>It is possible to multiply the @a matrix in-place, so
- * @result can be equal to @a but can't be equal to @b.</note>
- */
-COGL_EXPORT void
-cogl_matrix_multiply (CoglMatrix *result,
-		      const CoglMatrix *a,
-		      const CoglMatrix *b);
-
-/**
- * cogl_matrix_rotate:
- * @matrix: A 4x4 transformation matrix
- * @angle: The angle you want to rotate in degrees
- * @x: X component of your rotation vector
- * @y: Y component of your rotation vector
- * @z: Z component of your rotation vector
- *
- * Multiplies @matrix with a rotation matrix that applies a rotation
- * of @angle degrees around the specified 3D vector.
- */
-COGL_EXPORT void
-cogl_matrix_rotate (CoglMatrix *matrix,
-		    float angle,
-		    float x,
-		    float y,
-		    float z);
-
-/**
- * cogl_matrix_rotate_euler:
- * @matrix: A 4x4 transformation matrix
- * @euler: A euler describing a rotation
- *
- * Multiplies @matrix with a rotation transformation described by the
- * given #graphene_euler_t.
- *
- * Since: 2.0
- */
-COGL_EXPORT void
-cogl_matrix_rotate_euler (CoglMatrix *matrix,
-                          const graphene_euler_t *euler);
-
-/**
- * cogl_matrix_translate:
- * @matrix: A 4x4 transformation matrix
- * @x: The X translation you want to apply
- * @y: The Y translation you want to apply
- * @z: The Z translation you want to apply
- *
- * Multiplies @matrix with a transform matrix that translates along
- * the X, Y and Z axis.
- */
-COGL_EXPORT void
-cogl_matrix_translate (CoglMatrix *matrix,
-		       float x,
-		       float y,
-		       float z);
-
-/**
- * cogl_matrix_scale:
- * @matrix: A 4x4 transformation matrix
- * @sx: The X scale factor
- * @sy: The Y scale factor
- * @sz: The Z scale factor
- *
- * Multiplies @matrix with a transform matrix that scales along the X,
- * Y and Z axis.
- */
-COGL_EXPORT void
-cogl_matrix_scale (CoglMatrix *matrix,
-		   float sx,
-		   float sy,
-		   float sz);
-
-/**
- * cogl_matrix_look_at:
- * @matrix: A 4x4 transformation matrix
- * @eye_position_x: The X coordinate to look from
- * @eye_position_y: The Y coordinate to look from
- * @eye_position_z: The Z coordinate to look from
- * @object_x: The X coordinate of the object to look at
- * @object_y: The Y coordinate of the object to look at
- * @object_z: The Z coordinate of the object to look at
- * @world_up_x: The X component of the world's up direction vector
- * @world_up_y: The Y component of the world's up direction vector
- * @world_up_z: The Z component of the world's up direction vector
- *
- * Applies a view transform @matrix that positions the camera at
- * the coordinate (@eye_position_x, @eye_position_y, @eye_position_z)
- * looking towards an object at the coordinate (@object_x, @object_y,
- * @object_z). The top of the camera is aligned to the given world up
- * vector, which is normally simply (0, 1, 0) to map up to the
- * positive direction of the y axis.
- *
- * Because there is a lot of misleading documentation online for
- * gluLookAt regarding the up vector we want to try and be a bit
- * clearer here.
- *
- * The up vector should simply be relative to your world coordinates
- * and does not need to change as you move the eye and object
- * positions.  Many online sources may claim that the up vector needs
- * to be perpendicular to the vector between the eye and object
- * position (partly because the man page is somewhat misleading) but
- * that is not necessary for this function.
- *
- * <note>You should never look directly along the world-up
- * vector.</note>
- *
- * <note>It is assumed you are using a typical projection matrix where
- * your origin maps to the center of your viewport.</note>
- *
- * <note>Almost always when you use this function it should be the first
- * transform applied to a new modelview transform</note>
- *
- * Since: 1.8
- * Stability: unstable
- */
-COGL_EXPORT void
-cogl_matrix_look_at (CoglMatrix *matrix,
-                     float eye_position_x,
-                     float eye_position_y,
-                     float eye_position_z,
-                     float object_x,
-                     float object_y,
-                     float object_z,
-                     float world_up_x,
-                     float world_up_y,
-                     float world_up_z);
-
-/**
- * cogl_matrix_frustum:
- * @matrix: A 4x4 transformation matrix
- * @left: X position of the left clipping plane where it
- *   intersects the near clipping plane
- * @right: X position of the right clipping plane where it
- *   intersects the near clipping plane
- * @bottom: Y position of the bottom clipping plane where it
- *   intersects the near clipping plane
- * @top: Y position of the top clipping plane where it intersects
- *   the near clipping plane
- * @z_near: The distance to the near clipping plane (Must be positive)
- * @z_far: The distance to the far clipping plane (Must be positive)
- *
- * Multiplies @matrix by the given frustum perspective matrix.
- */
-COGL_EXPORT void
-cogl_matrix_frustum (CoglMatrix *matrix,
-                     float       left,
-                     float       right,
-                     float       bottom,
-                     float       top,
-                     float       z_near,
-                     float       z_far);
-
-/**
- * cogl_matrix_perspective:
- * @matrix: A 4x4 transformation matrix
- * @fov_y: Vertical field of view angle in degrees.
- * @aspect: The (width over height) aspect ratio for display
- * @z_near: The distance to the near clipping plane (Must be positive,
- *   and must not be 0)
- * @z_far: The distance to the far clipping plane (Must be positive)
- *
- * Multiplies @matrix by the described perspective matrix
- *
- * <note>You should be careful not to have to great a @z_far / @z_near
- * ratio since that will reduce the effectiveness of depth testing
- * since there won't be enough precision to identify the depth of
- * objects near to each other.</note>
- */
-COGL_EXPORT void
-cogl_matrix_perspective (CoglMatrix *matrix,
-                         float       fov_y,
-                         float       aspect,
-                         float       z_near,
-                         float       z_far);
-
-/**
- * cogl_matrix_orthographic:
- * @matrix: A 4x4 transformation matrix
- * @x_1: The x coordinate for the first vertical clipping plane
- * @y_1: The y coordinate for the first horizontal clipping plane
- * @x_2: The x coordinate for the second vertical clipping plane
- * @y_2: The y coordinate for the second horizontal clipping plane
- * @near: The <emphasis>distance</emphasis> to the near clipping
- *   plane (will be <emphasis>negative</emphasis> if the plane is
- *   behind the viewer)
- * @far: The <emphasis>distance</emphasis> to the far clipping
- *   plane (will be <emphasis>negative</emphasis> if the plane is
- *   behind the viewer)
- *
- * Multiplies @matrix by a parallel projection matrix.
- *
- * Since: 1.10
- * Stability: unstable
- */
-COGL_EXPORT void
-cogl_matrix_orthographic (CoglMatrix *matrix,
-                          float x_1,
-                          float y_1,
-                          float x_2,
-                          float y_2,
-                          float near,
-                          float far);
-
-/**
- * cogl_matrix_view_2d_in_frustum:
- * @matrix: A 4x4 transformation matrix
- * @left: coord of left vertical clipping plane
- * @right: coord of right vertical clipping plane
- * @bottom: coord of bottom horizontal clipping plane
- * @top: coord of top horizontal clipping plane
- * @z_near: The distance to the near clip plane. Never pass 0 and always pass
- *   a positive number.
- * @z_2d: The distance to the 2D plane. (Should always be positive and
- *   be between @z_near and the z_far value that was passed to
- *   cogl_matrix_frustum())
- * @width_2d: The width of the 2D coordinate system
- * @height_2d: The height of the 2D coordinate system
- *
- * Multiplies @matrix by a view transform that maps the 2D coordinates
- * (0,0) top left and (@width_2d,@height_2d) bottom right the full viewport
- * size. Geometry at a depth of 0 will now lie on this 2D plane.
- *
- * Note: this doesn't multiply the matrix by any projection matrix,
- * but it assumes you have a perspective projection as defined by
- * passing the corresponding arguments to cogl_matrix_frustum().
-
- * Toolkits such as Clutter that mix 2D and 3D drawing can use this to
- * create a 2D coordinate system within a 3D perspective projected
- * view frustum.
- *
- * Since: 1.8
- * Stability: unstable
- */
-COGL_EXPORT void
-cogl_matrix_view_2d_in_frustum (CoglMatrix *matrix,
-                                float left,
-                                float right,
-                                float bottom,
-                                float top,
-                                float z_near,
-                                float z_2d,
-                                float width_2d,
-                                float height_2d);
-
-/**
- * cogl_matrix_view_2d_in_perspective:
- * @fov_y: A field of view angle for the Y axis
- * @aspect: The ratio of width to height determining the field of view angle
- *   for the x axis.
- * @z_near: The distance to the near clip plane. Never pass 0 and always pass
- *   a positive number.
- * @z_2d: The distance to the 2D plane. (Should always be positive and
- *   be between @z_near and the z_far value that was passed to
- *   cogl_matrix_frustum())
- * @width_2d: The width of the 2D coordinate system
- * @height_2d: The height of the 2D coordinate system
- *
- * Multiplies @matrix by a view transform that maps the 2D coordinates
- * (0,0) top left and (@width_2d,@height_2d) bottom right the full viewport
- * size. Geometry at a depth of 0 will now lie on this 2D plane.
- *
- * Note: this doesn't multiply the matrix by any projection matrix,
- * but it assumes you have a perspective projection as defined by
- * passing the corresponding arguments to cogl_matrix_perspective().
- *
- * Toolkits such as Clutter that mix 2D and 3D drawing can use this to
- * create a 2D coordinate system within a 3D perspective projected
- * view frustum.
- *
- * Since: 1.8
- * Stability: unstable
- */
-COGL_EXPORT void
-cogl_matrix_view_2d_in_perspective (CoglMatrix *matrix,
-                                    float fov_y,
-                                    float aspect,
-                                    float z_near,
-                                    float z_2d,
-                                    float width_2d,
-                                    float height_2d);
-
-/**
- * cogl_matrix_init_from_array:
- * @matrix: A 4x4 transformation matrix
- * @array: A linear array of 16 floats (column-major order)
- *
- * Initializes @matrix with the contents of @array
- */
-COGL_EXPORT void
-cogl_matrix_init_from_array (CoglMatrix *matrix,
-                             const float *array);
-
-/**
- * cogl_matrix_get_array:
- * @matrix: A 4x4 transformation matrix
- *
- * Casts @matrix to a float array which can be directly passed to OpenGL.
- *
- * Return value: a pointer to the float array
- */
-COGL_EXPORT const float *
-cogl_matrix_get_array (const CoglMatrix *matrix);
-
-/**
- * cogl_matrix_init_from_euler:
- * @matrix: A 4x4 transformation matrix
- * @euler: A #graphene_euler_t
- *
- * Initializes @matrix from a #graphene_euler_t rotation.
- */
-COGL_EXPORT void
-cogl_matrix_init_from_euler (CoglMatrix *matrix,
-                             const graphene_euler_t *euler);
-
-/**
- * cogl_matrix_equal:
- * @v1: A 4x4 transformation matrix
- * @v2: A 4x4 transformation matrix
- *
- * Compares two matrices to see if they represent the same
- * transformation. Although internally the matrices may have different
- * annotations associated with them and may potentially have a cached
- * inverse matrix these are not considered in the comparison.
- *
- * Since: 1.4
- */
-COGL_EXPORT gboolean
-cogl_matrix_equal (const void *v1, const void *v2);
-
-/**
- * cogl_matrix_copy:
- * @matrix: A 4x4 transformation matrix you want to copy
- *
- * Allocates a new #CoglMatrix on the heap and initializes it with
- * the same values as @matrix.
- *
- * Return value: (transfer full): A newly allocated #CoglMatrix which
- * should be freed using cogl_matrix_free()
- *
- * Since: 1.6
- */
-COGL_EXPORT CoglMatrix *
-cogl_matrix_copy (const CoglMatrix *matrix);
-
-/**
- * cogl_matrix_free:
- * @matrix: A 4x4 transformation matrix you want to free
- *
- * Frees a #CoglMatrix that was previously allocated via a call to
- * cogl_matrix_copy().
- *
- * Since: 1.6
- */
-COGL_EXPORT void
-cogl_matrix_free (CoglMatrix *matrix);
-
-/**
- * cogl_matrix_get_inverse:
- * @matrix: A 4x4 transformation matrix
- * @inverse: (out): The destination for a 4x4 inverse transformation matrix
- *
- * Gets the inverse transform of a given matrix and uses it to initialize
- * a new #CoglMatrix.
- *
- * <note>Although the first parameter is annotated as const to indicate
- * that the transform it represents isn't modified this function may
- * technically save a copy of the inverse transform within the given
- * #CoglMatrix so that subsequent requests for the inverse transform may
- * avoid costly inversion calculations.</note>
- *
- * Return value: %TRUE if the inverse was successfully calculated or %FALSE
- *   for degenerate transformations that can't be inverted (in this case the
- *   @inverse matrix will simply be initialized with the identity matrix)
- *
- * Since: 1.2
- */
-COGL_EXPORT gboolean
-cogl_matrix_get_inverse (const CoglMatrix *matrix,
-                         CoglMatrix *inverse);
-
-/* FIXME: to be consistent with cogl_matrix_{transform,project}_points
- * this could be renamed to cogl_matrix_project_point for Cogl 2.0...
- */
-
-/**
- * cogl_matrix_transform_point:
- * @matrix: A 4x4 transformation matrix
- * @x: (inout): The X component of your points position
- * @y: (inout): The Y component of your points position
- * @z: (inout): The Z component of your points position
- * @w: (inout): The W component of your points position
- *
- * Transforms a point whose position is given and returned as four float
- * components.
- */
-COGL_EXPORT void
-cogl_matrix_transform_point (const CoglMatrix *matrix,
-                             float *x,
-                             float *y,
-                             float *z,
-                             float *w);
-
-/**
- * cogl_matrix_transform_points:
- * @matrix: A transformation matrix
- * @n_components: The number of position components for each input point.
- *                (either 2 or 3)
- * @stride_in: The stride in bytes between input points.
- * @points_in: A pointer to the first component of the first input point.
- * @stride_out: The stride in bytes between output points.
- * @points_out: A pointer to the first component of the first output point.
- * @n_points: The number of points to transform.
- *
- * Transforms an array of input points and writes the result to
- * another array of output points. The input points can either have 2
- * or 3 components each. The output points always have 3 components.
- * The output array can simply point to the input array to do the
- * transform in-place.
- *
- * If you need to transform 4 component points see
- * cogl_matrix_project_points().
- *
- * Here's an example with differing input/output strides:
- * |[
- * typedef struct {
- *   float x,y;
- *   uint8_t r,g,b,a;
- *   float s,t,p;
- * } MyInVertex;
- * typedef struct {
- *   uint8_t r,g,b,a;
- *   float x,y,z;
- * } MyOutVertex;
- * MyInVertex vertices[N_VERTICES];
- * MyOutVertex results[N_VERTICES];
- * CoglMatrix matrix;
- *
- * my_load_vertices (vertices);
- * my_get_matrix (&matrix);
- *
- * cogl_matrix_transform_points (&matrix,
- *                               2,
- *                               sizeof (MyInVertex),
- *                               &vertices[0].x,
- *                               sizeof (MyOutVertex),
- *                               &results[0].x,
- *                               N_VERTICES);
- * ]|
- *
- * Stability: unstable
- */
-COGL_EXPORT void
-cogl_matrix_transform_points (const CoglMatrix *matrix,
-                              int n_components,
-                              size_t stride_in,
-                              const void *points_in,
-                              size_t stride_out,
-                              void *points_out,
-                              int n_points);
-
-/**
- * cogl_matrix_project_points:
- * @matrix: A projection matrix
- * @n_components: The number of position components for each input point.
- *                (either 2, 3 or 4)
- * @stride_in: The stride in bytes between input points.
- * @points_in: A pointer to the first component of the first input point.
- * @stride_out: The stride in bytes between output points.
- * @points_out: A pointer to the first component of the first output point.
- * @n_points: The number of points to transform.
- *
- * Projects an array of input points and writes the result to another
- * array of output points. The input points can either have 2, 3 or 4
- * components each. The output points always have 4 components (known
- * as homogeneous coordinates). The output array can simply point to
- * the input array to do the transform in-place.
- *
- * Here's an example with differing input/output strides:
- * |[
- * typedef struct {
- *   float x,y;
- *   uint8_t r,g,b,a;
- *   float s,t,p;
- * } MyInVertex;
- * typedef struct {
- *   uint8_t r,g,b,a;
- *   float x,y,z;
- * } MyOutVertex;
- * MyInVertex vertices[N_VERTICES];
- * MyOutVertex results[N_VERTICES];
- * CoglMatrix matrix;
- *
- * my_load_vertices (vertices);
- * my_get_matrix (&matrix);
- *
- * cogl_matrix_project_points (&matrix,
- *                             2,
- *                             sizeof (MyInVertex),
- *                             &vertices[0].x,
- *                             sizeof (MyOutVertex),
- *                             &results[0].x,
- *                             N_VERTICES);
- * ]|
- *
- * Stability: unstable
- */
-COGL_EXPORT void
-cogl_matrix_project_points (const CoglMatrix *matrix,
-                            int n_components,
-                            size_t stride_in,
-                            const void *points_in,
-                            size_t stride_out,
-                            void *points_out,
-                            int n_points);
-
-/**
- * cogl_matrix_is_identity:
- * @matrix: A #CoglMatrix
- *
- * Determines if the given matrix is an identity matrix.
- *
- * Returns: %TRUE if @matrix is an identity matrix else %FALSE
- * Since: 1.8
- */
-COGL_EXPORT gboolean
-cogl_matrix_is_identity (const CoglMatrix *matrix);
-
-/**
- * cogl_matrix_transpose:
- * @matrix: A #CoglMatrix
- *
- * Replaces @matrix with its transpose. Ie, every element (i,j) in the
- * new matrix is taken from element (j,i) in the old matrix.
- *
- * Since: 1.10
- */
-COGL_EXPORT void
-cogl_matrix_transpose (CoglMatrix *matrix);
-
-/**
- * cogl_debug_matrix_print:
- * @matrix: A #CoglMatrix
- *
- * Prints the contents of a #CoglMatrix to stdout.
- *
- * Since: 2.0
- */
-COGL_EXPORT void
-cogl_debug_matrix_print (const CoglMatrix *matrix);
-
-#define COGL_GTYPE_TYPE_MATRIX (cogl_matrix_get_gtype ())
-
-/**
- * cogl_matrix_get_gtype:
- *
- * Returns: a #GType that can be used with the GLib type system.
- */
-COGL_EXPORT
-GType cogl_matrix_get_gtype (void);
-
-/**
- * cogl_gtype_matrix_get_type:
- *
- * Returns: the GType for the registered "CoglMatrix" boxed type. This
- * can be used for example to define GObject properties that accept a
- * #CoglMatrix value.
- *
- * Deprecated: 1.18: Use cogl_matrix_get_gtype() instead.
- */
-COGL_EXPORT GType
-cogl_gtype_matrix_get_type (void);
-
-G_END_DECLS
-
-#endif /* __COGL_MATRIX_H */
diff --git a/cogl/cogl/cogl-meta-texture.c b/cogl/cogl/cogl-meta-texture.c
index 026d86cd79c4c927f0fad5c3d03b7ccd501e6fd8..b8b91aa4a7407d64be28e4105bb6ef06e36e475c 100644
--- a/cogl/cogl/cogl-meta-texture.c
+++ b/cogl/cogl/cogl-meta-texture.c
@@ -33,7 +33,6 @@
 #include "cogl-config.h"
 
 #include "cogl-texture.h"
-#include "cogl-matrix.h"
 #include "cogl-spans.h"
 #include "cogl-meta-texture.h"
 #include "cogl-texture-private.h"
diff --git a/cogl/cogl/cogl-pipeline-layer-private.h b/cogl/cogl/cogl-pipeline-layer-private.h
index adde9bbf002bcde23932111ec173e84e0051674d..461a45519ccb22289be52022c5881bb49950e3f7 100644
--- a/cogl/cogl/cogl-pipeline-layer-private.h
+++ b/cogl/cogl/cogl-pipeline-layer-private.h
@@ -38,7 +38,6 @@
 #include "cogl-pipeline.h"
 #include "cogl-node-private.h"
 #include "cogl-texture.h"
-#include "cogl-matrix.h"
 #include "cogl-pipeline-layer-state.h"
 #include "cogl-pipeline-snippet-private.h"
 #include "cogl-sampler-cache-private.h"
@@ -180,7 +179,7 @@ typedef struct
   float texture_combine_constant[4];
 
   /* The texture matrix dscribes how to transform texture coordinates */
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
 
   CoglPipelineSnippetList vertex_snippets;
   CoglPipelineSnippetList fragment_snippets;
diff --git a/cogl/cogl/cogl-pipeline-layer-state.c b/cogl/cogl/cogl-pipeline-layer-state.c
index 73be1ea89fe7c8b9aecd8a9f39b0fd2570b7d281..b2503148da9bbf17088a99e50863612b944ba2eb 100644
--- a/cogl/cogl/cogl-pipeline-layer-state.c
+++ b/cogl/cogl/cogl-pipeline-layer-state.c
@@ -37,7 +37,6 @@
 #include "cogl-pipeline-private.h"
 #include "cogl-blend-string.h"
 #include "cogl-util.h"
-#include "cogl-matrix.h"
 #include "cogl-snippet-private.h"
 #include "cogl-texture-private.h"
 #include "cogl-pipeline-layer-state-private.h"
@@ -789,7 +788,7 @@ _cogl_pipeline_layer_user_matrix_equal (CoglPipelineLayer *authority0,
   CoglPipelineLayerBigState *big_state0 = authority0->big_state;
   CoglPipelineLayerBigState *big_state1 = authority1->big_state;
 
-  if (!cogl_matrix_equal (&big_state0->matrix, &big_state1->matrix))
+  if (!graphene_matrix_equal (&big_state0->matrix, &big_state1->matrix))
     return FALSE;
 
   return TRUE;
@@ -1124,7 +1123,7 @@ _cogl_pipeline_get_layer_combine_constant (CoglPipeline *pipeline,
 /* We should probably make a public API version of this that has a
    matrix out-param. For an internal API it's good to be able to avoid
    copying the matrix */
-const CoglMatrix *
+const graphene_matrix_t *
 _cogl_pipeline_get_layer_matrix (CoglPipeline *pipeline, int layer_index)
 {
   CoglPipelineLayerState       change =
@@ -1143,7 +1142,7 @@ _cogl_pipeline_get_layer_matrix (CoglPipeline *pipeline, int layer_index)
 void
 cogl_pipeline_set_layer_matrix (CoglPipeline *pipeline,
 				int layer_index,
-                                const CoglMatrix *matrix)
+                                const graphene_matrix_t *matrix)
 {
   CoglPipelineLayerState state = COGL_PIPELINE_LAYER_STATE_USER_MATRIX;
   CoglPipelineLayer     *layer;
@@ -1164,7 +1163,7 @@ cogl_pipeline_set_layer_matrix (CoglPipeline *pipeline,
    * state we want to change */
   authority = _cogl_pipeline_layer_get_authority (layer, state);
 
-  if (cogl_matrix_equal (matrix, &authority->big_state->matrix))
+  if (graphene_matrix_equal (matrix, &authority->big_state->matrix))
     return;
 
   new = _cogl_pipeline_layer_pre_change_notify (pipeline, layer, state);
@@ -1183,7 +1182,7 @@ cogl_pipeline_set_layer_matrix (CoglPipeline *pipeline,
           CoglPipelineLayer *old_authority =
             _cogl_pipeline_layer_get_authority (parent, state);
 
-          if (cogl_matrix_equal (matrix, &old_authority->big_state->matrix))
+          if (graphene_matrix_equal (matrix, &old_authority->big_state->matrix))
             {
               layer->differences &= ~state;
 
diff --git a/cogl/cogl/cogl-pipeline-layer-state.h b/cogl/cogl/cogl-pipeline-layer-state.h
index 947b37b145551259d24dda51c3bb29fefbf226c4..13bc465789816186f68052c1887cc8c0625670c1 100644
--- a/cogl/cogl/cogl-pipeline-layer-state.h
+++ b/cogl/cogl/cogl-pipeline-layer-state.h
@@ -37,7 +37,6 @@
 
 #include <cogl/cogl-pipeline.h>
 #include <cogl/cogl-color.h>
-#include <cogl/cogl-matrix.h>
 #include <cogl/cogl-texture.h>
 
 G_BEGIN_DECLS
@@ -336,7 +335,7 @@ cogl_pipeline_set_layer_combine_constant (CoglPipeline    *pipeline,
 COGL_EXPORT void
 cogl_pipeline_set_layer_matrix (CoglPipeline     *pipeline,
 				int               layer_index,
-				const CoglMatrix *matrix);
+				const graphene_matrix_t *matrix);
 
 /**
  * cogl_pipeline_get_n_layers:
diff --git a/cogl/cogl/cogl-pipeline-layer.c b/cogl/cogl/cogl-pipeline-layer.c
index 18d0140abea8337946763233330fd462f4f6fc4a..32133352a403aec6abfb317f0464f8daaa771a8a 100644
--- a/cogl/cogl/cogl-pipeline-layer.c
+++ b/cogl/cogl/cogl-pipeline-layer.c
@@ -768,7 +768,7 @@ _cogl_pipeline_init_default_layers (void)
 
   big_state->point_sprite_coords = FALSE;
 
-  cogl_matrix_init_identity (&big_state->matrix);
+  graphene_matrix_init_identity (&big_state->matrix);
 
   ctx->default_layer_0 = _cogl_pipeline_layer_object_new (layer);
 
diff --git a/cogl/cogl/cogl-pipeline-private.h b/cogl/cogl/cogl-pipeline-private.h
index 8369abca86a4f9cd856a95a6d431b8aea9368e6b..b62c9285669478c730d7322eb4da86d52ee62193 100644
--- a/cogl/cogl/cogl-pipeline-private.h
+++ b/cogl/cogl/cogl-pipeline-private.h
@@ -37,7 +37,6 @@
 #include "cogl-node-private.h"
 #include "cogl-pipeline-layer-private.h"
 #include "cogl-pipeline.h"
-#include "cogl-matrix.h"
 #include "cogl-object-private.h"
 #include "cogl-profile.h"
 #include "cogl-list.h"
@@ -732,7 +731,7 @@ _cogl_pipeline_journal_ref (CoglPipeline *pipeline);
 void
 _cogl_pipeline_journal_unref (CoglPipeline *pipeline);
 
-const CoglMatrix *
+const graphene_matrix_t *
 _cogl_pipeline_get_layer_matrix (CoglPipeline *pipeline,
                                  int layer_index);
 
diff --git a/cogl/cogl/cogl-pipeline-state.h b/cogl/cogl/cogl-pipeline-state.h
index ceec55fc9864c7ee2b3a83cfa25842b92928a769..4387685462d6683cf58cf3ffd9588dd9dfb1ae1f 100644
--- a/cogl/cogl/cogl-pipeline-state.h
+++ b/cogl/cogl/cogl-pipeline-state.h
@@ -715,8 +715,8 @@ cogl_pipeline_set_uniform_int (CoglPipeline *pipeline,
  *
  * If @transpose is %FALSE then the matrix is expected to be in
  * column-major order or if it is %TRUE then the matrix is in
- * row-major order. You can pass a #CoglMatrix by calling by passing
- * the result of cogl_matrix_get_array() in @value and setting
+ * row-major order. You can pass a #graphene_matrix_t by calling by passing
+ * the result of graphene_matrix_to_float() in @value and setting
  * @transpose to %FALSE.
  *
  * Since: 2.0
diff --git a/cogl/cogl/cogl-private.h b/cogl/cogl/cogl-private.h
index 769510289dd76a96f7ed40628dd48b2275a7dea3..2878a16403beb2642649b2c0bbe3b37f3d292e98 100644
--- a/cogl/cogl/cogl-private.h
+++ b/cogl/cogl/cogl-private.h
@@ -79,11 +79,11 @@ typedef enum _CoglPipelineEvalFlags
 } CoglPipelineEvalFlags;
 
 void
-_cogl_transform_point (const CoglMatrix *matrix_mv,
-                       const CoglMatrix *matrix_p,
-                       const float *viewport,
-                       float *x,
-                       float *y);
+_cogl_transform_point (const graphene_matrix_t *matrix_mv,
+                       const graphene_matrix_t *matrix_p,
+                       const float             *viewport,
+                       float                   *x,
+                       float                   *y);
 
 gboolean
 _cogl_check_extension (const char *name, char * const *ext);
diff --git a/cogl/cogl/cogl-types.h b/cogl/cogl/cogl-types.h
index 35871703d6cf5bed357baa7cd72204cec8d60d3d..d6856bd2e9657aeb176d450210ee84bff387b390 100644
--- a/cogl/cogl/cogl-types.h
+++ b/cogl/cogl/cogl-types.h
@@ -40,6 +40,7 @@
 
 #include <cogl/cogl-defines.h>
 #include <cogl/cogl-macros.h>
+#include <graphene.h>
 
 #include <glib.h>
 #include <glib-object.h>
@@ -85,10 +86,6 @@ typedef void * CoglHandle;
 COGL_EXPORT GType
 cogl_handle_get_type (void) G_GNUC_CONST;
 
-/* We forward declare this in cogl-types to avoid circular dependencies
- * between cogl-matrix.h and cogl-quaterion.h */
-typedef struct _CoglMatrix      CoglMatrix;
-
 /**
  * CoglAngle:
  *
diff --git a/cogl/cogl/cogl.c b/cogl/cogl/cogl.c
index 320c0186d6c787923d4849299a8c5768cc08eb0a..a9cd5ca215842e723724dbc4195e988f7a9c369c 100644
--- a/cogl/cogl/cogl.c
+++ b/cogl/cogl/cogl.c
@@ -36,11 +36,11 @@
 
 #include "cogl-i18n-private.h"
 #include "cogl-debug.h"
+#include "cogl-graphene.h"
 #include "cogl-util.h"
 #include "cogl-context-private.h"
 #include "cogl-pipeline-private.h"
 #include "cogl-framebuffer-private.h"
-#include "cogl-matrix-private.h"
 #include "cogl-journal-private.h"
 #include "cogl-bitmap-private.h"
 #include "cogl-texture-private.h"
@@ -174,20 +174,20 @@ _cogl_driver_error_quark (void)
 /* Transform a homogeneous vertex position from model space to Cogl
  * window coordinates (with 0,0 being top left) */
 void
-_cogl_transform_point (const CoglMatrix *matrix_mv,
-                       const CoglMatrix *matrix_p,
-                       const float *viewport,
-                       float *x,
-                       float *y)
+_cogl_transform_point (const graphene_matrix_t *matrix_mv,
+                       const graphene_matrix_t *matrix_p,
+                       const float             *viewport,
+                       float                   *x,
+                       float                   *y)
 {
   float z = 0;
   float w = 1;
 
   /* Apply the modelview matrix transform */
-  cogl_matrix_transform_point (matrix_mv, x, y, &z, &w);
+  cogl_graphene_matrix_project_point (matrix_mv, x, y, &z, &w);
 
   /* Apply the projection matrix transform */
-  cogl_matrix_transform_point (matrix_p, x, y, &z, &w);
+  cogl_graphene_matrix_project_point (matrix_p, x, y, &z, &w);
 
   /* Perform perspective division */
   *x /= w;
diff --git a/cogl/cogl/cogl.h b/cogl/cogl/cogl.h
index 07b496208847007745db8790e8059fa1c2c4b76e..4a63a368fdb2ee0e5fcac2a0209347aae3ccd151 100644
--- a/cogl/cogl/cogl.h
+++ b/cogl/cogl/cogl.h
@@ -62,7 +62,6 @@
 #include <cogl/cogl-bitmap.h>
 #include <cogl/cogl-color.h>
 #include <cogl/cogl-dma-buf-handle.h>
-#include <cogl/cogl-matrix.h>
 #include <cogl/cogl-matrix-stack.h>
 #include <cogl/cogl-offscreen.h>
 #include <cogl/cogl-pixel-format.h>
@@ -123,6 +122,7 @@
 #include <cogl/cogl-glib-source.h>
 #include <cogl/cogl-trace.h>
 #include <cogl/cogl-scanout.h>
+#include <cogl/cogl-graphene.h>
 /* XXX: This will definitely go away once all the Clutter winsys
  * code has been migrated down into Cogl! */
 #include <cogl/deprecated/cogl-clutter.h>
diff --git a/cogl/cogl/deprecated/cogl-framebuffer-deprecated.h b/cogl/cogl/deprecated/cogl-framebuffer-deprecated.h
deleted file mode 100644
index 200dcee03b6b224e4555639ae3c3dd4db984e8b5..0000000000000000000000000000000000000000
--- a/cogl/cogl/deprecated/cogl-framebuffer-deprecated.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * Cogl
- *
- * A Low Level GPU Graphics and Utilities API
- *
- * Copyright (C) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- *
- */
-
-#ifndef __COGL_FRAMEBUFFER_DEPRECATED_H__
-#define __COGL_FRAMEBUFFER_DEPRECATED_H__
-
-#include <cogl/cogl-framebuffer.h>
-#include <cogl/cogl-macros.h>
-
-G_BEGIN_DECLS
-
-/**
- * cogl_set_framebuffer: (skip)
- * @buffer: A #CoglFramebuffer object, either onscreen or offscreen.
- *
- * This redirects all subsequent drawing to the specified framebuffer. This can
- * either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
- * or in the future it may be an onscreen framebuffers too.
- *
- * Since: 1.2
- * Deprecated: 1.16: The latest drawing apis take explicit
- *                   #CoglFramebuffer arguments so this stack of
- *                   framebuffers shouldn't be used anymore.
- */
-COGL_DEPRECATED
-void
-cogl_set_framebuffer (CoglFramebuffer *buffer);
-
-/**
- * cogl_push_framebuffer: (skip)
- * @buffer: A #CoglFramebuffer object, either onscreen or offscreen.
- *
- * Redirects all subsequent drawing to the specified framebuffer. This can
- * either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
- * or in the future it may be an onscreen framebuffer too.
- *
- * You should understand that a framebuffer owns the following state:
- * <itemizedlist>
- *  <listitem><simpara>The projection matrix</simpara></listitem>
- *  <listitem><simpara>The modelview matrix stack</simpara></listitem>
- *  <listitem><simpara>The viewport</simpara></listitem>
- *  <listitem><simpara>The clip stack</simpara></listitem>
- * </itemizedlist>
- * So these items will automatically be saved and restored when you
- * push and pop between different framebuffers.
- *
- * Also remember a newly allocated framebuffer will have an identity matrix for
- * the projection and modelview matrices which gives you a coordinate space
- * like OpenGL with (-1, -1) corresponding to the top left of the viewport,
- * (1, 1) corresponding to the bottom right and +z coming out towards the
- * viewer.
- *
- * If you want to set up a coordinate space like Clutter does with (0, 0)
- * corresponding to the top left and (framebuffer_width, framebuffer_height)
- * corresponding to the bottom right you can do so like this:
- *
- * |[
- * static void
- * setup_viewport (unsigned int width,
- *                 unsigned int height,
- *                 float fovy,
- *                 float aspect,
- *                 float z_near,
- *                 float z_far)
- * {
- *   float z_camera;
- *   CoglMatrix projection_matrix;
- *   CoglMatrix mv_matrix;
- *
- *   cogl_set_viewport (0, 0, width, height);
- *   cogl_perspective (fovy, aspect, z_near, z_far);
- *
- *   cogl_get_projection_matrix (&amp;projection_matrix);
- *   z_camera = 0.5 * projection_matrix.xx;
- *
- *   cogl_matrix_init_identity (&amp;mv_matrix);
- *   cogl_matrix_translate (&amp;mv_matrix, -0.5f, -0.5f, -z_camera);
- *   cogl_matrix_scale (&amp;mv_matrix, 1.0f / width, -1.0f / height, 1.0f / width);
- *   cogl_matrix_translate (&amp;mv_matrix, 0.0f, -1.0 * height, 0.0f);
- *   cogl_set_modelview_matrix (&amp;mv_matrix);
- * }
- *
- * static void
- * my_init_framebuffer (ClutterStage *stage,
- *                      CoglFramebuffer *framebuffer,
- *                      unsigned int framebuffer_width,
- *                      unsigned int framebuffer_height)
- * {
- *   ClutterPerspective perspective;
- *
- *   clutter_stage_get_perspective (stage, &perspective);
- *
- *   cogl_push_framebuffer (framebuffer);
- *   setup_viewport (framebuffer_width,
- *                   framebuffer_height,
- *                   perspective.fovy,
- *                   perspective.aspect,
- *                   perspective.z_near,
- *                   perspective.z_far);
- * }
- * ]|
- *
- * The previous framebuffer can be restored by calling cogl_pop_framebuffer()
- *
- * Since: 1.2
- * Deprecated: 1.16: The latest drawing apis take explicit
- *                   #CoglFramebuffer arguments so this stack of
- *                   framebuffers shouldn't be used anymore.
- */
-COGL_DEPRECATED
-void
-cogl_push_framebuffer (CoglFramebuffer *buffer);
-
-/**
- * cogl_pop_framebuffer: (skip)
- *
- * Restores the framebuffer that was previously at the top of the stack.
- * All subsequent drawing will be redirected to this framebuffer.
- *
- * Since: 1.2
- * Deprecated: 1.16: The latest drawing apis take explicit
- *                   #CoglFramebuffer arguments so this stack of
- *                   framebuffers shouldn't be used anymore.
- */
-COGL_DEPRECATED
-void
-cogl_pop_framebuffer (void);
-
-G_END_DECLS
-
-#endif /* __COGL_FRAMEBUFFER_DEPRECATED_H__ */
diff --git a/cogl/cogl/deprecated/cogl-material-compat.c b/cogl/cogl/deprecated/cogl-material-compat.c
index 23c03ea0aafddc23090c0278101a293d5bf13d25..ac7923325b46c774c46bfd78a13f2aa7c05a28e2 100644
--- a/cogl/cogl/deprecated/cogl-material-compat.c
+++ b/cogl/cogl/deprecated/cogl-material-compat.c
@@ -34,7 +34,6 @@
 #include <cogl-pipeline.h>
 #include <cogl-pipeline-private.h>
 #include <cogl-types.h>
-#include <cogl-matrix.h>
 #include <cogl-context-private.h>
 #include <deprecated/cogl-material-compat.h>
 
@@ -129,9 +128,9 @@ cogl_material_set_layer_combine_constant (CoglMaterial    *material,
 }
 
 void
-cogl_material_set_layer_matrix (CoglMaterial     *material,
-				int               layer_index,
-				const CoglMatrix *matrix)
+cogl_material_set_layer_matrix (CoglMaterial            *material,
+                                int                      layer_index,
+                                const graphene_matrix_t *matrix)
 {
   cogl_pipeline_set_layer_matrix (COGL_PIPELINE (material),
                                   layer_index, matrix);
diff --git a/cogl/cogl/deprecated/cogl-material-compat.h b/cogl/cogl/deprecated/cogl-material-compat.h
index 37ab372af945808074b16dd906ea4ab2570c8db7..04842f546e9842b5f426c98d7f7f4c7245c94b97 100644
--- a/cogl/cogl/deprecated/cogl-material-compat.h
+++ b/cogl/cogl/deprecated/cogl-material-compat.h
@@ -36,7 +36,6 @@
 #define __COGL_MATERIAL_H__
 
 #include <cogl/cogl-types.h>
-#include <cogl/cogl-matrix.h>
 #include <cogl/cogl-depth-state.h>
 #include <cogl/cogl-macros.h>
 #include <cogl/cogl-object.h>
@@ -590,9 +589,9 @@ cogl_material_set_layer_combine_constant (CoglMaterial    *material,
  */
 COGL_DEPRECATED_FOR (cogl_pipeline_set_layer_matrix)
 COGL_EXPORT void
-cogl_material_set_layer_matrix (CoglMaterial     *material,
-				int               layer_index,
-				const CoglMatrix *matrix);
+cogl_material_set_layer_matrix (CoglMaterial            *material,
+                                int                      layer_index,
+                                const graphene_matrix_t *matrix);
 
 /**
  * cogl_material_set_layer_filters:
diff --git a/cogl/cogl/driver/gl/cogl-clip-stack-gl.c b/cogl/cogl/driver/gl/cogl-clip-stack-gl.c
index 24a714f6ceba7cbbcb9412797f1df187b0f353f8..c528365979f355b86e9078502fd6cf484a5e5f88 100644
--- a/cogl/cogl/driver/gl/cogl-clip-stack-gl.c
+++ b/cogl/cogl/driver/gl/cogl-clip-stack-gl.c
@@ -35,6 +35,7 @@
 #include "cogl-config.h"
 
 #include "cogl-context-private.h"
+#include "cogl-graphene.h"
 #include "cogl-primitives-private.h"
 #include "cogl-primitive-private.h"
 #include "driver/gl/cogl-util-gl-private.h"
@@ -132,10 +133,11 @@ add_stencil_clip_region (CoglFramebuffer *framebuffer,
 {
   CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglMatrixEntry *old_projection_entry, *old_modelview_entry;
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
   int num_rectangles = cairo_region_num_rectangles (region);
   int i;
   CoglVertexP2 *vertices;
+  graphene_point3d_t p;
 
   /* NB: This can be called while flushing the journal so we need
    * to be very conservative with what state we change.
@@ -150,17 +152,18 @@ add_stencil_clip_region (CoglFramebuffer *framebuffer,
    * make a matrix that translates those across the viewport, and into
    * the default [-1, -1, 1, 1] range.
    */
-  cogl_matrix_init_identity (&matrix);
-  cogl_matrix_translate (&matrix, -1, 1, 0);
-  cogl_matrix_scale (&matrix,
-                     2.0 / framebuffer->viewport_width,
-                     - 2.0 / framebuffer->viewport_height,
-                     1);
-  cogl_matrix_translate (&matrix,
+  graphene_point3d_init (&p,
                          - framebuffer->viewport_x,
                          - framebuffer->viewport_y,
                          0);
 
+  graphene_matrix_init_translate (&matrix, &p);
+  graphene_matrix_scale (&matrix,
+                         2.0 / framebuffer->viewport_width,
+                         - 2.0 / framebuffer->viewport_height,
+                         1);
+  graphene_matrix_translate (&matrix, &GRAPHENE_POINT3D_INIT (-1.f, 1.f, 0.f));
+
   GE( ctx, glColorMask (FALSE, FALSE, FALSE, FALSE) );
   GE( ctx, glDepthMask (FALSE) );
 
@@ -204,8 +207,8 @@ add_stencil_clip_region (CoglFramebuffer *framebuffer,
       z2 = 0.f;
       w2 = 1.f;
 
-      cogl_matrix_transform_point (&matrix, &x1, &y1, &z1, &w1);
-      cogl_matrix_transform_point (&matrix, &x2, &y2, &z2, &w2);
+      cogl_graphene_matrix_project_point (&matrix, &x1, &y1, &z1, &w1);
+      cogl_graphene_matrix_project_point (&matrix, &x2, &y2, &z2, &w2);
 
       v[0].x = x1;
       v[0].y = y1;
diff --git a/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c b/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c
index b9b6048fd93f936577ad169e3793e24f41098423..88c0adc7702cb6025e596a3942b235d43f24d705 100644
--- a/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c
+++ b/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c
@@ -431,11 +431,11 @@ update_constants_cb (CoglPipeline *pipeline,
   if (unit_state->texture_matrix_uniform != -1 &&
       (state->update_all || unit_state->dirty_texture_matrix))
     {
-      const CoglMatrix *matrix;
-      const float *array;
+      const graphene_matrix_t *matrix;
+      float array[16];
 
       matrix = _cogl_pipeline_get_layer_matrix (pipeline, layer_index);
-      array = cogl_matrix_get_array (matrix);
+      graphene_matrix_to_float (matrix, array);
       GE (ctx, glUniformMatrix4fv (unit_state->texture_matrix_uniform,
                                    1, FALSE, array));
       unit_state->dirty_texture_matrix = FALSE;
@@ -1001,7 +1001,7 @@ _cogl_pipeline_progend_glsl_pre_paint (CoglPipeline *pipeline,
   gboolean projection_changed;
   gboolean need_modelview;
   gboolean need_projection;
-  CoglMatrix modelview, projection;
+  graphene_matrix_t modelview, projection;
 
   _COGL_GET_CONTEXT (ctx, NO_RETVAL);
 
@@ -1033,6 +1033,8 @@ _cogl_pipeline_progend_glsl_pre_paint (CoglPipeline *pipeline,
 
   if (modelview_changed || projection_changed)
     {
+      float v[16];
+
       if (program_state->mvp_uniform != -1)
         need_modelview = need_projection = TRUE;
       else
@@ -1049,27 +1051,33 @@ _cogl_pipeline_progend_glsl_pre_paint (CoglPipeline *pipeline,
         {
           if (needs_flip && program_state->flip_uniform == -1)
             {
-              CoglMatrix tmp_matrix;
+              graphene_matrix_t tmp_matrix;
               cogl_matrix_entry_get (projection_entry, &tmp_matrix);
-              cogl_matrix_multiply (&projection,
-                                    &ctx->y_flip_matrix,
-                                    &tmp_matrix);
+              graphene_matrix_multiply (&tmp_matrix,
+                                        &ctx->y_flip_matrix,
+                                        &projection);
             }
           else
             cogl_matrix_entry_get (projection_entry, &projection);
         }
 
       if (projection_changed && program_state->projection_uniform != -1)
-        GE (ctx, glUniformMatrix4fv (program_state->projection_uniform,
-                                     1, /* count */
-                                     FALSE, /* transpose */
-                                     cogl_matrix_get_array (&projection)));
+        {
+          graphene_matrix_to_float (&projection, v);
+          GE (ctx, glUniformMatrix4fv (program_state->projection_uniform,
+                                       1, /* count */
+                                       FALSE, /* transpose */
+                                       v));
+        }
 
       if (modelview_changed && program_state->modelview_uniform != -1)
-        GE (ctx, glUniformMatrix4fv (program_state->modelview_uniform,
-                                     1, /* count */
-                                     FALSE, /* transpose */
-                                     cogl_matrix_get_array (&modelview)));
+        {
+          graphene_matrix_to_float (&modelview,v);
+          GE (ctx, glUniformMatrix4fv (program_state->modelview_uniform,
+                                       1, /* count */
+                                       FALSE, /* transpose */
+                                       v));
+        }
 
       if (program_state->mvp_uniform != -1)
         {
@@ -1078,24 +1086,25 @@ _cogl_pipeline_progend_glsl_pre_paint (CoglPipeline *pipeline,
              avoiding the matrix multiplication */
           if (cogl_matrix_entry_is_identity (modelview_entry))
             {
+              graphene_matrix_to_float (&projection, v);
               GE (ctx,
                   glUniformMatrix4fv (program_state->mvp_uniform,
                                       1, /* count */
                                       FALSE, /* transpose */
-                                      cogl_matrix_get_array (&projection)));
+                                      v));
             }
           else
             {
-              CoglMatrix combined;
+              graphene_matrix_t combined;
+
+              graphene_matrix_multiply (&modelview, &projection, &combined);
+              graphene_matrix_to_float (&combined, v);
 
-              cogl_matrix_multiply (&combined,
-                                    &projection,
-                                    &modelview);
               GE (ctx,
                   glUniformMatrix4fv (program_state->mvp_uniform,
                                       1, /* count */
                                       FALSE, /* transpose */
-                                      cogl_matrix_get_array (&combined)));
+                                      v));
             }
         }
     }
diff --git a/cogl/cogl/meson.build b/cogl/cogl/meson.build
index 2947b46c9e216fb875ac3456d84872faf0559160..a7346d81c55408704d61b6db6a5fad2f6405d67a 100644
--- a/cogl/cogl/meson.build
+++ b/cogl/cogl/meson.build
@@ -79,7 +79,6 @@ cogl_headers = [
   'cogl-context.h',
   'cogl-frame-info.h',
   'cogl-framebuffer.h',
-  'cogl-matrix.h',
   'cogl-object.h',
   'cogl-offscreen.h',
   'cogl-onscreen.h',
@@ -123,6 +122,7 @@ cogl_nonintrospected_headers = [
   'cogl-gtype-private.h',
   'cogl-glib-source.h',
   'cogl-scanout.h',
+  'cogl-graphene.h',
 ]
 
 cogl_nodist_headers = [
@@ -257,8 +257,6 @@ cogl_sources = [
   'cogl-attribute.c',
   'cogl-primitive-private.h',
   'cogl-primitive.c',
-  'cogl-matrix.c',
-  'cogl-matrix-private.h',
   'cogl-matrix-stack.c',
   'cogl-matrix-stack-private.h',
   'cogl-depth-state.c',
@@ -354,6 +352,7 @@ cogl_sources = [
   'deprecated/cogl-clutter.c',
   'cogl-glib-source.c',
   'cogl-mutter.h',
+  'cogl-graphene.c',
 ]
 
 if have_x11
diff --git a/cogl/tests/conform/meson.build b/cogl/tests/conform/meson.build
index eb4e4b599664a8d5cd009d3d91002b9185cb8e1b..b278dfd9cae6b8f344392e6ccd8f78ddf9f83ab6 100644
--- a/cogl/tests/conform/meson.build
+++ b/cogl/tests/conform/meson.build
@@ -25,7 +25,6 @@ cogl_test_conformance_sources = [
   'test-point-sprite.c',
   'test-no-gl-header.c',
   'test-version.c',
-  'test-euler.c',
   'test-layer-remove.c',
   'test-alpha-test.c',
   'test-map-buffer-range.c',
diff --git a/cogl/tests/conform/test-conform-main.c b/cogl/tests/conform/test-conform-main.c
index e1f32c5e2dbf1911790b9559888d124b6b91fda8..c3619aa3c67b783fa042eac4ee1c5478b467e963 100644
--- a/cogl/tests/conform/test-conform-main.c
+++ b/cogl/tests/conform/test-conform-main.c
@@ -132,7 +132,6 @@ main (int argc, char **argv)
 
   UNPORTED_TEST (test_viewport);
 
-  ADD_TEST (test_euler, 0, 0);
   ADD_TEST (test_color_hsl, 0, 0);
 
   ADD_TEST (test_fence, TEST_REQUIREMENT_FENCE, 0);
diff --git a/cogl/tests/conform/test-declarations.h b/cogl/tests/conform/test-declarations.h
index 850d59f0f8df161e1bec6ecbeb739cbc7a94bf4d..50052cd1e9c8656bf5963a0731d1bd9f44e8355f 100644
--- a/cogl/tests/conform/test-declarations.h
+++ b/cogl/tests/conform/test-declarations.h
@@ -44,7 +44,6 @@ void test_pipeline_shader_state (void);
 void test_gles2_context (void);
 void test_gles2_context_fbo (void);
 void test_gles2_context_copy_tex_image (void);
-void test_euler (void);
 void test_color_hsl (void);
 void test_fence (void);
 void test_texture_no_allocate (void);
diff --git a/cogl/tests/conform/test-euler.c b/cogl/tests/conform/test-euler.c
deleted file mode 100644
index c911a1a1374cef238f6bd66158b597cf389cb351..0000000000000000000000000000000000000000
--- a/cogl/tests/conform/test-euler.c
+++ /dev/null
@@ -1,68 +0,0 @@
-#include <cogl/cogl.h>
-#include <math.h>
-#include <string.h>
-
-#include "test-declarations.h"
-#include "test-utils.h"
-
-/* Macros are used here instead of functions so that the
- * g_assert_cmpfloat will give a more interesting message when it
- * fails */
-
-#define COMPARE_FLOATS(a, b)                    \
-  do {                                          \
-    if (fabsf ((a) - (b)) >= 0.0001f)           \
-      g_assert_cmpfloat ((a), ==, (b));         \
-  } while (0)
-
-#define COMPARE_MATRICES(a, b) \
-  do {                                          \
-    COMPARE_FLOATS ((a)->xx, (b)->xx);          \
-    COMPARE_FLOATS ((a)->yx, (b)->yx);          \
-    COMPARE_FLOATS ((a)->zx, (b)->zx);          \
-    COMPARE_FLOATS ((a)->wx, (b)->wx);          \
-    COMPARE_FLOATS ((a)->xy, (b)->xy);          \
-    COMPARE_FLOATS ((a)->yy, (b)->yy);          \
-    COMPARE_FLOATS ((a)->zy, (b)->zy);          \
-    COMPARE_FLOATS ((a)->wy, (b)->wy);          \
-    COMPARE_FLOATS ((a)->xz, (b)->xz);          \
-    COMPARE_FLOATS ((a)->yz, (b)->yz);          \
-    COMPARE_FLOATS ((a)->zz, (b)->zz);          \
-    COMPARE_FLOATS ((a)->wz, (b)->wz);          \
-    COMPARE_FLOATS ((a)->xw, (b)->xw);          \
-    COMPARE_FLOATS ((a)->yw, (b)->yw);          \
-    COMPARE_FLOATS ((a)->zw, (b)->zw);          \
-    COMPARE_FLOATS ((a)->ww, (b)->ww);          \
-  } while (0)
-
-void
-test_euler (void)
-{
-  graphene_euler_t euler;
-  CoglMatrix matrix_a, matrix_b;
-
-  /* Try doing the rotation with three separate rotations */
-  cogl_matrix_init_identity (&matrix_a);
-  cogl_matrix_rotate (&matrix_a, -30.0f, 0.0f, 1.0f, 0.0f);
-  cogl_matrix_rotate (&matrix_a, 40.0f, 1.0f, 0.0f, 0.0f);
-  cogl_matrix_rotate (&matrix_a, 50.0f, 0.0f, 0.0f, 1.0f);
-
-  /* And try the same rotation with a euler */
-  graphene_euler_init_with_order (&euler, 40, -30, 50, GRAPHENE_EULER_ORDER_RYXZ);
-  cogl_matrix_init_from_euler (&matrix_b, &euler);
-
-  /* Verify that the matrices are approximately the same */
-  COMPARE_MATRICES (&matrix_a, &matrix_b);
-
-  /* Try applying the rotation from a euler to a framebuffer */
-  cogl_framebuffer_identity_matrix (test_fb);
-  cogl_framebuffer_rotate_euler (test_fb, &euler);
-  memset (&matrix_b, 0, sizeof (matrix_b));
-  cogl_framebuffer_get_modelview_matrix (test_fb, &matrix_b);
-  COMPARE_MATRICES (&matrix_a, &matrix_b);
-
-  /* FIXME: This needs a lot more tests! */
-
-  if (cogl_test_verbose ())
-    g_print ("OK\n");
-}
diff --git a/cogl/tests/conform/test-offscreen.c b/cogl/tests/conform/test-offscreen.c
index d5f77994721154b5316bbb20395aa1ee27e348b8..a5de870e5515f6c7463a8bbf2b89d564c7e87f38 100644
--- a/cogl/tests/conform/test-offscreen.c
+++ b/cogl/tests/conform/test-offscreen.c
@@ -72,6 +72,7 @@ test_paint (TestState *state)
    * verify it gets restored when we call cogl_pop_framebuffer () */
   cogl_framebuffer_scale (test_fb, 2, 2, 1);
 
+
   opaque_pipeline = cogl_pipeline_new (test_ctx);
   /* red, top left */
   cogl_pipeline_set_color4ub (opaque_pipeline, 0xff, 0x00, 0x00, 0xff);
diff --git a/cogl/tests/conform/test-pipeline-uniforms.c b/cogl/tests/conform/test-pipeline-uniforms.c
index a02f5d446491bbc8230d2620fb452cabb3631321..299985fecbdf2afa2e04e0b9e62e23b351f42074 100644
--- a/cogl/tests/conform/test-pipeline-uniforms.c
+++ b/cogl/tests/conform/test-pipeline-uniforms.c
@@ -218,33 +218,33 @@ paint_color_pipelines (TestState *state)
 static void
 paint_matrix_pipeline (CoglPipeline *pipeline)
 {
-  CoglMatrix matrices[4];
+  graphene_matrix_t matrices[4];
   float matrix_floats[16 * 4];
   int uniform_location;
   int i;
 
   for (i = 0; i < 4; i++)
-    cogl_matrix_init_identity (matrices + i);
+    graphene_matrix_init_identity (matrices + i);
 
   /* Use the first matrix to make the color red */
-  cogl_matrix_translate (matrices + 0, 1.0f, 0.0f, 0.0f);
+  graphene_matrix_translate (&matrices[0],
+                             &GRAPHENE_POINT3D_INIT (1.0f, 0.0f, 0.0f));
 
   /* Rotate the vertex so that it ends up green */
-  cogl_matrix_rotate (matrices + 1, 90.0f, 0.0f, 0.0f, 1.0f);
+  graphene_matrix_rotate (&matrices[1], 90.0f, graphene_vec3_z_axis ());
 
   /* Scale the vertex so it ends up halved */
-  cogl_matrix_scale (matrices + 2, 0.5f, 0.5f, 0.5f);
+  graphene_matrix_scale (&matrices[2], 0.5f, 0.5f, 0.5f);
 
   /* Add a blue component in the final matrix. The final matrix is
      uploaded as transposed so we need to transpose first to cancel
      that out */
-  cogl_matrix_translate (matrices + 3, 0.0f, 0.0f, 1.0f);
-  cogl_matrix_transpose (matrices + 3);
+  graphene_matrix_translate (&matrices[3],
+                             &GRAPHENE_POINT3D_INIT (0.0f, 0.0f, 1.0f));
+  graphene_matrix_transpose (&matrices[3], &matrices[3]);
 
   for (i = 0; i < 4; i++)
-    memcpy (matrix_floats + i * 16,
-            cogl_matrix_get_array (matrices + i),
-            sizeof (float) * 16);
+    graphene_matrix_to_float (&matrices[i], &matrix_floats[i * 16]);
 
   /* Set the first three matrices as transposed */
   uniform_location =
diff --git a/cogl/tests/conform/test-pipeline-user-matrix.c b/cogl/tests/conform/test-pipeline-user-matrix.c
index 37304688a42f0a4f2f3b417e56cf0b82f96f7f5d..689eeeae987c3fa214cbe351d489922baadbdb61 100644
--- a/cogl/tests/conform/test-pipeline-user-matrix.c
+++ b/cogl/tests/conform/test-pipeline-user-matrix.c
@@ -54,7 +54,7 @@ paint (TestState *state)
   };
   CoglTexture *tex0, *tex1;
   CoglPipeline *pipeline;
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
   GError *error = NULL;
 
   cogl_framebuffer_orthographic (test_fb,
@@ -66,7 +66,7 @@ paint (TestState *state)
 
   cogl_framebuffer_clear4f (test_fb, COGL_BUFFER_BIT_COLOR, 0, 0, 0, 1);
 
-  cogl_matrix_init_identity (&matrix);
+  graphene_matrix_init_identity (&matrix);
   cogl_framebuffer_set_modelview_matrix (test_fb, &matrix);
 
   tex0 = cogl_texture_new_from_data (2, 2,
@@ -104,15 +104,15 @@ paint (TestState *state)
     }
 
   /* Set a matrix on the first layer so that it will mirror about the y-axis */
-  cogl_matrix_init_identity (&matrix);
-  cogl_matrix_translate (&matrix, 0.0f, 1.0f, 0.0f);
-  cogl_matrix_scale (&matrix, 1.0f, -1.0f, 1.0f);
+  graphene_matrix_init_scale (&matrix, 1.0f, -1.0f, 1.0f);
+  graphene_matrix_translate (&matrix,
+                             &GRAPHENE_POINT3D_INIT (0.0f, 1.0f, 0.0f));
   cogl_pipeline_set_layer_matrix (pipeline, 0, &matrix);
 
   /* Set a matrix on the second layer so that it will mirror about the x-axis */
-  cogl_matrix_init_identity (&matrix);
-  cogl_matrix_translate (&matrix, 1.0f, 0.0f, 0.0f);
-  cogl_matrix_scale (&matrix, -1.0f, 1.0f, 1.0f);
+  graphene_matrix_init_scale (&matrix, -1.0f, 1.0f, 1.0f);
+  graphene_matrix_translate (&matrix,
+                             &GRAPHENE_POINT3D_INIT (1.0f, 0.0f, 0.0f));
   cogl_pipeline_set_layer_matrix (pipeline, 1, &matrix);
 
   cogl_framebuffer_draw_rectangle (test_fb,
diff --git a/cogl/tests/conform/test-primitive-and-journal.c b/cogl/tests/conform/test-primitive-and-journal.c
index aa93a1f1c64e82b429e9202d14cb60ecf9fc6836..343812ca20f129212bb7a3e0f091560a9f5d58f8 100644
--- a/cogl/tests/conform/test-primitive-and-journal.c
+++ b/cogl/tests/conform/test-primitive-and-journal.c
@@ -8,7 +8,7 @@ typedef CoglVertexP2C4 Vertex;
 static void
 setup_orthographic_modelview (void)
 {
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
   int fb_width = cogl_framebuffer_get_width (test_fb);
   int fb_height = cogl_framebuffer_get_height (test_fb);
 
@@ -18,13 +18,10 @@ setup_orthographic_modelview (void)
    * matrix we asked for. The matrix sets up an orthographic transform
    * in the modelview matrix */
 
-  cogl_matrix_init_identity (&matrix);
-  cogl_matrix_orthographic (&matrix,
-                            0.0f, 0.0f, /* x_1 y_1 */
-                            fb_width,
-                            fb_height,
-                            -1.0f, /* nearval */
-                            1.0f /* farval */);
+  graphene_matrix_init_ortho (&matrix,
+                              0.f, fb_width,
+                              fb_height, 0.f,
+                              -1.f, 1.f);
   cogl_framebuffer_set_modelview_matrix (test_fb, &matrix);
 }
 
diff --git a/cogl/tests/conform/test-readpixels.c b/cogl/tests/conform/test-readpixels.c
index 003179436dcbfd139964f0992a31272f7a42967c..64824b0aa987cd3f0c53a522af4acc52796c5b93 100644
--- a/cogl/tests/conform/test-readpixels.c
+++ b/cogl/tests/conform/test-readpixels.c
@@ -20,9 +20,9 @@ on_paint (ClutterActor        *actor,
           void                *state)
 {
   float saved_viewport[4];
-  CoglMatrix saved_projection;
-  CoglMatrix projection;
-  CoglMatrix modelview;
+  graphene_matrix_t saved_projection;
+  graphene_matrix_t projection;
+  graphene_matrix_t modelview;
   guchar *data;
   CoglHandle tex;
   CoglHandle offscreen;
@@ -35,8 +35,8 @@ on_paint (ClutterActor        *actor,
   cogl_get_projection_matrix (&saved_projection);
   cogl_push_matrix ();
 
-  cogl_matrix_init_identity (&projection);
-  cogl_matrix_init_identity (&modelview);
+  graphene_matrix_init_identity (&projection);
+  graphene_matrix_init_identity (&modelview);
 
   cogl_set_projection_matrix (&projection);
   cogl_set_modelview_matrix (&modelview);
diff --git a/cogl/tests/conform/test-snippets.c b/cogl/tests/conform/test-snippets.c
index 9b19b221bf169f9d2046053c04cb52f484d424b7..5ed3d8d0f45c8bf9a32656a728cb33afbcbe3408 100644
--- a/cogl/tests/conform/test-snippets.c
+++ b/cogl/tests/conform/test-snippets.c
@@ -431,13 +431,13 @@ test_modify_vertex_layer (TestState *state)
 {
   CoglPipeline *pipeline;
   CoglSnippet *snippet;
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
 
   /* Test modifying the vertex layer code */
   pipeline = create_texture_pipeline (state);
 
-  cogl_matrix_init_identity (&matrix);
-  cogl_matrix_translate (&matrix, 0.0f, 1.0f, 0.0f);
+  graphene_matrix_init_translate (&matrix,
+                                  &GRAPHENE_POINT3D_INIT (0.0f, 1.0f, 0.0f));
   cogl_pipeline_set_layer_matrix (pipeline, 0, &matrix);
 
   snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM,
@@ -460,13 +460,13 @@ test_replace_vertex_layer (TestState *state)
 {
   CoglPipeline *pipeline;
   CoglSnippet *snippet;
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
 
   /* Test replacing the vertex layer code */
   pipeline = create_texture_pipeline (state);
 
-  cogl_matrix_init_identity (&matrix);
-  cogl_matrix_translate (&matrix, 0.0f, 1.0f, 0.0f);
+  graphene_matrix_init_translate (&matrix,
+                                  &GRAPHENE_POINT3D_INIT (0.0f, 1.0f, 0.0f));
   cogl_pipeline_set_layer_matrix (pipeline, 0, &matrix);
 
   snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM,
@@ -490,13 +490,14 @@ test_vertex_transform_hook (TestState *state)
 {
   CoglPipeline *pipeline;
   CoglSnippet *snippet;
-  CoglMatrix identity_matrix;
-  CoglMatrix matrix;
+  graphene_matrix_t identity_matrix;
+  graphene_matrix_t matrix;
+  float v[16];
   int location;
 
   /* Test the vertex transform hook */
 
-  cogl_matrix_init_identity (&identity_matrix);
+  graphene_matrix_init_identity (&identity_matrix);
 
   pipeline = cogl_pipeline_new (test_ctx);
 
@@ -513,12 +514,13 @@ test_vertex_transform_hook (TestState *state)
   /* Copy the current projection matrix to a uniform */
   cogl_framebuffer_get_projection_matrix (test_fb, &matrix);
   location = cogl_pipeline_get_uniform_location (pipeline, "pmat");
+  graphene_matrix_to_float (&matrix, v);
   cogl_pipeline_set_uniform_matrix (pipeline,
                                     location,
                                     4, /* dimensions */
                                     1, /* count */
                                     FALSE, /* don't transpose */
-                                    cogl_matrix_get_array (&matrix));
+                                    v);
 
   /* Replace the real projection matrix with the identity. This should
      mess up the drawing unless the snippet replacement is working */
diff --git a/cogl/tests/conform/test-viewport.c b/cogl/tests/conform/test-viewport.c
index e4d172872709b013a715b235c2c3e54cbe3b080b..3b58a2351f4d209657bac389bbccfb2f1b1bf873 100644
--- a/cogl/tests/conform/test-viewport.c
+++ b/cogl/tests/conform/test-viewport.c
@@ -71,9 +71,9 @@ on_paint (ClutterActor        *actor,
           void                *state)
 {
   float saved_viewport[4];
-  CoglMatrix saved_projection;
-  CoglMatrix projection;
-  CoglMatrix modelview;
+  graphene_matrix_t saved_projection;
+  graphene_matrix_t projection;
+  graphene_matrix_t modelview;
   guchar *data;
   CoglHandle tex;
   CoglHandle offscreen;
@@ -90,8 +90,8 @@ on_paint (ClutterActor        *actor,
   cogl_get_projection_matrix (&saved_projection);
   cogl_push_matrix ();
 
-  cogl_matrix_init_identity (&projection);
-  cogl_matrix_init_identity (&modelview);
+  graphene_matrix_init_identity (&projection);
+  graphene_matrix_init_identity (&modelview);
 
   cogl_set_projection_matrix (&projection);
   cogl_set_modelview_matrix (&modelview);
@@ -354,8 +354,8 @@ on_paint (ClutterActor        *actor,
 
   /* Uncomment to display the last contents of the offscreen framebuffer */
 #if 1
-  cogl_matrix_init_identity (&projection);
-  cogl_matrix_init_identity (&modelview);
+  graphene_matrix_init_identity (&projection);
+  graphene_matrix_init_identity (&modelview);
   cogl_set_viewport (0, 0, FRAMEBUFFER_WIDTH, FRAMEBUFFER_HEIGHT);
   cogl_set_projection_matrix (&projection);
   cogl_set_modelview_matrix (&modelview);
diff --git a/meson.build b/meson.build
index 1204218f778df78d9ae1ad30ff755357bd0fd640..247bbb91b9cb1b8cd3cc7c1af306a7d249070693 100644
--- a/meson.build
+++ b/meson.build
@@ -15,7 +15,7 @@ libmutter_api_version = '@0@'.format(api_version)
 fribidi_req = '>= 1.0.0'
 glib_req = '>= 2.61.1'
 gi_req = '>= 0.9.5'
-graphene_req = '>= 1.9.3'
+graphene_req = '>= 1.10.2'
 gtk3_req = '>= 3.19.8'
 gdk_pixbuf_req = '>= 2.0'
 uprof_req = '>= 0.3'
diff --git a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
index d698baba64e7c3871e84b412cc4c663d00cf023d..1688c5cb421021685c90a0baad0e56ebce4bc468 100644
--- a/src/backends/meta-renderer-view.c
+++ b/src/backends/meta-renderer-view.c
@@ -74,46 +74,46 @@ meta_renderer_view_get_crtc (MetaRendererView *view)
 }
 
 static void
-meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView *view,
-                                                        CoglMatrix       *matrix)
+meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
+                                                        graphene_matrix_t *matrix)
 {
   MetaRendererView *renderer_view = META_RENDERER_VIEW (view);
 
-  cogl_matrix_init_identity (matrix);
+  graphene_matrix_init_identity (matrix);
 
   switch (renderer_view->transform)
     {
     case META_MONITOR_TRANSFORM_NORMAL:
       break;
     case META_MONITOR_TRANSFORM_90:
-      cogl_matrix_rotate (matrix, 90, 0, 0, 1);
-      cogl_matrix_translate (matrix, 0, -1, 0);
+      graphene_matrix_translate (matrix, &GRAPHENE_POINT3D_INIT (0, -1, 0));
+      graphene_matrix_rotate (matrix, 90, graphene_vec3_z_axis ());
       break;
     case META_MONITOR_TRANSFORM_180:
-      cogl_matrix_rotate (matrix, 180, 0, 0, 1);
-      cogl_matrix_translate (matrix, -1, -1, 0);
+      graphene_matrix_translate (matrix, &GRAPHENE_POINT3D_INIT (-1, -1, 0));
+      graphene_matrix_rotate (matrix, 180, graphene_vec3_z_axis ());
       break;
     case META_MONITOR_TRANSFORM_270:
-      cogl_matrix_rotate (matrix, 270, 0, 0, 1);
-      cogl_matrix_translate (matrix, -1, 0, 0);
+      graphene_matrix_translate (matrix, &GRAPHENE_POINT3D_INIT (-1, 0, 0));
+      graphene_matrix_rotate (matrix, 270, graphene_vec3_z_axis ());
       break;
     case META_MONITOR_TRANSFORM_FLIPPED:
-      cogl_matrix_scale (matrix, -1, 1, 1);
-      cogl_matrix_translate (matrix, -1, 0, 0);
+      graphene_matrix_translate (matrix, &GRAPHENE_POINT3D_INIT (-1, 0, 0));
+      graphene_matrix_scale (matrix, -1, 1, 1);
       break;
     case META_MONITOR_TRANSFORM_FLIPPED_90:
-      cogl_matrix_scale (matrix, -1, 1, 1);
-      cogl_matrix_rotate (matrix, 90, 0, 0, 1);
+      graphene_matrix_rotate (matrix, 90, graphene_vec3_z_axis ());
+      graphene_matrix_scale (matrix, -1, 1, 1);
       break;
     case META_MONITOR_TRANSFORM_FLIPPED_180:
-      cogl_matrix_scale (matrix, -1, 1, 1);
-      cogl_matrix_rotate (matrix, 180, 0, 0, 1);
-      cogl_matrix_translate (matrix, 0, -1, 0);
+      graphene_matrix_translate (matrix, &GRAPHENE_POINT3D_INIT (0, -1, 0));
+      graphene_matrix_rotate (matrix, 180, graphene_vec3_z_axis ());
+      graphene_matrix_scale (matrix, -1, 1, 1);
       break;
     case META_MONITOR_TRANSFORM_FLIPPED_270:
-      cogl_matrix_scale (matrix, -1, 1, 1);
-      cogl_matrix_rotate (matrix, 270, 0, 0, 1);
-      cogl_matrix_translate (matrix, -1, -1, 0);
+      graphene_matrix_translate (matrix, &GRAPHENE_POINT3D_INIT (-1, -1, 0));
+      graphene_matrix_rotate (matrix, 270, graphene_vec3_z_axis ());
+      graphene_matrix_scale (matrix, -1, 1, 1);
       break;
     }
 }
@@ -122,7 +122,7 @@ static void
 meta_renderer_view_setup_offscreen_blit_pipeline (ClutterStageView *view,
                                                   CoglPipeline     *pipeline)
 {
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
 
   meta_renderer_view_get_offscreen_transformation_matrix (view, &matrix);
   cogl_pipeline_set_layer_matrix (pipeline, 0, &matrix);
diff --git a/src/backends/x11/nested/meta-stage-x11-nested.c b/src/backends/x11/nested/meta-stage-x11-nested.c
index be0ece2fa015fc23b131b4700568a342efc9c2b8..165d40c943db6042907021226717dfcae8f9648d 100644
--- a/src/backends/x11/nested/meta-stage-x11-nested.c
+++ b/src/backends/x11/nested/meta-stage-x11-nested.c
@@ -110,8 +110,8 @@ draw_view (MetaStageX11Nested *stage_nested,
   ClutterStageView *stage_view = CLUTTER_STAGE_VIEW (renderer_view);
   MetaCrtc *crtc;
   const MetaCrtcConfig *crtc_config;
-  CoglMatrix projection_matrix;
-  CoglMatrix transform;
+  graphene_matrix_t projection_matrix;
+  graphene_matrix_t transform;
   float texture_width, texture_height;
   float sample_x, sample_y, sample_width, sample_height;
   float s_1, t_1, s_2, t_2;
@@ -131,11 +131,10 @@ draw_view (MetaStageX11Nested *stage_nested,
                                                           &transform);
 
   cogl_framebuffer_push_matrix (onscreen);
-  cogl_matrix_init_identity (&projection_matrix);
-  cogl_matrix_translate (&projection_matrix, -1, 1, 0);
-  cogl_matrix_scale (&projection_matrix, 2, -2, 0);
-
-  cogl_matrix_multiply (&projection_matrix, &projection_matrix, &transform);
+  graphene_matrix_init_scale (&projection_matrix, 2, -2, 0);
+  graphene_matrix_translate (&projection_matrix,
+                             &GRAPHENE_POINT3D_INIT (-1, 1, 0));
+  graphene_matrix_multiply (&transform, &projection_matrix, &projection_matrix);
   cogl_framebuffer_set_projection_matrix (onscreen, &projection_matrix);
 
   s_1 = sample_x / texture_width;
diff --git a/src/compositor/clutter-utils.c b/src/compositor/clutter-utils.c
index f05a698f58a9c40f8c926bb6581c7319c7e00726..86d788562e383c38961de1b385bb7bbf16424d28 100644
--- a/src/compositor/clutter-utils.c
+++ b/src/compositor/clutter-utils.c
@@ -140,7 +140,7 @@ meta_actor_painting_untransformed (CoglFramebuffer *fb,
                                    int             *x_origin,
                                    int             *y_origin)
 {
-  CoglMatrix modelview, projection, modelview_projection;
+  graphene_matrix_t modelview, projection, modelview_projection;
   graphene_point3d_t vertices[4];
   float viewport[4];
   int i;
@@ -148,9 +148,9 @@ meta_actor_painting_untransformed (CoglFramebuffer *fb,
   cogl_framebuffer_get_modelview_matrix (fb, &modelview);
   cogl_framebuffer_get_projection_matrix (fb, &projection);
 
-  cogl_matrix_multiply (&modelview_projection,
-                        &projection,
-                        &modelview);
+  graphene_matrix_multiply (&modelview,
+                            &projection,
+                            &modelview_projection);
 
   vertices[0].x = 0;
   vertices[0].y = 0;
@@ -170,11 +170,11 @@ meta_actor_painting_untransformed (CoglFramebuffer *fb,
   for (i = 0; i < 4; i++)
     {
       float w = 1;
-      cogl_matrix_transform_point (&modelview_projection,
-                                   &vertices[i].x,
-                                   &vertices[i].y,
-                                   &vertices[i].z,
-                                   &w);
+      cogl_graphene_matrix_project_point (&modelview_projection,
+                                          &vertices[i].x,
+                                          &vertices[i].y,
+                                          &vertices[i].z,
+                                          &w);
       vertices[i].x = MTX_GL_SCALE_X (vertices[i].x, w,
                                       viewport[2], viewport[0]);
       vertices[i].y = MTX_GL_SCALE_Y (vertices[i].y, w,
diff --git a/src/compositor/meta-shaped-texture.c b/src/compositor/meta-shaped-texture.c
index a8e8216dbf50854607f02b27005adca9a0a9071e..2637a63fe4590b0d683d09c832f5609ee7d97dfd 100644
--- a/src/compositor/meta-shaped-texture.c
+++ b/src/compositor/meta-shaped-texture.c
@@ -273,7 +273,7 @@ get_base_pipeline (MetaShapedTexture *stex,
                    CoglContext       *ctx)
 {
   CoglPipeline *pipeline;
-  CoglMatrix matrix;
+  graphene_matrix_t matrix;
 
   if (stex->base_pipeline)
     return stex->base_pipeline;
@@ -288,20 +288,14 @@ get_base_pipeline (MetaShapedTexture *stex,
   cogl_pipeline_set_layer_wrap_mode_t (pipeline, 1,
                                        COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE);
 
-  cogl_matrix_init_identity (&matrix);
-
-  if (!stex->is_y_inverted)
-    {
-      cogl_matrix_scale (&matrix, 1, -1, 1);
-      cogl_matrix_translate (&matrix, 0, -1, 0);
-      cogl_pipeline_set_layer_matrix (pipeline, 0, &matrix);
-    }
+  graphene_matrix_init_identity (&matrix);
 
   if (stex->transform != META_MONITOR_TRANSFORM_NORMAL)
     {
       graphene_euler_t euler;
 
-      cogl_matrix_translate (&matrix, 0.5, 0.5, 0.0);
+      graphene_matrix_translate (&matrix,
+                                 &GRAPHENE_POINT3D_INIT (-0.5, -0.5, 0.0));
       switch (stex->transform)
         {
         case META_MONITOR_TRANSFORM_90:
@@ -335,40 +329,50 @@ get_base_pipeline (MetaShapedTexture *stex,
         case META_MONITOR_TRANSFORM_NORMAL:
           g_assert_not_reached ();
         }
-      cogl_matrix_rotate_euler (&matrix, &euler);
-      cogl_matrix_translate (&matrix, -0.5, -0.5, 0.0);
+      graphene_matrix_rotate_euler (&matrix, &euler);
+      graphene_matrix_translate (&matrix,
+                                 &GRAPHENE_POINT3D_INIT (0.5, 0.5, 0.0));
     }
 
   if (stex->has_viewport_src_rect)
     {
       float scaled_tex_width = stex->tex_width / (float) stex->buffer_scale;
       float scaled_tex_height = stex->tex_height / (float) stex->buffer_scale;
+      graphene_point3d_t p;
+
+      graphene_point3d_init (&p,
+                             stex->viewport_src_rect.origin.x /
+                             stex->viewport_src_rect.size.width,
+                             stex->viewport_src_rect.origin.y /
+                             stex->viewport_src_rect.size.height,
+                             0);
+      graphene_matrix_translate (&matrix, &p);
 
       if (meta_monitor_transform_is_rotated (stex->transform))
         {
-          cogl_matrix_scale (&matrix,
-                             stex->viewport_src_rect.size.width /
-                             scaled_tex_height,
-                             stex->viewport_src_rect.size.height /
-                             scaled_tex_width,
-                             1);
+          graphene_matrix_scale (&matrix,
+                                 stex->viewport_src_rect.size.width /
+                                 scaled_tex_height,
+                                 stex->viewport_src_rect.size.height /
+                                 scaled_tex_width,
+                                 1);
         }
       else
         {
-          cogl_matrix_scale (&matrix,
-                             stex->viewport_src_rect.size.width /
-                             scaled_tex_width,
-                             stex->viewport_src_rect.size.height /
-                             scaled_tex_height,
-                             1);
+          graphene_matrix_scale (&matrix,
+                                 stex->viewport_src_rect.size.width /
+                                 scaled_tex_width,
+                                 stex->viewport_src_rect.size.height /
+                                 scaled_tex_height,
+                                 1);
         }
+    }
 
-      cogl_matrix_translate (&matrix,
-                             stex->viewport_src_rect.origin.x /
-                             stex->viewport_src_rect.size.width,
-                             stex->viewport_src_rect.origin.y /
-                             stex->viewport_src_rect.size.height,
-                             0);
+  if (!stex->is_y_inverted)
+    {
+      graphene_matrix_translate (&matrix, &GRAPHENE_POINT3D_INIT (0, -1, 0));
+      graphene_matrix_scale (&matrix, 1, -1, 1);
+      cogl_pipeline_set_layer_matrix (pipeline, 0, &matrix);
     }
 
   cogl_pipeline_set_layer_matrix (pipeline, 0, &matrix);
@@ -1364,7 +1368,7 @@ get_image_via_offscreen (MetaShapedTexture     *stex,
   GError *error = NULL;
   CoglOffscreen *offscreen;
   CoglFramebuffer *fb;
-  CoglMatrix projection_matrix;
+  graphene_matrix_t projection_matrix;
   cairo_rectangle_int_t fallback_clip;
   ClutterColor clear_color;
   ClutterPaintContext *paint_context;
@@ -1403,13 +1407,13 @@ get_image_via_offscreen (MetaShapedTexture     *stex,
     }
 
   cogl_framebuffer_push_matrix (fb);
-  cogl_matrix_init_identity (&projection_matrix);
-  cogl_matrix_scale (&projection_matrix,
-                     1.0 / (image_width / 2.0),
-                     -1.0 / (image_height / 2.0), 0);
-  cogl_matrix_translate (&projection_matrix,
-                         -(image_width / 2.0),
-                         -(image_height / 2.0), 0);
+  graphene_matrix_init_translate (&projection_matrix,
+                                  &GRAPHENE_POINT3D_INIT (-(image_width / 2.0),
+                                                          -(image_height / 2.0),
+                                                          0));
+  graphene_matrix_scale (&projection_matrix,
+                         1.0 / (image_width / 2.0),
+                         -1.0 / (image_height / 2.0), 0);
 
   cogl_framebuffer_set_projection_matrix (fb, &projection_matrix);
 
diff --git a/src/compositor/meta-texture-tower.c b/src/compositor/meta-texture-tower.c
index b0df9ed06aa9073f9e76a00bc678a33c1a89d970..cb7b997262a1dceaf5c6f43b1964fef64ab373d8 100644
--- a/src/compositor/meta-texture-tower.c
+++ b/src/compositor/meta-texture-tower.c
@@ -248,7 +248,10 @@ get_paint_level (ClutterPaintContext *paint_context,
                  int                  height)
 {
   CoglFramebuffer *framebuffer;
-  CoglMatrix projection, modelview, pm;
+  graphene_matrix_t projection, modelview, pm;
+  float xx, xy, xw;
+  float yx, yy, yw;
+  float wx, wy, ww;
   float v[4];
   double viewport_width, viewport_height;
   double u0, v0;
@@ -278,7 +281,17 @@ get_paint_level (ClutterPaintContext *paint_context,
   cogl_framebuffer_get_projection_matrix (framebuffer, &projection);
   cogl_framebuffer_get_modelview_matrix (framebuffer, &modelview);
 
-  cogl_matrix_multiply (&pm, &projection, &modelview);
+  graphene_matrix_multiply (&modelview, &projection, &pm);
+
+  xx = graphene_matrix_get_value (&pm, 0, 0);
+  xy = graphene_matrix_get_value (&pm, 0, 1);
+  xw = graphene_matrix_get_value (&pm, 0, 3);
+  yx = graphene_matrix_get_value (&pm, 1, 0);
+  yy = graphene_matrix_get_value (&pm, 1, 1);
+  yw = graphene_matrix_get_value (&pm, 1, 3);
+  wx = graphene_matrix_get_value (&pm, 3, 0);
+  wy = graphene_matrix_get_value (&pm, 3, 1);
+  ww = graphene_matrix_get_value (&pm, 3, 3);
 
   cogl_framebuffer_get_viewport4fv (framebuffer, v);
   viewport_width = v[2];
@@ -287,9 +300,9 @@ get_paint_level (ClutterPaintContext *paint_context,
   u0 = width / 2.;
   v0 = height / 2.;
 
-  xc = pm.xx * u0 + pm.xy * v0 + pm.xw;
-  yc = pm.yx * u0 + pm.yy * v0 + pm.yw;
-  wc = pm.wx * u0 + pm.wy * v0 + pm.ww;
+  xc = xx * u0 + yx * v0 + wx;
+  yc = xy * u0 + yy * v0 + wy;
+  wc = xw * u0 + yw * v0 + ww;
 
   /* We'll simplify the equations below for a bit of micro-optimization.
    * The commented out code is the unsimplified version.
@@ -302,10 +315,10 @@ get_paint_level (ClutterPaintContext *paint_context,
   // with respect to u, v, using
   // d(a/b)/dx = da/dx * (1/b) - a * db/dx / (b^2)
 
-  dxdu = 0.5 * viewport_width * (pm.xx - pm.wx * (xc/wc)) / wc;
-  dxdv = 0.5 * viewport_width * (pm.xy - pm.wy * (xc/wc)) / wc;
-  dydu = 0.5 * viewport_height * (pm.yx - pm.wx * (yc/wc)) / wc;
-  dydv = 0.5 * viewport_height * (pm.yy - pm.wy * (yc/wc)) / wc;
+  dxdu = 0.5 * viewport_width * (xx - xw * (xc/wc)) / wc;
+  dxdv = 0.5 * viewport_width * (yx - yw * (xc/wc)) / wc;
+  dydu = 0.5 * viewport_height * (xy - xw * (yc/wc)) / wc;
+  dydv = 0.5 * viewport_height * (yy - yw * (yc/wc)) / wc;
 
   // Compute the inverse partials as the matrix inverse
   det = dxdu * dydv - dxdv * dydu;
@@ -324,10 +337,10 @@ get_paint_level (ClutterPaintContext *paint_context,
   */
 
   /* dxdu * wc, etc */
-  dxdu_ = 0.5 * viewport_width * (pm.xx - pm.wx * (xc/wc));
-  dxdv_ = 0.5 * viewport_width * (pm.xy - pm.wy * (xc/wc));
-  dydu_ = 0.5 * viewport_height * (pm.yx - pm.wx * (yc/wc));
-  dydv_ = 0.5 * viewport_height * (pm.yy - pm.wy * (yc/wc));
+  dxdu_ = 0.5 * viewport_width * (xx - xw * (xc/wc));
+  dxdv_ = 0.5 * viewport_width * (yx - yw * (xc/wc));
+  dydu_ = 0.5 * viewport_height * (xy - xw * (yc/wc));
+  dydv_ = 0.5 * viewport_height * (yy - yw * (yc/wc));
 
   /* det * wc^2 */
   det_ = dxdu_ * dydv_ - dxdv_ * dydu_;
@@ -340,7 +353,7 @@ get_paint_level (ClutterPaintContext *paint_context,
   lambda = 0.5 * M_LOG2E * log (rho_sq * wc * wc / det_sq) + LOD_BIAS;
 
 #if 0
-  g_print ("%g %g %g\n", 0.5 * viewport_width * pm.xx / pm.ww, 0.5 * viewport_height * pm.yy / pm.ww, lambda);
+  g_print ("%g %g %g\n", 0.5 * viewport_width * xx / ww, 0.5 * viewport_height * yy / ww, lambda);
 #endif
 
   if (lambda <= 0.)
diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index 8d2548fbb76e280b619362ebb074a70f3128d2a0..3b39ce9ddfed3c3166714769575571444bd81049 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -1111,15 +1111,17 @@ meta_window_actor_set_geometry_scale (MetaWindowActor *window_actor,
 {
   MetaWindowActorPrivate *priv =
     meta_window_actor_get_instance_private (window_actor);
-  CoglMatrix child_transform;
+  graphene_matrix_t child_transform;
 
   if (priv->geometry_scale == geometry_scale)
     return;
 
   priv->geometry_scale = geometry_scale;
 
-  cogl_matrix_init_identity (&child_transform);
-  cogl_matrix_scale (&child_transform, geometry_scale, geometry_scale, 1);
+  graphene_matrix_init_scale (&child_transform,
+                              geometry_scale,
+                              geometry_scale,
+                              1);
   clutter_actor_set_child_transform (CLUTTER_ACTOR (window_actor),
                                      &child_transform);
 }
diff --git a/src/tests/clutter/conform/actor-pivot-point.c b/src/tests/clutter/conform/actor-pivot-point.c
index fc196b03f50e50596e94a3a9258ea6b638dddcc2..f16d18dea29b60092ef4f6b95a0779d7a0b87c45 100644
--- a/src/tests/clutter/conform/actor-pivot-point.c
+++ b/src/tests/clutter/conform/actor-pivot-point.c
@@ -10,7 +10,7 @@ static void
 actor_pivot (void)
 {
   ClutterActor *stage, *actor_implicit, *actor_explicit;
-  ClutterMatrix transform, result_implicit, result_explicit;
+  graphene_matrix_t transform, result_implicit, result_explicit;
   ClutterActorBox allocation = CLUTTER_ACTOR_BOX_INIT (0, 0, 90, 30);
   gfloat angle = 30;
 
@@ -33,14 +33,13 @@ actor_pivot (void)
   clutter_actor_set_rotation_angle (actor_implicit, CLUTTER_Z_AXIS, angle);
 
   /* Explicit transformation */
-  clutter_matrix_init_identity(&transform);
-  cogl_matrix_rotate (&transform, angle, 0, 0, 1.0);
+  graphene_matrix_init_rotate (&transform, angle, graphene_vec3_z_axis ());
   clutter_actor_set_transform (actor_explicit, &transform);
 
   clutter_actor_get_transform (actor_implicit, &result_implicit);
   clutter_actor_get_transform (actor_explicit, &result_explicit);
 
-  g_assert (cogl_matrix_equal (&result_implicit, &result_explicit));
+  g_assert (graphene_matrix_equal (&result_implicit, &result_explicit));
 
   clutter_actor_destroy (actor_implicit);
   clutter_actor_destroy (actor_explicit);
diff --git a/src/tests/clutter/interactive/test-cogl-multitexture.c b/src/tests/clutter/interactive/test-cogl-multitexture.c
index 4805d90fe39daacd4e268fedd28d02d3847f5e64..f14f0b7d8a1ac61b50939877595b7bf1cad70a1f 100644
--- a/src/tests/clutter/interactive/test-cogl-multitexture.c
+++ b/src/tests/clutter/interactive/test-cogl-multitexture.c
@@ -21,13 +21,13 @@ typedef struct _TestMultiLayerMaterialState
   ClutterTimeline *timeline;
 
   CoglHandle       material0;
-  CoglMatrix       tex_matrix0;
-  CoglMatrix       rot_matrix0;
+  graphene_matrix_t tex_matrix0;
+  graphene_matrix_t rot_matrix0;
   CoglHandle       light_tex0;
 
   CoglHandle       material1;
-  CoglMatrix       tex_matrix1;
-  CoglMatrix       rot_matrix1;
+  graphene_matrix_t tex_matrix1;
+  graphene_matrix_t rot_matrix1;
   CoglHandle       light_tex1;
 
 } TestMultiLayerMaterialState;
@@ -45,14 +45,14 @@ frame_cb (ClutterTimeline  *timeline,
 {
   TestMultiLayerMaterialState *state = data;
 
-  cogl_matrix_multiply (&state->tex_matrix0,
-			&state->tex_matrix0,
-			&state->rot_matrix0);
+  graphene_matrix_multiply (&state->rot_matrix0,
+                            &state->tex_matrix0,
+                            &state->tex_matrix0);
   cogl_material_set_layer_matrix (state->material0, 2, &state->tex_matrix0);
 
-  cogl_matrix_multiply (&state->tex_matrix1,
-			&state->tex_matrix1,
-			&state->rot_matrix1);
+  graphene_matrix_multiply (&state->rot_matrix1,
+                            &state->tex_matrix1,
+                            &state->tex_matrix1);
   cogl_material_set_layer_matrix (state->material1, 2, &state->tex_matrix1);
 }
 
@@ -196,18 +196,22 @@ test_cogl_multitexture_main (int argc, char *argv[])
 
   state->tex_coords = tex_coords;
 
-  cogl_matrix_init_identity (&state->tex_matrix0);
-  cogl_matrix_init_identity (&state->tex_matrix1);
-  cogl_matrix_init_identity (&state->rot_matrix0);
-  cogl_matrix_init_identity (&state->rot_matrix1);
-
-  cogl_matrix_translate (&state->rot_matrix0, 0.5, 0.5, 0);
-  cogl_matrix_rotate (&state->rot_matrix0, 10.0, 0, 0, 1.0);
-  cogl_matrix_translate (&state->rot_matrix0, -0.5, -0.5, 0);
-
-  cogl_matrix_translate (&state->rot_matrix1, 0.5, 0.5, 0);
-  cogl_matrix_rotate (&state->rot_matrix1, -10.0, 0, 0, 1.0);
-  cogl_matrix_translate (&state->rot_matrix1, -0.5, -0.5, 0);
+  graphene_matrix_init_identity (&state->tex_matrix0);
+  graphene_matrix_init_identity (&state->tex_matrix1);
+  graphene_matrix_init_identity (&state->rot_matrix0);
+  graphene_matrix_init_identity (&state->rot_matrix1);
+
+  graohene_matrix_translate (&state->rot_matrix0,
+                             &GRAPHENE_POINT3D_INIT (-0.5, -0.5, 0));
+  graohene_matrix_rotate (&state->rot_matrix0, 10.0, graphene_vec3_z_axis ());
+  graphene_matrix_translate (&state->rot_matrix0,
+                             &GRAPHENE_POINT3D_INIT (0.5, 0.5, 0));
+
+  graphene_matrix_translate (&state->rot_matrix1,
+                             &GRAPHENE_POINT3D_INIT (-0.5, -0.5, 0));
+  graohene_matrix_rotate (&state->rot_matrix1, -10.0, graphene_vec3_z_axis ());
+  graphene_matrix_translate (&state->rot_matrix1,
+                             &GRAPHENE_POINT3D_INIT (0.5, 0.5, 0));
 
   clutter_actor_set_translation (data->parent_container, -86.f, -125.f, 0.f);
   clutter_container_add_actor (CLUTTER_CONTAINER(stage),
diff --git a/src/tests/clutter/interactive/test-cogl-offscreen.c b/src/tests/clutter/interactive/test-cogl-offscreen.c
index 8580fb45a41e89586a3de4c44e0448b4eecfcfce..5d80899447e8d658abd289304fb13e3299fa51cc 100644
--- a/src/tests/clutter/interactive/test-cogl-offscreen.c
+++ b/src/tests/clutter/interactive/test-cogl-offscreen.c
@@ -181,8 +181,8 @@ setup_viewport (CoglFramebuffer *framebuffer,
                 float            z_far)
 {
   float z_camera;
-  CoglMatrix projection_matrix;
-  CoglMatrix mv_matrix;
+  graphene_matrix_t projection_matrix;
+  graphene_matrix_t mv_matrix;
 
   cogl_framebuffer_set_viewport (framebuffer, 0, 0, width, height);
 
@@ -232,12 +232,15 @@ setup_viewport (CoglFramebuffer *framebuffer,
    */
 
   cogl_framebuffer_get_projection_matrix (framebuffer, &projection_matrix);
-  z_camera = 0.5 * projection_matrix.xx;
-
-  cogl_matrix_init_identity (&mv_matrix);
-  cogl_matrix_translate (&mv_matrix, -0.5f, -0.5f, -z_camera);
-  cogl_matrix_scale (&mv_matrix, 1.0f / width, -1.0f / height, 1.0f / width);
-  cogl_matrix_translate (&mv_matrix, 0.0f, -1.0 * height, 0.0f);
+  z_camera = 0.5 * graphene_matrix_get_value (&projection_matrix, 0, 0);
+
+  graphene_matrix_init_translate (&mv_matrix,
+                                  &GRAPHENE_POINT3D_INIT (0.0f,
+                                                          -1.0 * height,
+                                                          0.0f));
+  graphene_matrix_scale (&mv_matrix, 1.0f / width, -1.0f / height, 1.0f / width);
+  graphene_matrix_translate (&mv_matrix,
+                             &GRAPHENE_POINT3D_INIT (-0.5f, -0.5f, -z_camera));
   cogl_framebuffer_set_modelview_matrix (framebuffer, &mv_matrix);
 }
 
diff --git a/src/tests/clutter/interactive/test-cogl-point-sprites.c b/src/tests/clutter/interactive/test-cogl-point-sprites.c
index 6d4326470ce594b3bc88a2c5e9ddd3c7c83525f3..681fdb71f7843ef278ea5074e61e1a71d282a277 100644
--- a/src/tests/clutter/interactive/test-cogl-point-sprites.c
+++ b/src/tests/clutter/interactive/test-cogl-point-sprites.c
@@ -103,13 +103,13 @@ paint_cb (ClutterActor        *stage,
 {
   CoglFramebuffer *framebuffer =
     clutter_paint_context_get_framebuffer (paint_context);
-  CoglMatrix old_matrix, new_matrix;
+  graphene_matrix_t old_matrix, new_matrix;
   int i;
   float diff_time;
 
   cogl_framebuffer_get_projection_matrix (framebuffer, &old_matrix);
   /* Use an orthogonal projection from -1 -> 1 in both axes */
-  cogl_matrix_init_identity (&new_matrix);
+  graphene_matrix_init_identity (&new_matrix);
   cogl_framebuffer_set_projection_matrix (framebuffer, &new_matrix);
 
   cogl_framebuffer_push_matrix (framebuffer);
