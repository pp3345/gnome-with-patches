diff --git a/clutter/clutter/clutter-backend.c b/clutter/clutter/clutter-backend.c
index d331f9fad8e10600d2fd8c2f87066fe0fe04bde5..5e98a2bbe55b43cde0e262804303e348eaa69446 100644
--- a/clutter/clutter/clutter-backend.c
+++ b/clutter/clutter/clutter-backend.c
@@ -93,7 +93,7 @@ clutter_backend_dispose (GObject *gobject)
   /* clear the events still in the queue of the main context */
   _clutter_clear_events_queue ();
 
-  g_clear_pointer (&backend->dummy_onscreen, cogl_object_unref);
+  g_clear_object (&backend->dummy_onscreen);
   if (backend->stage_window)
     {
       g_object_remove_weak_pointer (G_OBJECT (backend->stage_window),
diff --git a/clutter/clutter/clutter-offscreen-effect.c b/clutter/clutter/clutter-offscreen-effect.c
index 2dae9039ae780821d10d2d48f49eb7ca3634c9f3..cfb0ddc95573c4f04a91ad89929e7fbb5abcfa12 100644
--- a/clutter/clutter/clutter-offscreen-effect.c
+++ b/clutter/clutter/clutter-offscreen-effect.c
@@ -80,7 +80,7 @@
 
 struct _ClutterOffscreenEffectPrivate
 {
-  CoglHandle offscreen;
+  CoglOffscreen *offscreen;
   CoglPipeline *pipeline;
   CoglHandle texture;
 
@@ -118,7 +118,7 @@ clutter_offscreen_effect_set_actor (ClutterActorMeta *meta,
   meta_class->set_actor (meta, actor);
 
   /* clear out the previous state */
-  g_clear_pointer (&priv->offscreen, cogl_object_unref);
+  g_clear_object (&priv->offscreen);
 
   /* we keep a back pointer here, to avoid going through the ActorMeta */
   priv->actor = clutter_actor_meta_get_actor (meta);
@@ -161,7 +161,7 @@ ensure_pipeline_filter_for_scale (ClutterOffscreenEffect *self,
 static void
 video_memory_purged (ClutterOffscreenEffect *self)
 {
-  g_clear_pointer (&self->priv->offscreen, cogl_object_unref);
+  g_clear_object (&self->priv->offscreen);
 }
 
 static gboolean
@@ -173,6 +173,8 @@ update_fbo (ClutterEffect *effect,
   ClutterOffscreenEffect *self = CLUTTER_OFFSCREEN_EFFECT (effect);
   ClutterOffscreenEffectPrivate *priv = self->priv;
   ClutterActor *stage_actor;
+  CoglOffscreen *offscreen;
+  g_autoptr (GError) error = NULL;
 
   stage_actor = clutter_actor_get_stage (priv->actor);
   if (stage_actor != priv->stage)
@@ -219,7 +221,7 @@ update_fbo (ClutterEffect *effect,
     }
 
   g_clear_pointer (&priv->texture, cogl_object_unref);
-  g_clear_pointer (&priv->offscreen, cogl_object_unref);
+  g_clear_object (&priv->offscreen);
 
   priv->texture =
     clutter_offscreen_effect_create_texture (self, target_width, target_height);
@@ -231,13 +233,14 @@ update_fbo (ClutterEffect *effect,
   priv->target_width = target_width;
   priv->target_height = target_height;
 
-  priv->offscreen = cogl_offscreen_new_to_texture (priv->texture);
-  if (priv->offscreen == NULL)
+  offscreen = cogl_offscreen_new_with_texture (priv->texture);
+  if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (offscreen), &error))
     {
-      g_warning ("%s: Unable to create an Offscreen buffer", G_STRLOC);
+      g_warning ("Failed to create offscreen effect framebuffer: %s",
+                 error->message);
 
-      cogl_object_unref (priv->pipeline);
-      priv->pipeline = NULL;
+      g_object_unref (offscreen);
+      cogl_clear_object (&priv->pipeline);
 
       priv->target_width = 0;
       priv->target_height = 0;
@@ -245,6 +248,8 @@ update_fbo (ClutterEffect *effect,
       return FALSE;
     }
 
+  priv->offscreen = offscreen;
+
   return TRUE;
 }
 
@@ -254,6 +259,7 @@ clutter_offscreen_effect_pre_paint (ClutterEffect       *effect,
 {
   ClutterOffscreenEffect *self = CLUTTER_OFFSCREEN_EFFECT (effect);
   ClutterOffscreenEffectPrivate *priv = self->priv;
+  CoglFramebuffer *offscreen;
   ClutterActorBox raw_box, box;
   ClutterActor *stage;
   graphene_matrix_t projection, modelview;
@@ -315,7 +321,8 @@ clutter_offscreen_effect_pre_paint (ClutterEffect       *effect,
   if (!update_fbo (effect, target_width, target_height, resource_scale))
     goto disable_effect;
 
-  clutter_paint_context_push_framebuffer (paint_context, priv->offscreen);
+  offscreen = COGL_FRAMEBUFFER (priv->offscreen);
+  clutter_paint_context_push_framebuffer (paint_context, offscreen);
 
   /* We don't want the FBO contents to be transformed. That could waste memory
    * (e.g. during zoom), or result in something that's not rectangular (clipped
@@ -325,30 +332,30 @@ clutter_offscreen_effect_pre_paint (ClutterEffect       *effect,
    * contents on screen...
    */
   clutter_actor_get_transform (priv->stage, &modelview);
-  cogl_framebuffer_set_modelview_matrix (priv->offscreen, &modelview);
+  cogl_framebuffer_set_modelview_matrix (offscreen, &modelview);
 
   /* Set up the viewport so that it has the same size as the stage (avoid
    * distortion), but translated to account for the FBO offset...
    */
-  cogl_framebuffer_set_viewport (priv->offscreen,
+  cogl_framebuffer_set_viewport (offscreen,
                                  -priv->fbo_offset_x,
                                  -priv->fbo_offset_y,
                                  stage_width,
                                  stage_height);
 
-  /* Copy the stage's projection matrix across to the framebuffer */
+  /* Copy the stage's projection matrix across to the offscreen */
   _clutter_stage_get_projection_matrix (CLUTTER_STAGE (priv->stage),
                                         &projection);
 
-  cogl_framebuffer_set_projection_matrix (priv->offscreen, &projection);
+  cogl_framebuffer_set_projection_matrix (offscreen, &projection);
 
   cogl_color_init_from_4ub (&transparent, 0, 0, 0, 0);
-  cogl_framebuffer_clear (priv->offscreen,
+  cogl_framebuffer_clear (offscreen,
                           COGL_BUFFER_BIT_COLOR |
                           COGL_BUFFER_BIT_DEPTH,
                           &transparent);
 
-  cogl_framebuffer_push_matrix (priv->offscreen);
+  cogl_framebuffer_push_matrix (offscreen);
 
   /* Override the actor's opacity to fully opaque - we paint the offscreen
    * texture with the actor's paint opacity, so we need to do this to avoid
@@ -361,7 +368,7 @@ clutter_offscreen_effect_pre_paint (ClutterEffect       *effect,
   return TRUE;
 
 disable_effect:
-  cogl_clear_object (&priv->offscreen);
+  g_clear_object (&priv->offscreen);
   return FALSE;
 }
 
@@ -468,7 +475,7 @@ clutter_offscreen_effect_paint (ClutterEffect           *effect,
   if (flags & CLUTTER_EFFECT_PAINT_BYPASS_EFFECT)
     {
       clutter_actor_continue_paint (priv->actor, paint_context);
-      cogl_clear_object (&priv->offscreen);
+      g_clear_object (&priv->offscreen);
       return;
     }
 
@@ -495,7 +502,7 @@ clutter_offscreen_effect_set_enabled (ClutterActorMeta *meta,
   ClutterOffscreenEffect *offscreen_effect = CLUTTER_OFFSCREEN_EFFECT (meta);
   ClutterOffscreenEffectPrivate *priv = offscreen_effect->priv;
 
-  g_clear_pointer (&priv->offscreen, cogl_object_unref);
+  g_clear_object (&priv->offscreen);
 
   parent_class->set_enabled (meta, is_enabled);
 }
@@ -506,7 +513,7 @@ clutter_offscreen_effect_finalize (GObject *gobject)
   ClutterOffscreenEffect *self = CLUTTER_OFFSCREEN_EFFECT (gobject);
   ClutterOffscreenEffectPrivate *priv = self->priv;
 
-  g_clear_pointer (&priv->offscreen, cogl_object_unref);
+  g_clear_object (&priv->offscreen);
   g_clear_pointer (&priv->texture, cogl_object_unref);
   g_clear_pointer (&priv->pipeline, cogl_object_unref);
 
diff --git a/clutter/clutter/clutter-paint-context.c b/clutter/clutter/clutter-paint-context.c
index 5981835068e948c0e3e0436aaf41a1299491c201..5e348581c18bc8faeeaccec0e90bd88d5bab1560 100644
--- a/clutter/clutter/clutter-paint-context.c
+++ b/clutter/clutter/clutter-paint-context.c
@@ -86,8 +86,7 @@ clutter_paint_context_ref (ClutterPaintContext *paint_context)
 static void
 clutter_paint_context_dispose (ClutterPaintContext *paint_context)
 {
-  g_list_free_full (paint_context->framebuffers,
-                    cogl_object_unref);
+  g_list_free_full (paint_context->framebuffers, g_object_unref);
   paint_context->framebuffers = NULL;
   g_clear_pointer (&paint_context->redraw_clip, cairo_region_destroy);
 }
@@ -114,7 +113,7 @@ clutter_paint_context_push_framebuffer (ClutterPaintContext *paint_context,
                                         CoglFramebuffer     *framebuffer)
 {
   paint_context->framebuffers = g_list_prepend (paint_context->framebuffers,
-                                                cogl_object_ref (framebuffer));
+                                                g_object_ref (framebuffer));
 }
 
 void
@@ -122,7 +121,7 @@ clutter_paint_context_pop_framebuffer (ClutterPaintContext *paint_context)
 {
   g_return_if_fail (paint_context->framebuffers);
 
-  cogl_object_unref (paint_context->framebuffers->data);
+  g_object_unref (paint_context->framebuffers->data);
   paint_context->framebuffers =
     g_list_delete_link (paint_context->framebuffers,
                         paint_context->framebuffers);
diff --git a/clutter/clutter/clutter-paint-nodes.c b/clutter/clutter/clutter-paint-nodes.c
index de2f3fdcc6e39ac596fe6fc9e07776f45910a1fc..41e789a0721e90837b77122fe32ccb2857d915db 100644
--- a/clutter/clutter/clutter-paint-nodes.c
+++ b/clutter/clutter/clutter-paint-nodes.c
@@ -130,7 +130,7 @@ clutter_root_node_finalize (ClutterPaintNode *node)
 {
   ClutterRootNode *rnode = (ClutterRootNode *) node;
 
-  cogl_object_unref (rnode->framebuffer);
+  g_object_unref (rnode->framebuffer);
 
   CLUTTER_PAINT_NODE_CLASS (clutter_root_node_parent_class)->finalize (node);
 }
@@ -177,7 +177,7 @@ clutter_root_node_new (CoglFramebuffer    *framebuffer,
                             clear_color->alpha);
   cogl_color_premultiply (&res->clear_color);
 
-  res->framebuffer = cogl_object_ref (framebuffer);
+  res->framebuffer = g_object_ref (framebuffer);
   res->clear_flags = clear_flags;
 
   return (ClutterPaintNode *) res;
@@ -326,7 +326,7 @@ clutter_dummy_node_finalize (ClutterPaintNode *node)
 {
   ClutterDummyNode *dnode = (ClutterDummyNode *) node;
 
-  cogl_clear_object (&dnode->framebuffer);
+  g_clear_object (&dnode->framebuffer);
 
   CLUTTER_PAINT_NODE_CLASS (clutter_dummy_node_parent_class)->finalize (node);
 }
@@ -358,7 +358,7 @@ _clutter_dummy_node_new (ClutterActor    *actor,
 
   dnode = (ClutterDummyNode *) res;
   dnode->actor = actor;
-  dnode->framebuffer = cogl_object_ref (framebuffer);
+  dnode->framebuffer = g_object_ref (framebuffer);
 
   return res;
 }
@@ -1361,8 +1361,7 @@ clutter_layer_node_finalize (ClutterPaintNode *node)
   if (lnode->pipeline != NULL)
     cogl_object_unref (lnode->pipeline);
 
-  if (lnode->offscreen != NULL)
-    cogl_object_unref (lnode->offscreen);
+  g_clear_object (&lnode->offscreen);
 
   CLUTTER_PAINT_NODE_CLASS (clutter_layer_node_parent_class)->finalize (node);
 }
@@ -1415,6 +1414,8 @@ clutter_layer_node_new (const graphene_matrix_t *projection,
   CoglTexture2D *tex_2d;
   CoglTexture *texture;
   CoglColor color;
+  CoglOffscreen *offscreen;
+  g_autoptr (GError) error = NULL;
 
   res = _clutter_paint_node_create (CLUTTER_TYPE_LAYER_NODE);
 
@@ -1433,13 +1434,17 @@ clutter_layer_node_new (const graphene_matrix_t *projection,
   texture = COGL_TEXTURE (tex_2d);
   cogl_texture_set_premultiplied (texture, TRUE);
 
-  res->offscreen = COGL_FRAMEBUFFER (cogl_offscreen_new_to_texture (texture));
-  if (res->offscreen == NULL)
+  offscreen = cogl_offscreen_new_with_texture (texture);
+  if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (offscreen), &error))
     {
-      g_critical ("%s: Unable to create an offscreen buffer", G_STRLOC);
+      g_warning ("Unable to create an allocate paint node offscreen: %s",
+                 error->message);
+      g_object_unref (offscreen);
       goto out;
     }
 
+  res->offscreen = COGL_FRAMEBUFFER (offscreen);
+
   cogl_color_init_from_4ub (&color, opacity, opacity, opacity, opacity);
 
   /* the pipeline used to paint the texture; we use nearest
diff --git a/clutter/clutter/clutter-pick-context.c b/clutter/clutter/clutter-pick-context.c
index a02d6e795217fea8b2b69da8fac7790be39acb1f..5ecb907b09e1ddad5811ea3422bc7dacab823b6c 100644
--- a/clutter/clutter/clutter-pick-context.c
+++ b/clutter/clutter/clutter-pick-context.c
@@ -38,7 +38,7 @@ clutter_pick_context_new_for_view (ClutterStageView *view)
   pick_context = g_new0 (ClutterPickContext, 1);
   g_ref_count_init (&pick_context->ref_count);
   pick_context->framebuffer =
-    cogl_object_ref (clutter_stage_view_get_framebuffer (view));
+    g_object_ref (clutter_stage_view_get_framebuffer (view));
 
   return pick_context;
 }
@@ -53,7 +53,7 @@ clutter_pick_context_ref (ClutterPickContext *pick_context)
 static void
 clutter_pick_context_dispose (ClutterPickContext *pick_context)
 {
-  g_clear_pointer (&pick_context->framebuffer, cogl_object_unref);
+  g_clear_object (&pick_context->framebuffer);
 }
 
 void
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index 6e505bd07e7820e89890a3779b5e68aef6e84552..8123eb7db507808851722c3d10f5c50a122cdcce 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -321,7 +321,7 @@ init_dma_buf_shadowfbs (ClutterStageView  *view,
       return FALSE;
     }
 
-  if (!cogl_is_onscreen (priv->framebuffer))
+  if (!COGL_IS_ONSCREEN (priv->framebuffer))
     {
       g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
                    "Tried to use shadow buffer without onscreen");
@@ -348,7 +348,7 @@ init_dma_buf_shadowfbs (ClutterStageView  *view,
 
   initial_shadowfb =
     cogl_dma_buf_handle_get_framebuffer (priv->shadow.dma_buf.handles[0]);
-  priv->shadow.framebuffer = cogl_object_ref (initial_shadowfb);
+  priv->shadow.framebuffer = COGL_OFFSCREEN (g_object_ref (initial_shadowfb));
 
   return TRUE;
 }
@@ -376,7 +376,7 @@ create_offscreen_framebuffer (CoglContext  *context,
   cogl_object_unref (texture);
   if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (framebuffer), error))
     {
-      cogl_object_unref (framebuffer);
+      g_object_unref (framebuffer);
       return FALSE;
     }
 
@@ -631,8 +631,8 @@ swap_dma_buf_framebuffer (ClutterStageView *view)
   next_dma_buf_handle = priv->shadow.dma_buf.handles[next_idx];
   next_framebuffer =
     cogl_dma_buf_handle_get_framebuffer (next_dma_buf_handle);
-  cogl_clear_object (&priv->shadow.framebuffer);
-  priv->shadow.framebuffer = cogl_object_ref (next_framebuffer);
+  g_clear_object (&priv->shadow.framebuffer);
+  priv->shadow.framebuffer = COGL_OFFSCREEN (g_object_ref (next_framebuffer));
 }
 
 static void
@@ -1165,7 +1165,7 @@ clutter_stage_view_set_framebuffer (ClutterStageView *view,
   g_warn_if_fail (!priv->framebuffer);
   if (framebuffer)
     {
-      priv->framebuffer = cogl_object_ref (framebuffer);
+      priv->framebuffer = g_object_ref (framebuffer);
       sanity_check_framebuffer (view);
     }
 }
@@ -1192,10 +1192,10 @@ clutter_stage_view_get_property (GObject    *object,
       g_value_set_boxed (value, &priv->layout);
       break;
     case PROP_FRAMEBUFFER:
-      g_value_set_boxed (value, priv->framebuffer);
+      g_value_set_object (value, priv->framebuffer);
       break;
     case PROP_OFFSCREEN:
-      g_value_set_boxed (value, priv->offscreen);
+      g_value_set_object (value, priv->offscreen);
       break;
     case PROP_USE_SHADOWFB:
       g_value_set_boolean (value, priv->use_shadowfb);
@@ -1235,10 +1235,10 @@ clutter_stage_view_set_property (GObject      *object,
       priv->layout = *layout;
       break;
     case PROP_FRAMEBUFFER:
-      clutter_stage_view_set_framebuffer (view, g_value_get_boxed (value));
+      clutter_stage_view_set_framebuffer (view, g_value_get_object (value));
       break;
     case PROP_OFFSCREEN:
-      priv->offscreen = g_value_dup_boxed (value);
+      priv->offscreen = g_value_dup_object (value);
       break;
     case PROP_USE_SHADOWFB:
       priv->use_shadowfb = g_value_get_boolean (value);
@@ -1281,7 +1281,7 @@ clutter_stage_view_dispose (GObject *object)
 
   g_clear_pointer (&priv->name, g_free);
 
-  g_clear_pointer (&priv->shadow.framebuffer, cogl_object_unref);
+  g_clear_object (&priv->shadow.framebuffer);
   for (i = 0; i < G_N_ELEMENTS (priv->shadow.dma_buf.handles); i++)
     {
       g_clear_pointer (&priv->shadow.dma_buf.handles[i],
@@ -1290,7 +1290,7 @@ clutter_stage_view_dispose (GObject *object)
   g_clear_pointer (&priv->shadow.dma_buf.damage_history,
                    clutter_damage_history_free);
 
-  g_clear_pointer (&priv->offscreen, cogl_object_unref);
+  g_clear_object (&priv->offscreen);
   g_clear_pointer (&priv->offscreen_pipeline, cogl_object_unref);
   g_clear_pointer (&priv->redraw_clip, cairo_region_destroy);
   g_clear_pointer (&priv->frame_clock, clutter_frame_clock_destroy);
@@ -1305,7 +1305,7 @@ clutter_stage_view_finalize (GObject *object)
   ClutterStageViewPrivate *priv =
     clutter_stage_view_get_instance_private (view);
 
-  g_clear_pointer (&priv->framebuffer, cogl_object_unref);
+  g_clear_object (&priv->framebuffer);
 
   G_OBJECT_CLASS (clutter_stage_view_parent_class)->dispose (object);
 }
@@ -1364,22 +1364,22 @@ clutter_stage_view_class_init (ClutterStageViewClass *klass)
                         G_PARAM_STATIC_STRINGS);
 
   obj_props[PROP_FRAMEBUFFER] =
-    g_param_spec_boxed ("framebuffer",
-                        "View framebuffer",
-                        "The front buffer of the view",
-                        COGL_TYPE_HANDLE,
-                        G_PARAM_READWRITE |
-                        G_PARAM_CONSTRUCT |
-                        G_PARAM_STATIC_STRINGS);
+    g_param_spec_object ("framebuffer",
+                         "View framebuffer",
+                         "The front buffer of the view",
+                         COGL_TYPE_FRAMEBUFFER,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT |
+                         G_PARAM_STATIC_STRINGS);
 
   obj_props[PROP_OFFSCREEN] =
-    g_param_spec_boxed ("offscreen",
-                        "Offscreen buffer",
-                        "Framebuffer used as intermediate buffer",
-                        COGL_TYPE_HANDLE,
-                        G_PARAM_READWRITE |
-                        G_PARAM_CONSTRUCT_ONLY |
-                        G_PARAM_STATIC_STRINGS);
+    g_param_spec_object ("offscreen",
+                         "Offscreen buffer",
+                         "Framebuffer used as intermediate buffer",
+                         COGL_TYPE_OFFSCREEN,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
 
   obj_props[PROP_USE_SHADOWFB] =
     g_param_spec_boolean ("use-shadowfb",
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index c9680388b6fdca3de3dafeac84abaf71a8830fe8..26cc9e0e581175f7c20791f538496f0adca56570 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -3731,7 +3731,7 @@ clutter_stage_paint_to_buffer (ClutterStage                 *stage,
                                             bitmap);
 
   cogl_object_unref (bitmap);
-  cogl_object_unref (framebuffer);
+  g_object_unref (framebuffer);
 
   return TRUE;
 }
diff --git a/clutter/clutter/cogl/clutter-stage-cogl.c b/clutter/clutter/cogl/clutter-stage-cogl.c
index 6483973e40fe3ad0caf54df5952763a9b2a4dc0a..794960e82ae1f80bd234dff1b5ca038e78e2cb1d 100644
--- a/clutter/clutter/cogl/clutter-stage-cogl.c
+++ b/clutter/clutter/cogl/clutter-stage-cogl.c
@@ -257,7 +257,7 @@ swap_framebuffer (ClutterStageWindow *stage_window,
 
   clutter_stage_view_before_swap_buffer (view, swap_region);
 
-  if (cogl_is_onscreen (framebuffer))
+  if (COGL_IS_ONSCREEN (framebuffer))
     {
       CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
       int *damage, n_rects, i;
@@ -481,10 +481,10 @@ clutter_stage_cogl_redraw_view_primary (ClutterStageCogl *stage_cogl,
   fb_height = cogl_framebuffer_get_height (fb);
 
   can_blit_sub_buffer =
-    cogl_is_onscreen (onscreen) &&
+    COGL_IS_ONSCREEN (onscreen) &&
     cogl_clutter_winsys_has_feature (COGL_WINSYS_FEATURE_SWAP_REGION);
 
-  has_buffer_age = cogl_is_onscreen (onscreen) && is_buffer_age_enabled ();
+  has_buffer_age = COGL_IS_ONSCREEN (onscreen) && is_buffer_age_enabled ();
 
   redraw_clip = clutter_stage_view_take_redraw_clip (view);
   if (G_UNLIKELY (clutter_paint_debug_flags & CLUTTER_DEBUG_PAINT_DAMAGE_REGION))
@@ -661,7 +661,7 @@ clutter_stage_cogl_scanout_view (ClutterStageCogl  *stage_cogl,
   CoglOnscreen *onscreen;
   CoglFrameInfo *frame_info;
 
-  g_assert (cogl_is_onscreen (framebuffer));
+  g_assert (COGL_IS_ONSCREEN (framebuffer));
 
   onscreen = COGL_ONSCREEN (framebuffer);
 
@@ -807,7 +807,7 @@ clutter_stage_view_cogl_constructed (GObject *object)
   CoglFramebuffer *framebuffer;
 
   framebuffer = clutter_stage_view_get_onscreen (view);
-  if (framebuffer && cogl_is_onscreen (framebuffer))
+  if (framebuffer && COGL_IS_ONSCREEN (framebuffer))
     {
       view_priv->frame_cb_closure =
         cogl_onscreen_add_frame_callback (COGL_ONSCREEN (framebuffer),
diff --git a/cogl/cogl-pango/cogl-pango-display-list.c b/cogl/cogl-pango/cogl-pango-display-list.c
index caf202d06e48a18273557259d8683a9a86fefae1..2e5b6414fc9fdaae76a428d0832306f6968f4225 100644
--- a/cogl/cogl-pango/cogl-pango-display-list.c
+++ b/cogl/cogl-pango/cogl-pango-display-list.c
@@ -259,7 +259,7 @@ emit_vertex_buffer_geometry (CoglFramebuffer *fb,
                              CoglPipeline *pipeline,
                              CoglPangoDisplayListNode *node)
 {
-  CoglContext *ctx = fb->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (fb);
 
   /* It's expensive to go through the Cogl journal for large runs
    * of text in part because the journal transforms the quads in software
diff --git a/cogl/cogl/cogl-attribute.c b/cogl/cogl/cogl-attribute.c
index f42bc9f9b6686aaf3aeca3d61cd72f3adeafbd28..a31906739a3c714e394a432b5b3370ca6e92130e 100644
--- a/cogl/cogl/cogl-attribute.c
+++ b/cogl/cogl/cogl-attribute.c
@@ -587,12 +587,12 @@ _cogl_flush_attributes_state (CoglFramebuffer *framebuffer,
                               CoglAttribute **attributes,
                               int n_attributes)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglFlushLayerState layers_state;
   CoglPipeline *copy = NULL;
 
   if (!(flags & COGL_DRAW_SKIP_JOURNAL_FLUSH))
-    _cogl_journal_flush (framebuffer->journal);
+    _cogl_framebuffer_flush_journal (framebuffer);
 
   layers_state.unit = 0;
   layers_state.options.flags = 0;
diff --git a/cogl/cogl/cogl-blit.c b/cogl/cogl/cogl-blit.c
index 3ddc3eba237b97fc48e5e9a8695aa1e908b49294..57922f736f873e83dfbb3b465a3fe8ffb73108b2 100644
--- a/cogl/cogl/cogl-blit.c
+++ b/cogl/cogl/cogl-blit.c
@@ -62,7 +62,7 @@ _cogl_blit_texture_render_begin (CoglBlitData *data)
   if (!cogl_framebuffer_allocate (fb, &ignore_error))
     {
       g_error_free (ignore_error);
-      cogl_object_unref (fb);
+      g_object_unref (fb);
       return FALSE;
     }
 
@@ -142,7 +142,7 @@ _cogl_blit_texture_render_end (CoglBlitData *data)
   cogl_pipeline_set_layer_texture (ctx->blit_texture_pipeline, 0,
                                    data->dst_tex);
 
-  cogl_object_unref (data->dest_fb);
+  g_object_unref (data->dest_fb);
 }
 
 static gboolean
@@ -190,10 +190,8 @@ _cogl_blit_framebuffer_begin (CoglBlitData *data)
 
 error:
 
-  if (dst_offscreen)
-    cogl_object_unref (dst_offscreen);
-  if (src_offscreen)
-    cogl_object_unref (src_offscreen);
+  g_clear_object (&dst_offscreen);
+  g_clear_object (&src_offscreen);
 
   return FALSE;
 }
@@ -218,8 +216,8 @@ _cogl_blit_framebuffer_blit (CoglBlitData *data,
 static void
 _cogl_blit_framebuffer_end (CoglBlitData *data)
 {
-  cogl_object_unref (data->src_fb);
-  cogl_object_unref (data->dest_fb);
+  g_object_unref (data->src_fb);
+  g_object_unref (data->dest_fb);
 }
 
 static gboolean
@@ -240,7 +238,7 @@ _cogl_blit_copy_tex_sub_image_begin (CoglBlitData *data)
   if (!cogl_framebuffer_allocate (fb, &ignore_error))
     {
       g_error_free (ignore_error);
-      cogl_object_unref (fb);
+      g_object_unref (fb);
       return FALSE;
     }
 
@@ -269,7 +267,7 @@ _cogl_blit_copy_tex_sub_image_blit (CoglBlitData *data,
 static void
 _cogl_blit_copy_tex_sub_image_end (CoglBlitData *data)
 {
-  cogl_object_unref (data->src_fb);
+  g_object_unref (data->src_fb);
 }
 
 static gboolean
diff --git a/cogl/cogl/cogl-clip-stack.c b/cogl/cogl/cogl-clip-stack.c
index e1581872132271f73059d44ebbd5d190b200797a..66adfae364054bf9ea6958a66adb5a796164f73a 100644
--- a/cogl/cogl/cogl-clip-stack.c
+++ b/cogl/cogl/cogl-clip-stack.c
@@ -428,7 +428,7 @@ void
 _cogl_clip_stack_flush (CoglClipStack *stack,
                         CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
   ctx->driver_vtable->clip_stack_flush (stack, framebuffer);
 }
diff --git a/cogl/cogl/cogl-dma-buf-handle.c b/cogl/cogl/cogl-dma-buf-handle.c
index 9724ac9c95bab6768895da050489dada60592a3e..5b18f103045a2cccf1b178c37ce96a1d7244787b 100644
--- a/cogl/cogl/cogl-dma-buf-handle.c
+++ b/cogl/cogl/cogl-dma-buf-handle.c
@@ -71,7 +71,7 @@ cogl_dma_buf_handle_new (CoglFramebuffer *framebuffer,
   g_assert (dmabuf_fd != -1);
 
   dmabuf_handle = g_new0 (CoglDmaBufHandle, 1);
-  dmabuf_handle->framebuffer = cogl_object_ref (framebuffer);
+  dmabuf_handle->framebuffer = g_object_ref (framebuffer);
   dmabuf_handle->dmabuf_fd = dmabuf_fd;
   dmabuf_handle->user_data = user_data;
   dmabuf_handle->destroy_func = destroy_func;
@@ -90,7 +90,7 @@ cogl_dma_buf_handle_free (CoglDmaBufHandle *dmabuf_handle)
 {
   g_return_if_fail (dmabuf_handle != NULL);
 
-  g_clear_pointer (&dmabuf_handle->framebuffer, cogl_object_unref);
+  g_clear_object (&dmabuf_handle->framebuffer);
 
   if (dmabuf_handle->destroy_func)
     g_clear_pointer (&dmabuf_handle->user_data, dmabuf_handle->destroy_func);
diff --git a/cogl/cogl/cogl-fence.c b/cogl/cogl/cogl-fence.c
index eb40978b120bb34728f1e9f63eecd6d608f21357..ff1a7dfcace5402d789e144cdc011a0fce27f1f3 100644
--- a/cogl/cogl/cogl-fence.c
+++ b/cogl/cogl/cogl-fence.c
@@ -45,7 +45,7 @@ cogl_fence_closure_get_user_data (CoglFenceClosure *closure)
 static void
 _cogl_fence_check (CoglFenceClosure *fence)
 {
-  CoglContext *context = fence->framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (fence->framebuffer);
 
   if (fence->type == FENCE_TYPE_WINSYS)
     {
@@ -95,10 +95,11 @@ _cogl_fence_poll_prepare (void *source)
    * hit and the main loop might block forever */
   for (l = context->framebuffers; l; l = l->next)
     {
-      CoglFramebuffer *fb = l->data;
+      CoglFramebuffer *framebuffer = l->data;
+      CoglJournal *journal = cogl_framebuffer_get_journal (framebuffer);
 
-      if (!_cogl_list_empty (&fb->journal->pending_fences))
-        _cogl_framebuffer_flush_journal (fb);
+      if (!_cogl_list_empty (&journal->pending_fences))
+        _cogl_framebuffer_flush_journal (framebuffer);
     }
 
   if (!_cogl_list_empty (&context->fences))
@@ -110,7 +111,7 @@ _cogl_fence_poll_prepare (void *source)
 void
 _cogl_fence_submit (CoglFenceClosure *fence)
 {
-  CoglContext *context = fence->framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (fence->framebuffer);
   const CoglWinsysVtable *winsys = _cogl_context_get_winsys (context);
 
   fence->type = FENCE_TYPE_ERROR;
@@ -156,8 +157,8 @@ cogl_framebuffer_add_fence_callback (CoglFramebuffer *framebuffer,
                                      CoglFenceCallback callback,
                                      void *user_data)
 {
-  CoglContext *context = framebuffer->context;
-  CoglJournal *journal = framebuffer->journal;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
+  CoglJournal *journal = cogl_framebuffer_get_journal (framebuffer);
   CoglFenceClosure *fence;
 
   if (!COGL_FLAGS_GET (context->features, COGL_FEATURE_ID_FENCE))
@@ -184,7 +185,7 @@ void
 cogl_framebuffer_cancel_fence_callback (CoglFramebuffer *framebuffer,
                                         CoglFenceClosure *fence)
 {
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
 
   if (fence->type == FENCE_TYPE_PENDING)
     {
@@ -214,8 +215,8 @@ cogl_framebuffer_cancel_fence_callback (CoglFramebuffer *framebuffer,
 void
 _cogl_fence_cancel_fences_for_framebuffer (CoglFramebuffer *framebuffer)
 {
-  CoglJournal *journal = framebuffer->journal;
-  CoglContext *context = framebuffer->context;
+  CoglJournal *journal = cogl_framebuffer_get_journal (framebuffer);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglFenceClosure *fence, *tmp;
 
   while (!_cogl_list_empty (&journal->pending_fences))
diff --git a/cogl/cogl/cogl-framebuffer-private.h b/cogl/cogl/cogl-framebuffer-private.h
index 38e58fd69c4047546e7002e5a2aa5d121dcbd805..2f0a05b43af5120ca7771dd0e4df835ec45adc73 100644
--- a/cogl/cogl/cogl-framebuffer-private.h
+++ b/cogl/cogl/cogl-framebuffer-private.h
@@ -41,11 +41,6 @@
 #include "cogl-gl-header.h"
 #include "cogl-clip-stack.h"
 
-typedef enum _CoglFramebufferType {
-  COGL_FRAMEBUFFER_TYPE_ONSCREEN,
-  COGL_FRAMEBUFFER_TYPE_OFFSCREEN
-} CoglFramebufferType;
-
 typedef struct
 {
   CoglSwapChain *swap_chain;
@@ -115,74 +110,6 @@ typedef struct
   int stencil;
 } CoglFramebufferBits;
 
-struct _CoglFramebuffer
-{
-  CoglObject          _parent;
-  CoglContext        *context;
-  CoglFramebufferType  type;
-
-  /* The user configuration before allocation... */
-  CoglFramebufferConfig config;
-
-  int                 width;
-  int                 height;
-  /* Format of the pixels in the framebuffer (including the expected
-     premult state) */
-  CoglPixelFormat     internal_format;
-  gboolean            allocated;
-
-  CoglMatrixStack    *modelview_stack;
-  CoglMatrixStack    *projection_stack;
-  float               viewport_x;
-  float               viewport_y;
-  float               viewport_width;
-  float               viewport_height;
-  int                 viewport_age;
-  int                 viewport_age_for_scissor_workaround;
-
-  CoglClipStack      *clip_stack;
-
-  gboolean            dither_enabled;
-  gboolean            depth_writing_enabled;
-  CoglStereoMode      stereo_mode;
-
-  /* We journal the textured rectangles we want to submit to OpenGL so
-   * we have an opportunity to batch them together into less draw
-   * calls. */
-  CoglJournal        *journal;
-
-  /* The scene of a given framebuffer may depend on images in other
-   * framebuffers... */
-  GList              *deps;
-
-  /* As part of an optimization for reading-back single pixels from a
-   * framebuffer in some simple cases where the geometry is still
-   * available in the journal we need to track the bounds of the last
-   * region cleared, its color and we need to track when something
-   * does in fact draw to that region so it is no longer clear.
-   */
-  float               clear_color_red;
-  float               clear_color_green;
-  float               clear_color_blue;
-  float               clear_color_alpha;
-  int                 clear_clip_x0;
-  int                 clear_clip_y0;
-  int                 clear_clip_x1;
-  int                 clear_clip_y1;
-  gboolean            clear_clip_dirty;
-
-  /* driver specific */
-  gboolean            dirty_bitmasks;
-  CoglFramebufferBits bits;
-
-  int                 samples_per_pixel;
-
-  /* Whether the depth buffer was enabled for this framebuffer,
-   * usually means it needs to be cleared before being reused next.
-   */
-  gboolean            depth_buffer_clear_needed;
-};
-
 typedef enum
 {
   COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH_STENCIL    = 1L<<0,
@@ -199,12 +126,12 @@ typedef struct _CoglGLFramebuffer
 
 struct _CoglOffscreen
 {
-  CoglFramebuffer  _parent;
+  CoglFramebuffer parent;
 
   CoglGLFramebuffer gl_framebuffer;
 
-  CoglTexture    *texture;
-  int             texture_level;
+  CoglTexture *texture;
+  int texture_level;
 
   CoglTexture *depth_texture;
 
@@ -216,12 +143,24 @@ struct _CoglOffscreen
   CoglOffscreenFlags create_flags;
 };
 
+gboolean
+cogl_framebuffer_is_allocated (CoglFramebuffer *framebuffer);
+
+void
+cogl_framebuffer_init_config (CoglFramebuffer             *framebuffer,
+                              const CoglFramebufferConfig *config);
+
+const CoglFramebufferConfig *
+cogl_framebuffer_get_config (CoglFramebuffer *framebuffer);
+
+void
+cogl_framebuffer_update_samples_per_pixel (CoglFramebuffer *framebuffer,
+                                           int              samples_per_pixel);
+
 void
-_cogl_framebuffer_init (CoglFramebuffer *framebuffer,
-                        CoglContext *ctx,
-                        CoglFramebufferType type,
-                        int width,
-                        int height);
+cogl_framebuffer_update_size (CoglFramebuffer *framebuffer,
+                              int              width,
+                              int              height);
 
 /* XXX: For a public api we might instead want a way to explicitly
  * set the _premult status of a framebuffer or what components we
@@ -239,6 +178,9 @@ void
 _cogl_framebuffer_set_internal_format (CoglFramebuffer *framebuffer,
                                        CoglPixelFormat internal_format);
 
+CoglPixelFormat
+cogl_framebuffer_get_internal_format (CoglFramebuffer *framebuffer);
+
 void _cogl_framebuffer_free (CoglFramebuffer *framebuffer);
 
 const CoglWinsysVtable *
@@ -255,6 +197,9 @@ _cogl_framebuffer_clear_without_flush4f (CoglFramebuffer *framebuffer,
 void
 _cogl_framebuffer_mark_clear_clip_dirty (CoglFramebuffer *framebuffer);
 
+void
+cogl_framebuffer_set_depth_buffer_clear_needed (CoglFramebuffer *framebuffer);
+
 /*
  * _cogl_framebuffer_get_clip_stack:
  * @framebuffer: A #CoglFramebuffer
@@ -353,6 +298,13 @@ void
 cogl_framebuffer_set_viewport4fv (CoglFramebuffer *framebuffer,
                                   float *viewport);
 
+void
+cogl_framebuffer_get_viewport4f (CoglFramebuffer *framebuffer,
+                                 float           *viewport_x,
+                                 float           *viewport_y,
+                                 float           *viewport_width,
+                                 float           *viewport_height);
+
 unsigned long
 _cogl_framebuffer_compare (CoglFramebuffer *a,
                            CoglFramebuffer *b,
@@ -396,4 +348,15 @@ _cogl_framebuffer_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
 COGL_EXPORT int
 _cogl_framebuffer_get_stencil_bits (CoglFramebuffer *framebuffer);
 
+CoglJournal *
+cogl_framebuffer_get_journal (CoglFramebuffer *framebuffer);
+
+gpointer
+cogl_framebuffer_get_driver_private (CoglFramebuffer *framebuffer);
+
+void
+cogl_framebuffer_set_driver_private (CoglFramebuffer *framebuffer,
+                                     gpointer         driver_private,
+                                     GDestroyNotify   desrtoy_notify);
+
 #endif /* __COGL_FRAMEBUFFER_PRIVATE_H */
diff --git a/cogl/cogl/cogl-framebuffer.c b/cogl/cogl/cogl-framebuffer.c
index b4991900ba6b490540a96696f22011ad56f4b533..1073685b62214e7ddd795d8d052160b8d728d1df 100644
--- a/cogl/cogl/cogl-framebuffer.c
+++ b/cogl/cogl/cogl-framebuffer.c
@@ -53,26 +53,102 @@
 #include "cogl-gtype-private.h"
 #include "winsys/cogl-winsys-private.h"
 
-extern CoglObjectClass _cogl_onscreen_class;
+enum
+{
+  PROP_0,
+
+  PROP_CONTEXT,
+  PROP_WIDTH,
+  PROP_HEIGHT,
+
+  N_PROPS
+};
+
+static GParamSpec *obj_props[N_PROPS];
+
+enum
+{
+  DESTROY,
+
+  N_SIGNALS
+};
+
+static guint signals[N_SIGNALS];
 
 #ifdef COGL_ENABLE_DEBUG
 static CoglUserDataKey wire_pipeline_key;
 #endif
 
-static void _cogl_offscreen_free (CoglOffscreen *offscreen);
+typedef struct _CoglFramebufferPrivate
+{
+  CoglContext *context;
 
-COGL_OBJECT_DEFINE_WITH_CODE_GTYPE (Offscreen, offscreen,
-                                    _cogl_offscreen_class.virt_unref =
-                                    _cogl_framebuffer_unref);
-COGL_GTYPE_DEFINE_CLASS (Offscreen, offscreen,
-                         COGL_GTYPE_IMPLEMENT_INTERFACE (framebuffer));
-COGL_GTYPE_DEFINE_INTERFACE (Framebuffer, framebuffer);
+  /* The user configuration before allocation... */
+  CoglFramebufferConfig config;
 
-/* XXX:
- * The CoglObject macros don't support any form of inheritance, so for
- * now we implement the CoglObject support for the CoglFramebuffer
- * abstract class manually.
+  int width;
+  int height;
+  /* Format of the pixels in the framebuffer (including the expected
+     premult state) */
+  CoglPixelFormat internal_format;
+  gboolean allocated;
+
+  CoglMatrixStack *modelview_stack;
+  CoglMatrixStack *projection_stack;
+  float viewport_x;
+  float viewport_y;
+  float viewport_width;
+  float viewport_height;
+  int viewport_age;
+  int viewport_age_for_scissor_workaround;
+
+  CoglClipStack *clip_stack;
+
+  gboolean dither_enabled;
+  gboolean depth_writing_enabled;
+  CoglStereoMode stereo_mode;
+
+  /* We journal the textured rectangles we want to submit to OpenGL so
+   * we have an opportunity to batch them together into less draw
+   * calls. */
+  CoglJournal *journal;
+
+  /* The scene of a given framebuffer may depend on images in other
+   * framebuffers... */
+  GList *deps;
+
+  /* As part of an optimization for reading-back single pixels from a
+   * framebuffer in some simple cases where the geometry is still
+   * available in the journal we need to track the bounds of the last
+   * region cleared, its color and we need to track when something
+   * does in fact draw to that region so it is no longer clear.
+   */
+  float clear_color_red;
+  float clear_color_green;
+  float clear_color_blue;
+  float clear_color_alpha;
+  int clear_clip_x0;
+  int clear_clip_y0;
+  int clear_clip_x1;
+  int clear_clip_y1;
+  gboolean clear_clip_dirty;
+
+  int samples_per_pixel;
+
+  /* Whether the depth buffer was enabled for this framebuffer,
+ * usually means it needs to be cleared before being reused next.
  */
+  gboolean depth_buffer_clear_needed;
+
+  gpointer driver_private;
+  GDestroyNotify driver_private_destroy;
+} CoglFramebufferPrivate;
+
+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (CoglFramebuffer, cogl_framebuffer,
+                                     G_TYPE_OBJECT)
+
+G_DEFINE_TYPE (CoglOffscreen, cogl_offscreen,
+               COGL_TYPE_FRAMEBUFFER)
 
 uint32_t
 cogl_framebuffer_error_quark (void)
@@ -83,55 +159,96 @@ cogl_framebuffer_error_quark (void)
 gboolean
 cogl_is_framebuffer (void *object)
 {
-  CoglObject *obj = object;
+  return COGL_IS_FRAMEBUFFER (object);
+}
 
-  if (obj == NULL)
-    return FALSE;
+static void
+cogl_framebuffer_get_property (GObject    *object,
+                               guint       prop_id,
+                               GValue     *value,
+                               GParamSpec *pspec)
+{
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (object);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
 
-  return (obj->klass == &_cogl_onscreen_class ||
-          obj->klass == &_cogl_offscreen_class);
+  switch (prop_id)
+    {
+    case PROP_CONTEXT:
+      g_value_set_boxed (value, priv->context);
+      break;
+    case PROP_WIDTH:
+      g_value_set_int (value, priv->width);
+      break;
+    case PROP_HEIGHT:
+      g_value_set_int (value, priv->height);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
 }
 
-void
-_cogl_framebuffer_init (CoglFramebuffer *framebuffer,
-                        CoglContext *ctx,
-                        CoglFramebufferType type,
-                        int width,
-                        int height)
+static void
+cogl_framebuffer_set_property (GObject      *object,
+                               guint         prop_id,
+                               const GValue *value,
+                               GParamSpec   *pspec)
+{
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (object);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  switch (prop_id)
+    {
+    case PROP_CONTEXT:
+      priv->context = g_value_get_boxed (value);
+      break;
+    case PROP_WIDTH:
+      priv->width = g_value_get_int (value);
+      break;
+    case PROP_HEIGHT:
+      priv->height = g_value_get_int (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+cogl_framebuffer_constructed (GObject *object)
 {
-  framebuffer->context = ctx;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (object);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
 
-  framebuffer->type = type;
-  framebuffer->width = width;
-  framebuffer->height = height;
-  framebuffer->internal_format = COGL_PIXEL_FORMAT_RGBA_8888_PRE;
-  framebuffer->viewport_x = 0;
-  framebuffer->viewport_y = 0;
-  framebuffer->viewport_width = width;
-  framebuffer->viewport_height = height;
-  framebuffer->viewport_age = 0;
-  framebuffer->viewport_age_for_scissor_workaround = -1;
-  framebuffer->dither_enabled = TRUE;
-  framebuffer->depth_writing_enabled = TRUE;
-  framebuffer->depth_buffer_clear_needed = TRUE;
+  g_assert (priv->context);
 
-  framebuffer->modelview_stack = cogl_matrix_stack_new (ctx);
-  framebuffer->projection_stack = cogl_matrix_stack_new (ctx);
+  priv->internal_format = COGL_PIXEL_FORMAT_RGBA_8888_PRE;
+  priv->viewport_x = 0;
+  priv->viewport_y = 0;
+  priv->viewport_width = priv->width;
+  priv->viewport_height = priv->height;
+  priv->viewport_age = 0;
+  priv->viewport_age_for_scissor_workaround = -1;
+  priv->dither_enabled = TRUE;
+  priv->depth_writing_enabled = TRUE;
+  priv->depth_buffer_clear_needed = TRUE;
 
-  framebuffer->dirty_bitmasks = TRUE;
+  priv->modelview_stack = cogl_matrix_stack_new (priv->context);
+  priv->projection_stack = cogl_matrix_stack_new (priv->context);
 
-  framebuffer->samples_per_pixel = 0;
+  priv->samples_per_pixel = 0;
 
-  framebuffer->clip_stack = NULL;
+  priv->clip_stack = NULL;
 
-  framebuffer->journal = _cogl_journal_new (framebuffer);
+  priv->journal = _cogl_journal_new (framebuffer);
 
   /* Ensure we know the framebuffer->clear_color* members can't be
    * referenced for our fast-path read-pixel optimization (see
    * _cogl_journal_try_read_pixel()) until some region of the
    * framebuffer is initialized.
    */
-  framebuffer->clear_clip_dirty = TRUE;
+  priv->clear_clip_dirty = TRUE;
 
   /* XXX: We have to maintain a central list of all framebuffers
    * because at times we need to be able to flush all known journals.
@@ -159,32 +276,68 @@ _cogl_framebuffer_init (CoglFramebuffer *framebuffer,
    * we don't have to worry about retaining references to OpenGL
    * texture coordinates that may later become invalid.
    */
-  ctx->framebuffers = g_list_prepend (ctx->framebuffers, framebuffer);
+  priv->context->framebuffers = g_list_prepend (priv->context->framebuffers,
+                                                framebuffer);
 }
 
 void
 _cogl_framebuffer_set_internal_format (CoglFramebuffer *framebuffer,
                                        CoglPixelFormat internal_format)
 {
-  framebuffer->internal_format = internal_format;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->internal_format = internal_format;
+}
+
+CoglPixelFormat
+cogl_framebuffer_get_internal_format (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->internal_format;
+}
+
+const CoglFramebufferConfig *
+cogl_framebuffer_get_config (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return &priv->config;
 }
 
 void
-_cogl_framebuffer_free (CoglFramebuffer *framebuffer)
+cogl_framebuffer_init_config (CoglFramebuffer             *framebuffer,
+                              const CoglFramebufferConfig *config)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
 
-  _cogl_fence_cancel_fences_for_framebuffer (framebuffer);
+  priv->config = *config;
+  cogl_object_ref (priv->config.swap_chain);
+}
 
-  _cogl_clip_stack_unref (framebuffer->clip_stack);
+static void
+cogl_framebuffer_dispose (GObject *object)
+{
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (object);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
 
-  cogl_object_unref (framebuffer->modelview_stack);
-  framebuffer->modelview_stack = NULL;
+  if (priv->journal)
+    {
+      g_signal_emit (framebuffer, signals[DESTROY], 0);
 
-  cogl_object_unref (framebuffer->projection_stack);
-  framebuffer->projection_stack = NULL;
+      _cogl_fence_cancel_fences_for_framebuffer (framebuffer);
+    }
 
-  cogl_object_unref (framebuffer->journal);
+  g_clear_pointer (&priv->clip_stack, _cogl_clip_stack_unref);
+  cogl_clear_object (&priv->modelview_stack);
+  cogl_clear_object (&priv->projection_stack);
+  cogl_clear_object (&priv->journal);
 
   ctx->framebuffers = g_list_remove (ctx->framebuffers, framebuffer);
 
@@ -192,12 +345,77 @@ _cogl_framebuffer_free (CoglFramebuffer *framebuffer)
     ctx->current_draw_buffer = NULL;
   if (ctx->current_read_buffer == framebuffer)
     ctx->current_read_buffer = NULL;
+
+  if (priv->driver_private_destroy)
+    priv->driver_private_destroy (priv->driver_private);
+  priv->driver_private = NULL;
+  priv->driver_private_destroy = NULL;
+}
+
+static void
+cogl_framebuffer_init (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->width = -1;
+  priv->height = -1;
+}
+
+static void
+cogl_framebuffer_class_init (CoglFramebufferClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = cogl_framebuffer_dispose;
+  object_class->constructed = cogl_framebuffer_constructed;
+  object_class->get_property = cogl_framebuffer_get_property;
+  object_class->set_property = cogl_framebuffer_set_property;
+
+  obj_props[PROP_CONTEXT] =
+    g_param_spec_boxed ("context",
+                        "context",
+                        "CoglContext",
+                        COGL_TYPE_HANDLE,
+                        G_PARAM_READWRITE |
+                        G_PARAM_CONSTRUCT_ONLY |
+                        G_PARAM_STATIC_STRINGS);
+  obj_props[PROP_WIDTH] =
+    g_param_spec_int ("width",
+                      "width",
+                      "framebuffer width",
+                      -1, INT_MAX, -1,
+                      G_PARAM_READWRITE |
+                      G_PARAM_CONSTRUCT |
+                      G_PARAM_STATIC_STRINGS);
+  obj_props[PROP_HEIGHT] =
+    g_param_spec_int ("height",
+                      "height",
+                      "framebuffer height",
+                      -1, INT_MAX, -1,
+                      G_PARAM_READWRITE |
+                      G_PARAM_CONSTRUCT |
+                      G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (object_class, N_PROPS, obj_props);
+
+  signals[DESTROY] =
+    g_signal_new (I_("destroy"),
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE,
+                  0);
 }
 
 const CoglWinsysVtable *
 _cogl_framebuffer_get_winsys (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->context->display->renderer->winsys_vtable;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->context->display->renderer->winsys_vtable;
 }
 
 /* This version of cogl_clear can be used internally as an alternative
@@ -212,7 +430,9 @@ _cogl_framebuffer_clear_without_flush4f (CoglFramebuffer *framebuffer,
                                          float blue,
                                          float alpha)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
 
   if (!buffers)
     {
@@ -235,7 +455,19 @@ _cogl_framebuffer_clear_without_flush4f (CoglFramebuffer *framebuffer,
 void
 _cogl_framebuffer_mark_clear_clip_dirty (CoglFramebuffer *framebuffer)
 {
-  framebuffer->clear_clip_dirty = TRUE;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->clear_clip_dirty = TRUE;
+}
+
+void
+cogl_framebuffer_set_depth_buffer_clear_needed (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->depth_buffer_clear_needed = TRUE;
 }
 
 void
@@ -246,6 +478,8 @@ cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
                           float blue,
                           float alpha)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglClipStack *clip_stack = _cogl_framebuffer_get_clip_stack (framebuffer);
   gboolean had_depth_and_color_buffer_bits;
   int scissor_x0;
@@ -257,7 +491,7 @@ cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
     (buffers & COGL_BUFFER_BIT_DEPTH) &&
     (buffers & COGL_BUFFER_BIT_COLOR);
 
-  if (!framebuffer->depth_buffer_clear_needed &&
+  if (!priv->depth_buffer_clear_needed &&
       (buffers & COGL_BUFFER_BIT_DEPTH))
     buffers &= ~(COGL_BUFFER_BIT_DEPTH);
 
@@ -303,15 +537,15 @@ cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
    * appropriate here.
    */
   if (had_depth_and_color_buffer_bits &&
-      !framebuffer->clear_clip_dirty &&
-      framebuffer->clear_color_red == red &&
-      framebuffer->clear_color_green == green &&
-      framebuffer->clear_color_blue == blue &&
-      framebuffer->clear_color_alpha == alpha &&
-      scissor_x0 == framebuffer->clear_clip_x0 &&
-      scissor_y0 == framebuffer->clear_clip_y0 &&
-      scissor_x1 == framebuffer->clear_clip_x1 &&
-      scissor_y1 == framebuffer->clear_clip_y1)
+      !priv->clear_clip_dirty &&
+      priv->clear_color_red == red &&
+      priv->clear_color_green == green &&
+      priv->clear_color_blue == blue &&
+      priv->clear_color_alpha == alpha &&
+      scissor_x0 == priv->clear_clip_x0 &&
+      scissor_y0 == priv->clear_clip_y0 &&
+      scissor_x1 == priv->clear_clip_x1 &&
+      scissor_y1 == priv->clear_clip_y1)
     {
       /* NB: We only have to consider the clip state of journal
        * entries if the current clear is clipped since otherwise we
@@ -330,17 +564,17 @@ cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
            * it's possible for some false negatives here but that will
            * just result in us falling back to a real clear.
            */
-          if (_cogl_journal_all_entries_within_bounds (framebuffer->journal,
+          if (_cogl_journal_all_entries_within_bounds (priv->journal,
                                                        scissor_x0, scissor_y0,
                                                        scissor_x1, scissor_y1))
             {
-              _cogl_journal_discard (framebuffer->journal);
+              _cogl_journal_discard (priv->journal);
               goto cleared;
             }
         }
       else
         {
-          _cogl_journal_discard (framebuffer->journal);
+          _cogl_journal_discard (priv->journal);
           goto cleared;
         }
     }
@@ -365,7 +599,7 @@ cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
   if (G_UNLIKELY (COGL_DEBUG_ENABLED (COGL_DEBUG_RECTANGLES)) &&
       buffers & COGL_BUFFER_BIT_COLOR)
     {
-      framebuffer->context->journal_rectangles_color = 1;
+      priv->context->journal_rectangles_color = 1;
     }
 
   COGL_NOTE (DRAW, "Clear end");
@@ -375,7 +609,7 @@ cleared:
   _cogl_framebuffer_mark_clear_clip_dirty (framebuffer);
 
   if (buffers & COGL_BUFFER_BIT_DEPTH)
-    framebuffer->depth_buffer_clear_needed = FALSE;
+    priv->depth_buffer_clear_needed = FALSE;
 
   if (had_depth_and_color_buffer_bits)
     {
@@ -383,19 +617,19 @@ cleared:
        * scenes where the whole frame is in the journal we need to
        * track the cleared color of the framebuffer in case the point
        * read doesn't intersect any of the journal rectangles. */
-      framebuffer->clear_clip_dirty = FALSE;
-      framebuffer->clear_color_red = red;
-      framebuffer->clear_color_green = green;
-      framebuffer->clear_color_blue = blue;
-      framebuffer->clear_color_alpha = alpha;
+      priv->clear_clip_dirty = FALSE;
+      priv->clear_color_red = red;
+      priv->clear_color_green = green;
+      priv->clear_color_blue = blue;
+      priv->clear_color_alpha = alpha;
 
       /* NB: A clear may be scissored so we need to track the extents
        * that the clear is applicable too... */
       _cogl_clip_stack_get_bounds (clip_stack,
-                                   &framebuffer->clear_clip_x0,
-                                   &framebuffer->clear_clip_y0,
-                                   &framebuffer->clear_clip_x1,
-                                   &framebuffer->clear_clip_y1);
+                                   &priv->clear_clip_x0,
+                                   &priv->clear_clip_y0,
+                                   &priv->clear_clip_x1,
+                                   &priv->clear_clip_y1);
     }
 }
 
@@ -425,58 +659,87 @@ cogl_framebuffer_clear (CoglFramebuffer *framebuffer,
 static void
 ensure_size_initialized (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   /* In the case of offscreen framebuffers backed by a texture then
    * until that texture has been allocated we might not know the size
    * of the framebuffer */
-  if (framebuffer->width < 0)
+  if (priv->width < 0)
     {
       /* Currently we assume the size is always initialized for
        * onscreen framebuffers. */
-      g_return_if_fail (cogl_is_offscreen (framebuffer));
+      g_return_if_fail (COGL_IS_OFFSCREEN (framebuffer));
 
       /* We also assume the size would have been initialized if the
        * framebuffer were allocated. */
-      g_return_if_fail (!framebuffer->allocated);
+      g_return_if_fail (!priv->allocated);
 
       cogl_framebuffer_allocate (framebuffer, NULL);
     }
 }
 
+void
+cogl_framebuffer_update_size (CoglFramebuffer *framebuffer,
+                              int              width,
+                              int              height)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->width = width;
+  priv->height = height;
+
+  cogl_framebuffer_set_viewport (framebuffer, 0, 0, width, height);
+}
+
 int
 cogl_framebuffer_get_width (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   ensure_size_initialized (framebuffer);
-  return framebuffer->width;
+  return priv->width;
 }
 
 int
 cogl_framebuffer_get_height (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   ensure_size_initialized (framebuffer);
-  return framebuffer->height;
+  return priv->height;
 }
 
 CoglClipStack *
 _cogl_framebuffer_get_clip_stack (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->clip_stack;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->clip_stack;
 }
 
 void
 cogl_framebuffer_set_viewport4fv (CoglFramebuffer *framebuffer,
                                   float *viewport)
 {
-  if (framebuffer->viewport_x == viewport[0] &&
-      framebuffer->viewport_y == viewport[1] &&
-      framebuffer->viewport_width == viewport[2] &&
-      framebuffer->viewport_height == viewport[3])
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  if (priv->viewport_x == viewport[0] &&
+      priv->viewport_y == viewport[1] &&
+      priv->viewport_width == viewport[2] &&
+      priv->viewport_height == viewport[3])
     return;
 
-  framebuffer->viewport_x = viewport[0];
-  framebuffer->viewport_y = viewport[1];
-  framebuffer->viewport_width = viewport[2];
-  framebuffer->viewport_height = viewport[3];
-  framebuffer->viewport_age++;
+  priv->viewport_x = viewport[0];
+  priv->viewport_y = viewport[1];
+  priv->viewport_width = viewport[2];
+  priv->viewport_height = viewport[3];
+  priv->viewport_age++;
 }
 
 void
@@ -486,77 +749,117 @@ cogl_framebuffer_set_viewport (CoglFramebuffer *framebuffer,
                                float width,
                                float height)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   g_return_if_fail (width > 0 && height > 0);
 
-  if (framebuffer->viewport_x == x &&
-      framebuffer->viewport_y == y &&
-      framebuffer->viewport_width == width &&
-      framebuffer->viewport_height == height)
+  if (priv->viewport_x == x &&
+      priv->viewport_y == y &&
+      priv->viewport_width == width &&
+      priv->viewport_height == height)
     return;
 
-  framebuffer->viewport_x = x;
-  framebuffer->viewport_y = y;
-  framebuffer->viewport_width = width;
-  framebuffer->viewport_height = height;
+  priv->viewport_x = x;
+  priv->viewport_y = y;
+  priv->viewport_width = width;
+  priv->viewport_height = height;
 }
 
 float
 cogl_framebuffer_get_viewport_x (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->viewport_x;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->viewport_x;
 }
 
 float
 cogl_framebuffer_get_viewport_y (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->viewport_y;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->viewport_y;
 }
 
 float
 cogl_framebuffer_get_viewport_width (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   ensure_size_initialized (framebuffer);
-  return framebuffer->viewport_width;
+  return priv->viewport_width;
 }
 
 float
 cogl_framebuffer_get_viewport_height (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   ensure_size_initialized (framebuffer);
-  return framebuffer->viewport_height;
+  return priv->viewport_height;
 }
 
 void
-cogl_framebuffer_get_viewport4fv (CoglFramebuffer *framebuffer,
-                                  float *viewport)
+cogl_framebuffer_get_viewport4f (CoglFramebuffer *framebuffer,
+                                 float           *viewport_x,
+                                 float           *viewport_y,
+                                 float           *viewport_width,
+                                 float           *viewport_height)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   ensure_size_initialized (framebuffer);
 
-  viewport[0] = framebuffer->viewport_x;
-  viewport[1] = framebuffer->viewport_y;
-  viewport[2] = framebuffer->viewport_width;
-  viewport[3] = framebuffer->viewport_height;
+  *viewport_x = priv->viewport_x;
+  *viewport_y = priv->viewport_y;
+  *viewport_width = priv->viewport_width;
+  *viewport_height = priv->viewport_height;
+}
+
+void
+cogl_framebuffer_get_viewport4fv (CoglFramebuffer *framebuffer,
+                                  float *viewport)
+{
+  cogl_framebuffer_get_viewport4f (framebuffer,
+                                   &viewport[0],
+                                   &viewport[1],
+                                   &viewport[2],
+                                   &viewport[3]);
 }
 
 CoglMatrixStack *
 _cogl_framebuffer_get_modelview_stack (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->modelview_stack;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->modelview_stack;
 }
 
 CoglMatrixStack *
 _cogl_framebuffer_get_projection_stack (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->projection_stack;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->projection_stack;
 }
 
 void
 _cogl_framebuffer_add_dependency (CoglFramebuffer *framebuffer,
                                   CoglFramebuffer *dependency)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   GList *l;
 
-  for (l = framebuffer->deps; l; l = l->next)
+  for (l = priv->deps; l; l = l->next)
     {
       CoglFramebuffer *existing_dep = l->data;
       if (existing_dep == dependency)
@@ -566,26 +869,28 @@ _cogl_framebuffer_add_dependency (CoglFramebuffer *framebuffer,
   /* TODO: generalize the primed-array type structure we e.g. use for
    * cogl_object_set_user_data or for pipeline children as a way to
    * avoid quite a lot of mid-scene micro allocations here... */
-  framebuffer->deps =
-    g_list_prepend (framebuffer->deps, cogl_object_ref (dependency));
+  priv->deps =
+    g_list_prepend (priv->deps, g_object_ref (dependency));
 }
 
 void
 _cogl_framebuffer_flush_journal (CoglFramebuffer *framebuffer)
 {
-  _cogl_journal_flush (framebuffer->journal);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  _cogl_journal_flush (priv->journal);
 }
 
 void
 _cogl_framebuffer_flush_dependency_journals (CoglFramebuffer *framebuffer)
 {
-  GList *l;
-  for (l = framebuffer->deps; l; l = l->next)
-    _cogl_framebuffer_flush_journal (l->data);
-  for (l = framebuffer->deps; l; l = l->next)
-    cogl_object_unref (l->data);
-  g_list_free (framebuffer->deps);
-  framebuffer->deps = NULL;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  g_list_foreach (priv->deps, (GFunc) _cogl_framebuffer_flush_journal, NULL);
+  g_list_free_full (priv->deps, g_object_unref);
+  priv->deps = NULL;
 }
 
 CoglOffscreen *
@@ -596,11 +901,12 @@ _cogl_offscreen_new_with_texture_full (CoglTexture *texture,
   CoglContext *ctx = texture->context;
   CoglOffscreen *offscreen;
   CoglFramebuffer *fb;
-  CoglOffscreen *ret;
 
   g_return_val_if_fail (cogl_is_texture (texture), NULL);
 
-  offscreen = g_new0 (CoglOffscreen, 1);
+  offscreen = g_object_new (COGL_TYPE_OFFSCREEN,
+                            "context", ctx,
+                            NULL);
   offscreen->texture = cogl_object_ref (texture);
   offscreen->texture_level = level;
   offscreen->create_flags = create_flags;
@@ -612,125 +918,127 @@ _cogl_offscreen_new_with_texture_full (CoglTexture *texture,
    * texture is being loaded from a file then the file might not
    * have been read yet. */
 
-  _cogl_framebuffer_init (fb,
-                          ctx,
-                          COGL_FRAMEBUFFER_TYPE_OFFSCREEN,
-                          -1, /* unknown width, until allocation */
-                          -1); /* unknown height until allocation */
-
-  ret = _cogl_offscreen_object_new (offscreen);
-
   _cogl_texture_associate_framebuffer (texture, fb);
 
-  return ret;
+  return offscreen;
 }
 
-/* XXX: deprecated api */
 CoglOffscreen *
-cogl_offscreen_new_to_texture (CoglTexture *texture)
+cogl_offscreen_new_with_texture (CoglTexture *texture)
+{
+  return _cogl_offscreen_new_with_texture_full (texture, 0, 0);
+}
+
+CoglTexture *
+cogl_offscreen_get_texture (CoglOffscreen *offscreen)
+{
+  return offscreen->texture;
+}
+
+static gboolean
+cogl_offscreen_allocate (CoglFramebuffer  *framebuffer,
+                         GError          **error)
 {
-  CoglOffscreen *ret = _cogl_offscreen_new_with_texture_full (texture, 0, 0);
-  GError *error = NULL;
+  CoglOffscreen *offscreen = COGL_OFFSCREEN (framebuffer);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
 
-  if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (ret), &error))
+  if (!cogl_texture_allocate (offscreen->texture, error))
+    return FALSE;
+
+  /* NB: it's only after allocating the texture that we will
+   * determine whether a texture needs slicing... */
+  if (cogl_texture_is_sliced (offscreen->texture))
     {
-      cogl_object_unref (ret);
-      g_error_free (error);
-      ret = NULL;
+      g_set_error (error, COGL_SYSTEM_ERROR, COGL_SYSTEM_ERROR_UNSUPPORTED,
+                   "Can't create offscreen framebuffer from "
+                   "sliced texture");
+      return FALSE;
     }
 
-  return ret;
+  /* Now that the texture has been allocated we can determine a
+   * size for the framebuffer... */
+  priv->width = cogl_texture_get_width (offscreen->texture);
+  priv->height = cogl_texture_get_height (offscreen->texture);
+  priv->viewport_width = priv->width;
+  priv->viewport_height = priv->height;
+
+  /* Forward the texture format as the internal format of the
+   * framebuffer */
+  priv->internal_format =
+    _cogl_texture_get_format (offscreen->texture);
+
+  if (!ctx->driver_vtable->offscreen_allocate (offscreen, error))
+    return FALSE;
+
+  return TRUE;
 }
 
-CoglOffscreen *
-cogl_offscreen_new_with_texture (CoglTexture *texture)
+static gboolean
+cogl_offscreen_is_y_flipped (CoglFramebuffer *framebuffer)
 {
-  return _cogl_offscreen_new_with_texture_full (texture, 0, 0);
+  return TRUE;
 }
 
-CoglTexture *
-cogl_offscreen_get_texture (CoglOffscreen *offscreen)
+static void
+cogl_offscreen_dispose (GObject *object)
 {
-  return offscreen->texture;
+  CoglOffscreen *offscreen = COGL_OFFSCREEN (object);
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (offscreen);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
+
+  if (offscreen->texture)
+    ctx->driver_vtable->offscreen_free (offscreen);
+
+  G_OBJECT_CLASS (cogl_offscreen_parent_class)->dispose (object);
+
+  cogl_clear_object (&offscreen->texture);
+  cogl_clear_object (&offscreen->depth_texture);
 }
 
 static void
-_cogl_offscreen_free (CoglOffscreen *offscreen)
+cogl_offscreen_init (CoglOffscreen *offscreen)
 {
-  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (offscreen);
-  CoglContext *ctx = framebuffer->context;
+}
 
-  ctx->driver_vtable->offscreen_free (offscreen);
+static void
+cogl_offscreen_class_init (CoglOffscreenClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  CoglFramebufferClass *framebuffer_class = COGL_FRAMEBUFFER_CLASS (klass);
 
-  /* Chain up to parent */
-  _cogl_framebuffer_free (framebuffer);
+  object_class->dispose = cogl_offscreen_dispose;
 
-  if (offscreen->texture != NULL)
-    cogl_object_unref (offscreen->texture);
+  framebuffer_class->allocate = cogl_offscreen_allocate;
+  framebuffer_class->is_y_flipped = cogl_offscreen_is_y_flipped;
+}
 
-  if (offscreen->depth_texture != NULL)
-    cogl_object_unref (offscreen->depth_texture);
+gboolean
+cogl_framebuffer_is_allocated (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
 
-  g_free (offscreen);
+  return priv->allocated;
 }
 
 gboolean
 cogl_framebuffer_allocate (CoglFramebuffer *framebuffer,
                            GError **error)
 {
-  CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
-  const CoglWinsysVtable *winsys = _cogl_framebuffer_get_winsys (framebuffer);
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
 
-  if (framebuffer->allocated)
+  if (priv->allocated)
     return TRUE;
 
-  if (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN)
-    {
-      if (!winsys->onscreen_init (onscreen, error))
-        return FALSE;
-
-      /* If the winsys doesn't support dirty events then we'll report
-       * one on allocation so that if the application only paints in
-       * response to dirty events then it will at least paint once to
-       * start */
-      if (!_cogl_has_private_feature (ctx, COGL_PRIVATE_FEATURE_DIRTY_EVENTS))
-        _cogl_onscreen_queue_full_dirty (onscreen);
-    }
-  else
-    {
-      CoglOffscreen *offscreen = COGL_OFFSCREEN (framebuffer);
-
-      if (!cogl_texture_allocate (offscreen->texture, error))
-        return FALSE;
-
-      /* NB: it's only after allocating the texture that we will
-       * determine whether a texture needs slicing... */
-      if (cogl_texture_is_sliced (offscreen->texture))
-        {
-          g_set_error (error, COGL_SYSTEM_ERROR, COGL_SYSTEM_ERROR_UNSUPPORTED,
-                       "Can't create offscreen framebuffer from "
-                       "sliced texture");
-          return FALSE;
-        }
-
-      /* Now that the texture has been allocated we can determine a
-       * size for the framebuffer... */
-      framebuffer->width = cogl_texture_get_width (offscreen->texture);
-      framebuffer->height = cogl_texture_get_height (offscreen->texture);
-      framebuffer->viewport_width = framebuffer->width;
-      framebuffer->viewport_height = framebuffer->height;
-
-      /* Forward the texture format as the internal format of the
-       * framebuffer */
-      framebuffer->internal_format =
-        _cogl_texture_get_format (offscreen->texture);
-
-      if (!ctx->driver_vtable->offscreen_allocate (offscreen, error))
-        return FALSE;
-    }
+  if (!COGL_FRAMEBUFFER_GET_CLASS (framebuffer)->allocate (framebuffer, error))
+    return FALSE;
 
-  framebuffer->allocated = TRUE;
+  priv->allocated = TRUE;
 
   return TRUE;
 }
@@ -739,13 +1047,16 @@ static unsigned long
 _cogl_framebuffer_compare_viewport_state (CoglFramebuffer *a,
                                           CoglFramebuffer *b)
 {
-  if (a->viewport_x != b->viewport_x ||
-      a->viewport_y != b->viewport_y ||
-      a->viewport_width != b->viewport_width ||
-      a->viewport_height != b->viewport_height ||
+  CoglFramebufferPrivate *priv_a = cogl_framebuffer_get_instance_private (a);
+  CoglFramebufferPrivate *priv_b = cogl_framebuffer_get_instance_private (b);
+
+  if (priv_a->viewport_x != priv_b->viewport_x ||
+      priv_a->viewport_y != priv_b->viewport_y ||
+      priv_a->viewport_width != priv_b->viewport_width ||
+      priv_a->viewport_height != priv_b->viewport_height ||
       /* NB: we render upside down to offscreen framebuffers and that
        * can affect how we setup the GL viewport... */
-      a->type != b->type)
+      G_OBJECT_TYPE (a) != G_OBJECT_TYPE (b))
     return COGL_FRAMEBUFFER_STATE_VIEWPORT;
   else
     return 0;
@@ -755,7 +1066,10 @@ static unsigned long
 _cogl_framebuffer_compare_clip_state (CoglFramebuffer *a,
                                       CoglFramebuffer *b)
 {
-  if (a->clip_stack != b->clip_stack)
+  CoglFramebufferPrivate *priv_a = cogl_framebuffer_get_instance_private (a);
+  CoglFramebufferPrivate *priv_b = cogl_framebuffer_get_instance_private (b);
+
+  if (priv_a->clip_stack != priv_b->clip_stack)
     return COGL_FRAMEBUFFER_STATE_CLIP;
   else
     return 0;
@@ -765,7 +1079,10 @@ static unsigned long
 _cogl_framebuffer_compare_dither_state (CoglFramebuffer *a,
                                         CoglFramebuffer *b)
 {
-  return a->dither_enabled != b->dither_enabled ?
+  CoglFramebufferPrivate *priv_a = cogl_framebuffer_get_instance_private (a);
+  CoglFramebufferPrivate *priv_b = cogl_framebuffer_get_instance_private (b);
+
+  return priv_a->dither_enabled != priv_b->dither_enabled ?
     COGL_FRAMEBUFFER_STATE_DITHER : 0;
 }
 
@@ -793,7 +1110,7 @@ static unsigned long
 _cogl_framebuffer_compare_front_face_winding_state (CoglFramebuffer *a,
                                                     CoglFramebuffer *b)
 {
-  if (a->type != b->type)
+  if (G_OBJECT_TYPE (a) != G_OBJECT_TYPE (b))
     return COGL_FRAMEBUFFER_STATE_FRONT_FACE_WINDING;
   else
     return 0;
@@ -803,7 +1120,10 @@ static unsigned long
 _cogl_framebuffer_compare_depth_write_state (CoglFramebuffer *a,
                                              CoglFramebuffer *b)
 {
-  return a->depth_writing_enabled != b->depth_writing_enabled ?
+  CoglFramebufferPrivate *priv_a = cogl_framebuffer_get_instance_private (a);
+  CoglFramebufferPrivate *priv_b = cogl_framebuffer_get_instance_private (b);
+
+  return priv_a->depth_writing_enabled != priv_b->depth_writing_enabled ?
     COGL_FRAMEBUFFER_STATE_DEPTH_WRITE : 0;
 }
 
@@ -811,7 +1131,10 @@ static unsigned long
 _cogl_framebuffer_compare_stereo_mode (CoglFramebuffer *a,
 				       CoglFramebuffer *b)
 {
-  return a->stereo_mode != b->stereo_mode ?
+  CoglFramebufferPrivate *priv_a = cogl_framebuffer_get_instance_private (a);
+  CoglFramebufferPrivate *priv_b = cogl_framebuffer_get_instance_private (b);
+
+  return priv_a->stereo_mode != priv_b->stereo_mode ?
     COGL_FRAMEBUFFER_STATE_STEREO_MODE : 0;
 }
 
@@ -881,7 +1204,7 @@ _cogl_framebuffer_flush_state (CoglFramebuffer *draw_buffer,
                                CoglFramebuffer *read_buffer,
                                CoglFramebufferState state)
 {
-  CoglContext *ctx = draw_buffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (draw_buffer);
 
   ctx->driver_vtable->framebuffer_flush_state (draw_buffer,
                                                read_buffer,
@@ -891,7 +1214,9 @@ _cogl_framebuffer_flush_state (CoglFramebuffer *draw_buffer,
 int
 cogl_framebuffer_get_red_bits (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
   CoglFramebufferBits bits;
 
   ctx->driver_vtable->framebuffer_query_bits (framebuffer, &bits);
@@ -902,7 +1227,9 @@ cogl_framebuffer_get_red_bits (CoglFramebuffer *framebuffer)
 int
 cogl_framebuffer_get_green_bits (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
   CoglFramebufferBits bits;
 
   ctx->driver_vtable->framebuffer_query_bits (framebuffer, &bits);
@@ -913,7 +1240,9 @@ cogl_framebuffer_get_green_bits (CoglFramebuffer *framebuffer)
 int
 cogl_framebuffer_get_blue_bits (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
   CoglFramebufferBits bits;
 
   ctx->driver_vtable->framebuffer_query_bits (framebuffer, &bits);
@@ -924,7 +1253,9 @@ cogl_framebuffer_get_blue_bits (CoglFramebuffer *framebuffer)
 int
 cogl_framebuffer_get_alpha_bits (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
   CoglFramebufferBits bits;
 
   ctx->driver_vtable->framebuffer_query_bits (framebuffer, &bits);
@@ -935,7 +1266,9 @@ cogl_framebuffer_get_alpha_bits (CoglFramebuffer *framebuffer)
 int
 cogl_framebuffer_get_depth_bits (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
   CoglFramebufferBits bits;
 
   ctx->driver_vtable->framebuffer_query_bits (framebuffer, &bits);
@@ -946,7 +1279,9 @@ cogl_framebuffer_get_depth_bits (CoglFramebuffer *framebuffer)
 int
 _cogl_framebuffer_get_stencil_bits (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
   CoglFramebufferBits bits;
 
   ctx->driver_vtable->framebuffer_query_bits (framebuffer, &bits);
@@ -957,96 +1292,136 @@ _cogl_framebuffer_get_stencil_bits (CoglFramebuffer *framebuffer)
 gboolean
 cogl_framebuffer_get_is_stereo (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->config.stereo_enabled;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->config.stereo_enabled;
 }
 
 CoglStereoMode
 cogl_framebuffer_get_stereo_mode (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->stereo_mode;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->stereo_mode;
 }
 
 void
 cogl_framebuffer_set_stereo_mode (CoglFramebuffer *framebuffer,
 				  CoglStereoMode   stereo_mode)
 {
-  if (framebuffer->stereo_mode == stereo_mode)
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  if (priv->stereo_mode == stereo_mode)
     return;
 
   /* Stereo mode changes don't go through the journal */
   _cogl_framebuffer_flush_journal (framebuffer);
 
-  framebuffer->stereo_mode = stereo_mode;
+  priv->stereo_mode = stereo_mode;
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
+  if (priv->context->current_draw_buffer == framebuffer)
+    priv->context->current_draw_buffer_changes |=
       COGL_FRAMEBUFFER_STATE_STEREO_MODE;
 }
 
 gboolean
 cogl_framebuffer_get_depth_write_enabled (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->depth_writing_enabled;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->depth_writing_enabled;
 }
 
 void
 cogl_framebuffer_set_depth_write_enabled (CoglFramebuffer *framebuffer,
                                           gboolean depth_write_enabled)
 {
-  if (framebuffer->depth_writing_enabled == depth_write_enabled)
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  if (priv->depth_writing_enabled == depth_write_enabled)
     return;
 
   /* XXX: Currently depth write changes don't go through the journal */
   _cogl_framebuffer_flush_journal (framebuffer);
 
-  framebuffer->depth_writing_enabled = depth_write_enabled;
+  priv->depth_writing_enabled = depth_write_enabled;
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
+  if (priv->context->current_draw_buffer == framebuffer)
+    priv->context->current_draw_buffer_changes |=
       COGL_FRAMEBUFFER_STATE_DEPTH_WRITE;
 }
 
 gboolean
 cogl_framebuffer_get_dither_enabled (CoglFramebuffer *framebuffer)
 {
-  return framebuffer->dither_enabled;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->dither_enabled;
 }
 
 void
 cogl_framebuffer_set_dither_enabled (CoglFramebuffer *framebuffer,
                                      gboolean dither_enabled)
 {
-  if (framebuffer->dither_enabled == dither_enabled)
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  if (priv->dither_enabled == dither_enabled)
     return;
 
-  framebuffer->dither_enabled = dither_enabled;
+  priv->dither_enabled = dither_enabled;
 }
 
 int
 cogl_framebuffer_get_samples_per_pixel (CoglFramebuffer *framebuffer)
 {
-  if (framebuffer->allocated)
-    return framebuffer->samples_per_pixel;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  if (priv->allocated)
+    return priv->samples_per_pixel;
   else
-    return framebuffer->config.samples_per_pixel;
+    return priv->config.samples_per_pixel;
 }
 
 void
 cogl_framebuffer_set_samples_per_pixel (CoglFramebuffer *framebuffer,
                                         int samples_per_pixel)
 {
-  g_return_if_fail (!framebuffer->allocated);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  g_return_if_fail (!priv->allocated);
+
+  priv->config.samples_per_pixel = samples_per_pixel;
+}
+
+void
+cogl_framebuffer_update_samples_per_pixel (CoglFramebuffer *framebuffer,
+                                           int              samples_per_pixel)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
 
-  framebuffer->config.samples_per_pixel = samples_per_pixel;
+  priv->samples_per_pixel = samples_per_pixel;
 }
 
 void
 cogl_framebuffer_resolve_samples (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   cogl_framebuffer_resolve_samples_region (framebuffer,
                                            0, 0,
-                                           framebuffer->width,
-                                           framebuffer->height);
+                                           priv->width,
+                                           priv->height);
 
   /* TODO: Make this happen implicitly when the resolve texture next gets used
    * as a source, either via cogl_texture_get_data(), via cogl_read_pixels() or
@@ -1089,9 +1464,21 @@ cogl_framebuffer_resolve_samples_region (CoglFramebuffer *framebuffer,
 CoglContext *
 cogl_framebuffer_get_context (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   g_return_val_if_fail (framebuffer != NULL, NULL);
 
-  return framebuffer->context;
+  return priv->context;
+}
+
+CoglJournal *
+cogl_framebuffer_get_journal (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->journal;
 }
 
 static gboolean
@@ -1101,6 +1488,8 @@ _cogl_framebuffer_try_fast_read_pixel (CoglFramebuffer *framebuffer,
                                        CoglReadPixelsFlags source,
                                        CoglBitmap *bitmap)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   gboolean found_intersection;
   CoglPixelFormat format;
 
@@ -1116,7 +1505,7 @@ _cogl_framebuffer_try_fast_read_pixel (CoglFramebuffer *framebuffer,
       format != COGL_PIXEL_FORMAT_RGBA_8888)
     return FALSE;
 
-  if (!_cogl_journal_try_read_pixel (framebuffer->journal,
+  if (!_cogl_journal_try_read_pixel (priv->journal,
                                      x, y, bitmap,
                                      &found_intersection))
     return FALSE;
@@ -1134,20 +1523,20 @@ _cogl_framebuffer_try_fast_read_pixel (CoglFramebuffer *framebuffer,
 
   /* If the framebuffer has been rendered too since it was last
    * cleared then we can't return the last known clear color. */
-  if (framebuffer->clear_clip_dirty)
+  if (priv->clear_clip_dirty)
     return FALSE;
 
-  if (x >= framebuffer->clear_clip_x0 &&
-      x < framebuffer->clear_clip_x1 &&
-      y >= framebuffer->clear_clip_y0 &&
-      y < framebuffer->clear_clip_y1)
+  if (x >= priv->clear_clip_x0 &&
+      x < priv->clear_clip_x1 &&
+      y >= priv->clear_clip_y0 &&
+      y < priv->clear_clip_y1)
     {
       uint8_t *pixel;
       GError *ignore_error = NULL;
 
       /* we currently only care about cases where the premultiplied or
        * unpremultipled colors are equivalent... */
-      if (framebuffer->clear_color_alpha != 1.0)
+      if (priv->clear_color_alpha != 1.0)
         return FALSE;
 
       pixel = _cogl_bitmap_map (bitmap,
@@ -1160,10 +1549,10 @@ _cogl_framebuffer_try_fast_read_pixel (CoglFramebuffer *framebuffer,
           return FALSE;
         }
 
-      pixel[0] = framebuffer->clear_color_red * 255.0;
-      pixel[1] = framebuffer->clear_color_green * 255.0;
-      pixel[2] = framebuffer->clear_color_blue * 255.0;
-      pixel[3] = framebuffer->clear_color_alpha * 255.0;
+      pixel[0] = priv->clear_color_red * 255.0;
+      pixel[1] = priv->clear_color_green * 255.0;
+      pixel[2] = priv->clear_color_blue * 255.0;
+      pixel[3] = priv->clear_color_alpha * 255.0;
 
       _cogl_bitmap_unmap (bitmap);
 
@@ -1181,6 +1570,8 @@ _cogl_framebuffer_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
                                            CoglBitmap *bitmap,
                                            GError **error)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglContext *ctx;
   int width;
   int height;
@@ -1194,7 +1585,7 @@ _cogl_framebuffer_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
   width = cogl_bitmap_get_width (bitmap);
   height = cogl_bitmap_get_height (bitmap);
 
-  if (width == 1 && height == 1 && !framebuffer->clear_clip_dirty)
+  if (width == 1 && height == 1 && !priv->clear_clip_dirty)
     {
       /* If everything drawn so far for this frame is still in the
        * Journal then if all of the rectangles only have a flat
@@ -1248,6 +1639,8 @@ cogl_framebuffer_read_pixels (CoglFramebuffer *framebuffer,
                               CoglPixelFormat format,
                               uint8_t *pixels)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   int bpp;
   CoglBitmap *bitmap;
   gboolean ret;
@@ -1255,7 +1648,7 @@ cogl_framebuffer_read_pixels (CoglFramebuffer *framebuffer,
   g_return_val_if_fail (cogl_pixel_format_get_n_planes (format) == 1, FALSE);
 
   bpp = cogl_pixel_format_get_bytes_per_pixel (format, 0);
-  bitmap = cogl_bitmap_new_for_data (framebuffer->context,
+  bitmap = cogl_bitmap_new_for_data (priv->context,
                                      width, height,
                                      format,
                                      bpp * width, /* rowstride */
@@ -1276,9 +1669,15 @@ cogl_framebuffer_read_pixels (CoglFramebuffer *framebuffer,
   return ret;
 }
 
+static gboolean
+cogl_framebuffer_is_y_flipped (CoglFramebuffer *framebuffer)
+{
+  return COGL_FRAMEBUFFER_GET_CLASS (framebuffer)->is_y_flipped (framebuffer);
+}
+
 gboolean
-cogl_blit_framebuffer (CoglFramebuffer *src,
-                       CoglFramebuffer *dest,
+cogl_blit_framebuffer (CoglFramebuffer *framebuffer,
+                       CoglFramebuffer *dst,
                        int src_x,
                        int src_y,
                        int dst_x,
@@ -1287,7 +1686,11 @@ cogl_blit_framebuffer (CoglFramebuffer *src,
                        int height,
                        GError **error)
 {
-  CoglContext *ctx = src->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglFramebufferPrivate *dst_priv =
+    cogl_framebuffer_get_instance_private (dst);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   int src_x1, src_y1, src_x2, src_y2;
   int dst_x1, dst_y1, dst_x2, dst_y2;
 
@@ -1300,8 +1703,8 @@ cogl_blit_framebuffer (CoglFramebuffer *src,
     }
 
   /* The buffers must use the same premult convention */
-  if ((src->internal_format & COGL_PREMULT_BIT) !=
-      (dest->internal_format & COGL_PREMULT_BIT))
+  if ((priv->internal_format & COGL_PREMULT_BIT) !=
+      (dst_priv->internal_format & COGL_PREMULT_BIT))
     {
       g_set_error_literal (error, COGL_SYSTEM_ERROR,
                            COGL_SYSTEM_ERROR_UNSUPPORTED,
@@ -1312,12 +1715,12 @@ cogl_blit_framebuffer (CoglFramebuffer *src,
   /* Make sure any batched primitives get submitted to the driver
    * before blitting
    */
-  _cogl_framebuffer_flush_journal (src);
+  _cogl_framebuffer_flush_journal (framebuffer);
 
   /* Make sure the current framebuffers are bound. We explicitly avoid
      flushing the clip state so we can bind our own empty state */
-  _cogl_framebuffer_flush_state (dest,
-                                 src,
+  _cogl_framebuffer_flush_state (dst,
+                                 framebuffer,
                                  COGL_FRAMEBUFFER_STATE_ALL &
                                  ~COGL_FRAMEBUFFER_STATE_CLIP);
 
@@ -1325,7 +1728,7 @@ cogl_blit_framebuffer (CoglFramebuffer *src,
      by the scissor and we want to hide this feature for the Cogl API
      because it's not obvious to an app how the clip state will affect
      the scissor */
-  _cogl_clip_stack_flush (NULL, dest);
+  _cogl_clip_stack_flush (NULL, dst);
 
   /* XXX: Because we are manually flushing clip state here we need to
    * make sure that the clip state gets updated the next time we flush
@@ -1336,7 +1739,7 @@ cogl_blit_framebuffer (CoglFramebuffer *src,
   /* Offscreens we do the normal way, onscreens need an y-flip. Even if
    * we consider offscreens to be rendered upside-down, the offscreen
    * orientation is in this function's API. */
-  if (cogl_is_offscreen (src))
+  if (cogl_framebuffer_is_y_flipped (framebuffer))
     {
       src_x1 = src_x;
       src_y1 = src_y;
@@ -1346,12 +1749,12 @@ cogl_blit_framebuffer (CoglFramebuffer *src,
   else
     {
       src_x1 = src_x;
-      src_y1 = cogl_framebuffer_get_height (src) - src_y;
+      src_y1 = cogl_framebuffer_get_height (framebuffer) - src_y;
       src_x2 = src_x + width;
       src_y2 = src_y1 - height;
     }
 
-  if (cogl_is_offscreen (dest))
+  if (cogl_framebuffer_is_y_flipped (dst))
     {
       dst_x1 = dst_x;
       dst_y1 = dst_y;
@@ -1361,7 +1764,7 @@ cogl_blit_framebuffer (CoglFramebuffer *src,
   else
     {
       dst_x1 = dst_x;
-      dst_y1 = cogl_framebuffer_get_height (dest) - dst_y;
+      dst_y1 = cogl_framebuffer_get_height (dst) - dst_y;
       dst_x2 = dst_x + width;
       dst_y2 = dst_y1 - height;
     }
@@ -1378,7 +1781,9 @@ void
 cogl_framebuffer_discard_buffers (CoglFramebuffer *framebuffer,
                                   unsigned long buffers)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
 
   g_return_if_fail (buffers & COGL_BUFFER_BIT_COLOR);
 
@@ -1388,7 +1793,9 @@ cogl_framebuffer_discard_buffers (CoglFramebuffer *framebuffer,
 void
 cogl_framebuffer_finish (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
 
   _cogl_framebuffer_flush_journal (framebuffer);
 
@@ -1398,8 +1805,9 @@ cogl_framebuffer_finish (CoglFramebuffer *framebuffer)
 void
 cogl_framebuffer_flush (CoglFramebuffer *framebuffer)
 {
-
-  CoglContext *ctx = framebuffer->context;
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+  CoglContext *ctx = priv->context;
 
   _cogl_framebuffer_flush_journal (framebuffer);
 
@@ -1409,37 +1817,49 @@ cogl_framebuffer_flush (CoglFramebuffer *framebuffer)
 void
 cogl_framebuffer_push_matrix (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_push (modelview_stack);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
 cogl_framebuffer_pop_matrix (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_pop (modelview_stack);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
 cogl_framebuffer_identity_matrix (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_load_identity (modelview_stack);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
@@ -1448,13 +1868,17 @@ cogl_framebuffer_scale (CoglFramebuffer *framebuffer,
                         float y,
                         float z)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_scale (modelview_stack, x, y, z);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
@@ -1463,13 +1887,17 @@ cogl_framebuffer_translate (CoglFramebuffer *framebuffer,
                             float y,
                             float z)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_translate (modelview_stack, x, y, z);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
@@ -1479,39 +1907,51 @@ cogl_framebuffer_rotate (CoglFramebuffer *framebuffer,
                          float y,
                          float z)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_rotate (modelview_stack, angle, x, y, z);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
 cogl_framebuffer_rotate_euler (CoglFramebuffer *framebuffer,
                                const graphene_euler_t *euler)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_rotate_euler (modelview_stack, euler);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
 cogl_framebuffer_transform (CoglFramebuffer         *framebuffer,
                             const graphene_matrix_t *matrix)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_multiply (modelview_stack, matrix);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
@@ -1521,6 +1961,8 @@ cogl_framebuffer_perspective (CoglFramebuffer *framebuffer,
                               float z_near,
                               float z_far)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   float ymax = z_near * tanf (fov_y * G_PI / 360.0);
 
   cogl_framebuffer_frustum (framebuffer,
@@ -1531,9 +1973,11 @@ cogl_framebuffer_perspective (CoglFramebuffer *framebuffer,
                             z_near,
                             z_far);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_PROJECTION;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_PROJECTION;
+    }
 }
 
 void
@@ -1545,6 +1989,8 @@ cogl_framebuffer_frustum (CoglFramebuffer *framebuffer,
                           float z_near,
                           float z_far)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *projection_stack =
     _cogl_framebuffer_get_projection_stack (framebuffer);
 
@@ -1562,9 +2008,11 @@ cogl_framebuffer_frustum (CoglFramebuffer *framebuffer,
                              z_near,
                              z_far);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_PROJECTION;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_PROJECTION;
+    }
 }
 
 void
@@ -1576,6 +2024,8 @@ cogl_framebuffer_orthographic (CoglFramebuffer *framebuffer,
                                float near,
                                float far)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   graphene_matrix_t ortho;
   CoglMatrixStack *projection_stack =
     _cogl_framebuffer_get_projection_stack (framebuffer);
@@ -1587,9 +2037,11 @@ cogl_framebuffer_orthographic (CoglFramebuffer *framebuffer,
   graphene_matrix_init_ortho (&ortho, x_1, x_2, y_2, y_1, near, far);
   cogl_matrix_stack_set (projection_stack, &ortho);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_PROJECTION;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_PROJECTION;
+    }
 }
 
 void
@@ -1598,6 +2050,7 @@ cogl_framebuffer_get_modelview_matrix (CoglFramebuffer   *framebuffer,
 {
   CoglMatrixEntry *modelview_entry =
     _cogl_framebuffer_get_modelview_entry (framebuffer);
+
   cogl_matrix_entry_get (modelview_entry, matrix);
 }
 
@@ -1605,13 +2058,17 @@ void
 cogl_framebuffer_set_modelview_matrix (CoglFramebuffer         *framebuffer,
                                        const graphene_matrix_t *matrix)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *modelview_stack =
     _cogl_framebuffer_get_modelview_stack (framebuffer);
   cogl_matrix_stack_set (modelview_stack, matrix);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_MODELVIEW;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_MODELVIEW;
+    }
 }
 
 void
@@ -1620,6 +2077,7 @@ cogl_framebuffer_get_projection_matrix (CoglFramebuffer   *framebuffer,
 {
   CoglMatrixEntry *projection_entry =
     _cogl_framebuffer_get_projection_entry (framebuffer);
+
   cogl_matrix_entry_get (projection_entry, matrix);
 }
 
@@ -1627,6 +2085,8 @@ void
 cogl_framebuffer_set_projection_matrix (CoglFramebuffer         *framebuffer,
                                         const graphene_matrix_t *matrix)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixStack *projection_stack =
     _cogl_framebuffer_get_projection_stack (framebuffer);
 
@@ -1636,9 +2096,11 @@ cogl_framebuffer_set_projection_matrix (CoglFramebuffer         *framebuffer,
 
   cogl_matrix_stack_set (projection_stack, matrix);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_PROJECTION;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_PROJECTION;
+    }
 }
 
 void
@@ -1648,13 +2110,18 @@ cogl_framebuffer_push_scissor_clip (CoglFramebuffer *framebuffer,
                                     int width,
                                     int height)
 {
-  framebuffer->clip_stack =
-    _cogl_clip_stack_push_window_rectangle (framebuffer->clip_stack,
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->clip_stack =
+    _cogl_clip_stack_push_window_rectangle (priv->clip_stack,
                                             x, y, width, height);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_CLIP;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_CLIP;
+    }
 }
 
 void
@@ -1664,6 +2131,8 @@ cogl_framebuffer_push_rectangle_clip (CoglFramebuffer *framebuffer,
                                       float x_2,
                                       float y_2)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixEntry *modelview_entry =
     _cogl_framebuffer_get_modelview_entry (framebuffer);
   CoglMatrixEntry *projection_entry =
@@ -1671,22 +2140,24 @@ cogl_framebuffer_push_rectangle_clip (CoglFramebuffer *framebuffer,
   /* XXX: It would be nicer if we stored the private viewport as a
    * vec4 so we could avoid this redundant copy. */
   float viewport[] = {
-      framebuffer->viewport_x,
-      framebuffer->viewport_y,
-      framebuffer->viewport_width,
-      framebuffer->viewport_height
+    priv->viewport_x,
+    priv->viewport_y,
+    priv->viewport_width,
+    priv->viewport_height
   };
 
-  framebuffer->clip_stack =
-    _cogl_clip_stack_push_rectangle (framebuffer->clip_stack,
+  priv->clip_stack =
+    _cogl_clip_stack_push_rectangle (priv->clip_stack,
                                      x_1, y_1, x_2, y_2,
                                      modelview_entry,
                                      projection_entry,
                                      viewport);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_CLIP;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_CLIP;
+    }
 }
 
 void
@@ -1697,6 +2168,8 @@ cogl_framebuffer_push_primitive_clip (CoglFramebuffer *framebuffer,
                                       float bounds_x2,
                                       float bounds_y2)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
   CoglMatrixEntry *modelview_entry =
     _cogl_framebuffer_get_modelview_entry (framebuffer);
   CoglMatrixEntry *projection_entry =
@@ -1704,14 +2177,14 @@ cogl_framebuffer_push_primitive_clip (CoglFramebuffer *framebuffer,
   /* XXX: It would be nicer if we stored the private viewport as a
    * vec4 so we could avoid this redundant copy. */
   float viewport[] = {
-      framebuffer->viewport_x,
-      framebuffer->viewport_y,
-      framebuffer->viewport_width,
-      framebuffer->viewport_height
+    priv->viewport_x,
+    priv->viewport_y,
+    priv->viewport_width,
+    priv->viewport_height
   };
 
-  framebuffer->clip_stack =
-    _cogl_clip_stack_push_primitive (framebuffer->clip_stack,
+  priv->clip_stack =
+    _cogl_clip_stack_push_primitive (priv->clip_stack,
                                      primitive,
                                      bounds_x1, bounds_y1,
                                      bounds_x2, bounds_y2,
@@ -1719,37 +2192,52 @@ cogl_framebuffer_push_primitive_clip (CoglFramebuffer *framebuffer,
                                      projection_entry,
                                      viewport);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_CLIP;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_CLIP;
+    }
 }
 
 void
 cogl_framebuffer_push_region_clip (CoglFramebuffer *framebuffer,
                                    cairo_region_t  *region)
 {
-  framebuffer->clip_stack =
-    cogl_clip_stack_push_region (framebuffer->clip_stack,
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->clip_stack =
+    cogl_clip_stack_push_region (priv->clip_stack,
                                  region);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_CLIP;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_CLIP;
+    }
 }
 
 void
 cogl_framebuffer_pop_clip (CoglFramebuffer *framebuffer)
 {
-  framebuffer->clip_stack = _cogl_clip_stack_pop (framebuffer->clip_stack);
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  priv->clip_stack = _cogl_clip_stack_pop (priv->clip_stack);
 
-  if (framebuffer->context->current_draw_buffer == framebuffer)
-    framebuffer->context->current_draw_buffer_changes |=
-      COGL_FRAMEBUFFER_STATE_CLIP;
+  if (priv->context->current_draw_buffer == framebuffer)
+    {
+      priv->context->current_draw_buffer_changes |=
+        COGL_FRAMEBUFFER_STATE_CLIP;
+    }
 }
 
 void
 _cogl_framebuffer_unref (CoglFramebuffer *framebuffer)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
   /* The journal holds a reference to the framebuffer whenever it is
      non-empty. Therefore if the journal is non-empty and we will have
      exactly one reference then we know the journal is the only thing
@@ -1757,7 +2245,7 @@ _cogl_framebuffer_unref (CoglFramebuffer *framebuffer)
      journal and let the framebuffer die. It is fine at this point if
      flushing the journal causes something else to take a reference to
      it and it comes back to life */
-  if (framebuffer->journal->entries->len > 0)
+  if (priv->journal->entries->len > 0)
     {
       unsigned int ref_count = ((CoglObject *) framebuffer)->ref_count;
 
@@ -2064,13 +2552,16 @@ _cogl_framebuffer_draw_attributes (CoglFramebuffer *framebuffer,
                                    int n_attributes,
                                    CoglDrawFlags flags)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
 #ifdef COGL_ENABLE_DEBUG
   if (G_UNLIKELY (COGL_DEBUG_ENABLED (COGL_DEBUG_WIREFRAME) &&
                   (flags & COGL_DRAW_SKIP_DEBUG_WIREFRAME) == 0) &&
       mode != COGL_VERTICES_MODE_LINES &&
       mode != COGL_VERTICES_MODE_LINE_LOOP &&
       mode != COGL_VERTICES_MODE_LINE_STRIP)
-    draw_wireframe (framebuffer->context,
+    draw_wireframe (priv->context,
                     framebuffer, pipeline,
                     mode, first_vertex, n_vertices,
                     attributes, n_attributes, NULL,
@@ -2078,7 +2569,7 @@ _cogl_framebuffer_draw_attributes (CoglFramebuffer *framebuffer,
   else
 #endif
     {
-      CoglContext *ctx = framebuffer->context;
+      CoglContext *ctx = priv->context;
 
       ctx->driver_vtable->framebuffer_draw_attributes (framebuffer,
                                                        pipeline,
@@ -2102,13 +2593,16 @@ _cogl_framebuffer_draw_indexed_attributes (CoglFramebuffer *framebuffer,
                                            int n_attributes,
                                            CoglDrawFlags flags)
 {
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
 #ifdef COGL_ENABLE_DEBUG
   if (G_UNLIKELY (COGL_DEBUG_ENABLED (COGL_DEBUG_WIREFRAME) &&
                   (flags & COGL_DRAW_SKIP_DEBUG_WIREFRAME) == 0) &&
       mode != COGL_VERTICES_MODE_LINES &&
       mode != COGL_VERTICES_MODE_LINE_LOOP &&
       mode != COGL_VERTICES_MODE_LINE_STRIP)
-    draw_wireframe (framebuffer->context,
+    draw_wireframe (priv->context,
                     framebuffer, pipeline,
                     mode, first_vertex, n_vertices,
                     attributes, n_attributes, indices,
@@ -2116,7 +2610,7 @@ _cogl_framebuffer_draw_indexed_attributes (CoglFramebuffer *framebuffer,
   else
 #endif
     {
-      CoglContext *ctx = framebuffer->context;
+      CoglContext *ctx = priv->context;
 
       ctx->driver_vtable->framebuffer_draw_indexed_attributes (framebuffer,
                                                                pipeline,
@@ -2280,3 +2774,26 @@ cogl_framebuffer_draw_textured_rectangles (CoglFramebuffer *framebuffer,
                                                    rects,
                                                    n_rectangles);
 }
+
+gpointer
+cogl_framebuffer_get_driver_private (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  return priv->driver_private;
+}
+
+void
+cogl_framebuffer_set_driver_private (CoglFramebuffer *framebuffer,
+                                     gpointer         driver_private,
+                                     GDestroyNotify   destroy_notify)
+{
+  CoglFramebufferPrivate *priv =
+    cogl_framebuffer_get_instance_private (framebuffer);
+
+  g_warn_if_fail (!priv->driver_private);
+
+  priv->driver_private = driver_private;
+  priv->driver_private_destroy = destroy_notify;
+}
diff --git a/cogl/cogl/cogl-framebuffer.h b/cogl/cogl/cogl-framebuffer.h
index 22af34fa040f699dd9a72f741cd51e6a25098f7b..688c35f762687156811538650b388e2fc7ea798b 100644
--- a/cogl/cogl/cogl-framebuffer.h
+++ b/cogl/cogl/cogl-framebuffer.h
@@ -35,19 +35,6 @@
 #ifndef __COGL_FRAMEBUFFER_H
 #define __COGL_FRAMEBUFFER_H
 
-/* We forward declare the CoglFramebuffer type here to avoid some circular
- * dependency issues with the following headers.
- */
-#if defined(__COGL_H_INSIDE__) && !defined(COGL_ENABLE_MUTTER_API) && \
-  !defined(COGL_GIR_SCANNING)
-/* For the public C api we typedef interface types as void to avoid needing
- * lots of casting in code and instead we will rely on runtime type checking
- * for these objects. */
-typedef void CoglFramebuffer;
-#else
-typedef struct _CoglFramebuffer CoglFramebuffer;
-#define COGL_FRAMEBUFFER(X) ((CoglFramebuffer *)(X))
-#endif
 
 #include <cogl/cogl-pipeline.h>
 #include <cogl/cogl-indices.h>
@@ -98,13 +85,20 @@ G_BEGIN_DECLS
  * configuration.
  */
 
-/**
- * cogl_framebuffer_get_gtype:
- *
- * Returns: a #GType that can be used with the GLib type system.
- */
+#define COGL_TYPE_FRAMEBUFFER (cogl_framebuffer_get_type ())
 COGL_EXPORT
-GType cogl_framebuffer_get_gtype (void);
+G_DECLARE_DERIVABLE_TYPE (CoglFramebuffer, cogl_framebuffer,
+                          COGL, FRAMEBUFFER, GObject)
+
+struct _CoglFramebufferClass
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  gboolean (* allocate) (CoglFramebuffer  *framebuffer,
+                         GError          **error);
+  gboolean (* is_y_flipped) (CoglFramebuffer *framebuffer);
+};
 
 /**
  * cogl_framebuffer_allocate:
@@ -1495,8 +1489,8 @@ cogl_is_framebuffer (void *object);
 
 /**
  * cogl_blit_framebuffer:
- * @src: The source #CoglFramebuffer
- * @dest: The destination #CoglFramebuffer
+ * @framebuffer: The source #CoglFramebuffer
+ * @dst: The destination #CoglFramebuffer
  * @src_x: Source x position
  * @src_y: Source y position
  * @dst_x: Destination x position
@@ -1546,8 +1540,8 @@ cogl_is_framebuffer (void *object);
  * COGL_SYSTEM_ERROR will be created.
  */
 COGL_EXPORT gboolean
-cogl_blit_framebuffer (CoglFramebuffer *src,
-                       CoglFramebuffer *dest,
+cogl_blit_framebuffer (CoglFramebuffer *framebuffer,
+                       CoglFramebuffer *dst,
                        int src_x,
                        int src_y,
                        int dst_x,
diff --git a/cogl/cogl/cogl-journal.c b/cogl/cogl/cogl-journal.c
index 498e4d877b33d8e62e8a9a5a4b8a6d5b9c57e3d6..b567530bd031b72ee64bb34f3c87322a162226e3 100644
--- a/cogl/cogl/cogl-journal.c
+++ b/cogl/cogl/cogl-journal.c
@@ -567,7 +567,8 @@ _cogl_journal_flush_vbo_offsets_and_entries (CoglJournalEntry *batch_start,
                                              void             *data)
 {
   CoglJournalFlushState *state = data;
-  CoglContext *ctx = state->journal->framebuffer->context;
+  CoglFramebuffer *framebuffer = state->journal->framebuffer;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   size_t stride;
   int i;
   CoglAttribute **attribute_entry;
@@ -688,7 +689,7 @@ _cogl_journal_flush_clip_stacks_and_entries (CoglJournalEntry *batch_start,
 {
   CoglJournalFlushState *state = data;
   CoglFramebuffer *framebuffer = state->journal->framebuffer;
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglMatrixStack *projection_stack;
 
   COGL_STATIC_TIMER (time_flush_clip_stack_pipeline_entries,
@@ -1032,7 +1033,7 @@ _cogl_journal_flush_dither_and_entries (CoglJournalEntry *batch_start,
 {
   CoglJournalFlushState *state = data;
   CoglFramebuffer *framebuffer = state->journal->framebuffer;
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
   COGL_STATIC_TIMER (time_flush_dither_and_entries,
                      "Journal Flush", /* parent */
@@ -1075,7 +1076,7 @@ _cogl_journal_flush_viewport_and_entries (CoglJournalEntry *batch_start,
 {
   CoglJournalFlushState *state = data;
   CoglFramebuffer *framebuffer = state->journal->framebuffer;
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   float current_viewport[4];
 
   COGL_STATIC_TIMER (time_flush_viewport_and_entries,
@@ -1123,8 +1124,8 @@ static CoglAttributeBuffer *
 create_attribute_buffer (CoglJournal *journal,
                          size_t n_bytes)
 {
+  CoglContext *ctx = cogl_framebuffer_get_context (journal->framebuffer);
   CoglAttributeBuffer *vbo;
-  CoglContext *ctx = journal->framebuffer->context;
 
   vbo = journal->vbo_pool[journal->next_vbo_in_pool];
 
@@ -1271,7 +1272,7 @@ _cogl_journal_discard (CoglJournal *journal)
 
   /* The journal only holds a reference to the framebuffer while the
      journal is not empty */
-  cogl_object_unref (journal->framebuffer);
+  g_object_unref (journal->framebuffer);
 }
 
 /* Note: A return value of FALSE doesn't mean 'no' it means
@@ -1383,7 +1384,7 @@ _cogl_journal_flush (CoglJournal *journal)
     }
 
   framebuffer = journal->framebuffer;
-  ctx = framebuffer->context;
+  ctx = cogl_framebuffer_get_context (framebuffer);
 
   /* The entries in this journal may depend on images in other
    * framebuffers which may require that we flush the journals
@@ -1532,7 +1533,7 @@ _cogl_journal_log_quad (CoglJournal  *journal,
      reference to the current framebuffer. This reference will be
      removed when the journal is flushed */
   if (journal->vertices->len == 0)
-    cogl_object_ref (framebuffer);
+    g_object_ref (framebuffer);
 
   /* The vertex data is logged into a separate array. The data needs
      to be copied into a vertex array before it's given to GL so we
diff --git a/cogl/cogl/cogl-offscreen.h b/cogl/cogl/cogl-offscreen.h
index 07289db5411e610362148ad72c779bd03a02a3bc..2fa21dcc448e0cae4e22a07fdbd4f637fb97c631 100644
--- a/cogl/cogl/cogl-offscreen.h
+++ b/cogl/cogl/cogl-offscreen.h
@@ -50,19 +50,13 @@ G_BEGIN_DECLS
  * Cogl allows creating and operating on offscreen framebuffers.
  */
 
-typedef struct _CoglOffscreen CoglOffscreen;
-
-#define COGL_OFFSCREEN(X) ((CoglOffscreen *)X)
+/* Offscreen api */
 
-/**
- * cogl_offscreen_get_gtype:
- *
- * Returns: a #GType that can be used with the GLib type system.
- */
+#define COGL_TYPE_OFFSCREEN (cogl_offscreen_get_type ())
 COGL_EXPORT
-GType cogl_offscreen_get_gtype (void);
-
-/* Offscreen api */
+G_DECLARE_FINAL_TYPE (CoglOffscreen, cogl_offscreen,
+                      COGL, OFFSCREEN,
+                      CoglFramebuffer)
 
 /**
  * cogl_offscreen_new_with_texture:
@@ -99,43 +93,6 @@ GType cogl_offscreen_get_gtype (void);
 COGL_EXPORT CoglOffscreen *
 cogl_offscreen_new_with_texture (CoglTexture *texture);
 
-/**
- * cogl_offscreen_new_to_texture:
- * @texture: A #CoglTexture pointer
- *
- * This creates an offscreen buffer object using the given @texture as the
- * primary color buffer. It doesn't just initialize the contents of the
- * offscreen buffer with the @texture; they are tightly bound so that
- * drawing to the offscreen buffer effectivly updates the contents of the
- * given texture. You don't need to destroy the offscreen buffer before
- * you can use the @texture again.
- *
- * <note>This only works with low-level #CoglTexture types such as
- * #CoglTexture2D and not with meta-texture types such as
- * #CoglTexture2DSliced.</note>
- *
- * Return value: (transfer full): a newly instantiated #CoglOffscreen
- *   framebuffer or %NULL if it wasn't possible to create the
- *   buffer.
- * Deprecated: 1.16: Use cogl_offscreen_new_with_texture instead.
- */
-COGL_DEPRECATED_FOR (cogl_offscreen_new_with_texture)
-COGL_EXPORT CoglOffscreen *
-cogl_offscreen_new_to_texture (CoglTexture *texture);
-
-/**
- * cogl_is_offscreen:
- * @object: A pointer to a #CoglObject
- *
- * Determines whether the given #CoglObject references an offscreen
- * framebuffer object.
- *
- * Returns: %TRUE if @object is a #CoglOffscreen framebuffer,
- *          %FALSE otherwise
- */
-COGL_EXPORT gboolean
-cogl_is_offscreen (void *object);
-
 /**
  * cogl_offscreen_get_texture: (skip)
  */
diff --git a/cogl/cogl/cogl-onscreen-private.h b/cogl/cogl/cogl-onscreen-private.h
index 480ca50761a41ceaf6a5ae97b9cdfdc06a7b1b8f..ad46273042d91557a757ddfb4066d8867e9ddf47 100644
--- a/cogl/cogl/cogl-onscreen-private.h
+++ b/cogl/cogl/cogl-onscreen-private.h
@@ -57,7 +57,7 @@ typedef struct _CoglOnscreenQueuedDirty
 
 struct _CoglOnscreen
 {
-  CoglFramebuffer  _parent;
+  CoglFramebuffer parent;
 
   CoglList frame_closures;
 
@@ -75,9 +75,6 @@ struct _CoglOnscreen
   void *winsys;
 };
 
-CoglOnscreen *
-_cogl_onscreen_new (void);
-
 COGL_EXPORT void
 _cogl_framebuffer_winsys_update_size (CoglFramebuffer *framebuffer,
                                       int width, int height);
diff --git a/cogl/cogl/cogl-onscreen.c b/cogl/cogl/cogl-onscreen.c
index ef996017ac3a945aed3c1df666a62446577410ea..651f3a72757f04368d718c48b5f0079b6dad5a3a 100644
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -42,13 +42,7 @@
 #include "cogl-poll-private.h"
 #include "cogl-gtype-private.h"
 
-static void _cogl_onscreen_free (CoglOnscreen *onscreen);
-
-COGL_OBJECT_DEFINE_WITH_CODE_GTYPE (Onscreen, onscreen,
-                                    _cogl_onscreen_class.virt_unref =
-                                    _cogl_framebuffer_unref);
-COGL_GTYPE_DEFINE_CLASS (Onscreen, onscreen,
-                         COGL_GTYPE_IMPLEMENT_INTERFACE (framebuffer));
+G_DEFINE_TYPE (CoglOnscreen, cogl_onscreen, COGL_TYPE_FRAMEBUFFER)
 
 static gpointer
 cogl_dummy_copy (gpointer data)
@@ -83,37 +77,7 @@ _cogl_onscreen_init_from_template (CoglOnscreen *onscreen,
   _cogl_list_init (&onscreen->resize_closures);
   _cogl_list_init (&onscreen->dirty_closures);
 
-  framebuffer->config = onscreen_template->config;
-  cogl_object_ref (framebuffer->config.swap_chain);
-}
-
-/* XXX: While we still have backend in Clutter we need a dummy object
- * to represent the CoglOnscreen framebuffer that the backend
- * creates... */
-CoglOnscreen *
-_cogl_onscreen_new (void)
-{
-  g_autofree CoglOnscreen *onscreen_ptr = g_new0 (CoglOnscreen, 1);
-  CoglOnscreen *onscreen;
-
-  _COGL_GET_CONTEXT (ctx, NULL);
-
-  onscreen = g_steal_pointer (&onscreen_ptr);
-  _cogl_framebuffer_init (COGL_FRAMEBUFFER (onscreen),
-                          ctx,
-                          COGL_FRAMEBUFFER_TYPE_ONSCREEN,
-                          0x1eadbeef, /* width */
-                          0x1eadbeef); /* height */
-  /* NB: make sure to pass positive width/height numbers here
-   * because otherwise we'll hit input validation assertions!*/
-
-  _cogl_onscreen_init_from_template (onscreen, ctx->display->onscreen_template);
-
-  COGL_FRAMEBUFFER (onscreen)->allocated = TRUE;
-
-  /* XXX: Note we don't initialize onscreen->winsys in this case. */
-
-  return _cogl_onscreen_object_new (onscreen);
+  cogl_framebuffer_init_config (framebuffer, &onscreen_template->config);
 }
 
 CoglOnscreen *
@@ -132,21 +96,48 @@ cogl_onscreen_new (CoglContext *ctx, int width, int height)
      is not premultiplied in case it is being used for some special
      purpose. */
 
-  onscreen = g_new0 (CoglOnscreen, 1);
-  _cogl_framebuffer_init (COGL_FRAMEBUFFER (onscreen),
-                          ctx,
-                          COGL_FRAMEBUFFER_TYPE_ONSCREEN,
-                          width, /* width */
-                          height); /* height */
+  onscreen = g_object_new (COGL_TYPE_ONSCREEN,
+                           "context", ctx,
+                           "width", width,
+                           "height", height,
+                           NULL);
 
   _cogl_onscreen_init_from_template (onscreen, ctx->display->onscreen_template);
 
-  return _cogl_onscreen_object_new (onscreen);
+  return onscreen;
+}
+
+static gboolean
+cogl_onscreen_allocate (CoglFramebuffer  *framebuffer,
+                        GError          **error)
+{
+  CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+  const CoglWinsysVtable *winsys = _cogl_framebuffer_get_winsys (framebuffer);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
+
+  if (!winsys->onscreen_init (onscreen, error))
+    return FALSE;
+
+  /* If the winsys doesn't support dirty events then we'll report
+   * one on allocation so that if the application only paints in
+   * response to dirty events then it will at least paint once to
+   * start */
+  if (!_cogl_has_private_feature (ctx, COGL_PRIVATE_FEATURE_DIRTY_EVENTS))
+    _cogl_onscreen_queue_full_dirty (onscreen);
+
+  return TRUE;
+}
+
+static gboolean
+cogl_onscreen_is_y_flipped (CoglFramebuffer *framebuffer)
+{
+  return FALSE;
 }
 
 static void
-_cogl_onscreen_free (CoglOnscreen *onscreen)
+cogl_onscreen_dispose (GObject *object)
 {
+  CoglOnscreen *onscreen = COGL_ONSCREEN (object);
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys = _cogl_framebuffer_get_winsys (framebuffer);
   CoglFrameInfo *frame_info;
@@ -159,13 +150,28 @@ _cogl_onscreen_free (CoglOnscreen *onscreen)
     cogl_object_unref (frame_info);
   g_queue_clear (&onscreen->pending_frame_infos);
 
-  winsys->onscreen_deinit (onscreen);
+  if (onscreen->winsys)
+    winsys->onscreen_deinit (onscreen);
   g_return_if_fail (onscreen->winsys == NULL);
 
-  /* Chain up to parent */
-  _cogl_framebuffer_free (framebuffer);
+  G_OBJECT_CLASS (cogl_onscreen_parent_class)->dispose (object);
+}
+
+static void
+cogl_onscreen_init (CoglOnscreen *onscreen)
+{
+}
+
+static void
+cogl_onscreen_class_init (CoglOnscreenClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  CoglFramebufferClass *framebuffer_class = COGL_FRAMEBUFFER_CLASS (klass);
+
+  object_class->dispose = cogl_onscreen_dispose;
 
-  g_free (onscreen);
+  framebuffer_class->allocate = cogl_onscreen_allocate;
+  framebuffer_class->is_y_flipped = cogl_onscreen_is_y_flipped;
 }
 
 static void
@@ -192,8 +198,8 @@ _cogl_dispatch_onscreen_cb (CoglContext *context)
   _cogl_list_insert_list (&queue, &context->onscreen_events_queue);
   _cogl_list_init (&context->onscreen_events_queue);
 
-  _cogl_closure_disconnect (context->onscreen_dispatch_idle);
-  context->onscreen_dispatch_idle = NULL;
+  g_clear_pointer (&context->onscreen_dispatch_idle,
+                   _cogl_closure_disconnect);
 
   _cogl_list_for_each_safe (event, tmp, &queue, link)
     {
@@ -202,7 +208,7 @@ _cogl_dispatch_onscreen_cb (CoglContext *context)
 
       notify_event (onscreen, event->type, info);
 
-      cogl_object_unref (onscreen);
+      g_object_unref (onscreen);
       cogl_object_unref (info);
 
       g_slice_free (CoglOnscreenEvent, event);
@@ -222,7 +228,7 @@ _cogl_dispatch_onscreen_cb (CoglContext *context)
                                  qe->onscreen,
                                  &qe->info);
 
-      cogl_object_unref (qe->onscreen);
+      g_object_unref (qe->onscreen);
 
       g_slice_free (CoglOnscreenQueuedDirty, qe);
     }
@@ -231,7 +237,8 @@ _cogl_dispatch_onscreen_cb (CoglContext *context)
 static void
 _cogl_onscreen_queue_dispatch_idle (CoglOnscreen *onscreen)
 {
-  CoglContext *ctx = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
   if (!ctx->onscreen_dispatch_idle)
     {
@@ -248,10 +255,11 @@ void
 _cogl_onscreen_queue_dirty (CoglOnscreen *onscreen,
                             const CoglOnscreenDirtyInfo *info)
 {
-  CoglContext *ctx = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglOnscreenQueuedDirty *qe = g_slice_new (CoglOnscreenQueuedDirty);
 
-  qe->onscreen = cogl_object_ref (onscreen);
+  qe->onscreen = g_object_ref (onscreen);
   qe->info = *info;
   _cogl_list_insert (ctx->onscreen_dirty_queue.prev, &qe->link);
 
@@ -266,8 +274,8 @@ _cogl_onscreen_queue_full_dirty (CoglOnscreen *onscreen)
 
   info.x = 0;
   info.y = 0;
-  info.width = framebuffer->width;
-  info.height = framebuffer->height;
+  info.width = cogl_framebuffer_get_width (framebuffer);
+  info.height = cogl_framebuffer_get_height (framebuffer);
 
   _cogl_onscreen_queue_dirty (onscreen, &info);
 }
@@ -277,11 +285,12 @@ _cogl_onscreen_queue_event (CoglOnscreen *onscreen,
                             CoglFrameEvent type,
                             CoglFrameInfo *info)
 {
-  CoglContext *ctx = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
   CoglOnscreenEvent *event = g_slice_new (CoglOnscreenEvent);
 
-  event->onscreen = cogl_object_ref (onscreen);
+  event->onscreen = g_object_ref (onscreen);
   event->info = cogl_object_ref (info);
   event->type = type;
 
@@ -299,7 +308,7 @@ cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
 
-  g_return_if_fail  (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN);
+  g_return_if_fail  (COGL_IS_ONSCREEN (framebuffer));
 
   info->frame_counter = onscreen->frame_counter;
   g_queue_push_tail (&onscreen->pending_frame_infos, info);
@@ -348,7 +357,7 @@ cogl_onscreen_swap_region (CoglOnscreen *onscreen,
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
 
-  g_return_if_fail  (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN);
+  g_return_if_fail  (COGL_IS_ONSCREEN (framebuffer));
 
   info->frame_counter = onscreen->frame_counter;
   g_queue_push_tail (&onscreen->pending_frame_infos, info);
@@ -394,7 +403,7 @@ cogl_onscreen_get_buffer_age (CoglOnscreen *onscreen)
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
 
-  g_return_val_if_fail  (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN, 0);
+  g_return_val_if_fail (COGL_IS_ONSCREEN (framebuffer), 0);
 
   winsys = _cogl_framebuffer_get_winsys (framebuffer);
 
@@ -413,7 +422,7 @@ cogl_onscreen_direct_scanout (CoglOnscreen   *onscreen,
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
 
-  g_warn_if_fail (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN);
+  g_warn_if_fail (COGL_IS_ONSCREEN (framebuffer));
   g_warn_if_fail (_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT));
 
   info->frame_counter = onscreen->frame_counter;
@@ -471,7 +480,7 @@ cogl_onscreen_show (CoglOnscreen *onscreen)
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   const CoglWinsysVtable *winsys;
 
-  if (!framebuffer->allocated)
+  if (!cogl_framebuffer_is_allocated (framebuffer))
     {
       if (!cogl_framebuffer_allocate (framebuffer, NULL))
         return;
@@ -487,7 +496,7 @@ cogl_onscreen_hide (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
 
-  if (framebuffer->allocated)
+  if (cogl_framebuffer_is_allocated (framebuffer))
     {
       const CoglWinsysVtable *winsys =
         _cogl_framebuffer_get_winsys (framebuffer);
@@ -516,23 +525,21 @@ _cogl_onscreen_notify_resize (CoglOnscreen *onscreen)
   _cogl_closure_list_invoke (&onscreen->resize_closures,
                              CoglOnscreenResizeCallback,
                              onscreen,
-                             framebuffer->width,
-                             framebuffer->height);
+                             cogl_framebuffer_get_width (framebuffer),
+                             cogl_framebuffer_get_height (framebuffer));
 }
 
 void
 _cogl_framebuffer_winsys_update_size (CoglFramebuffer *framebuffer,
                                       int width, int height)
 {
-  if (framebuffer->width == width && framebuffer->height == height)
+  if (cogl_framebuffer_get_width (framebuffer) == width &&
+      cogl_framebuffer_get_height (framebuffer) == height)
     return;
 
-  framebuffer->width = width;
-  framebuffer->height = height;
-
-  cogl_framebuffer_set_viewport (framebuffer, 0, 0, width, height);
+  cogl_framebuffer_update_size (framebuffer, width, height);
 
-  if (!_cogl_has_private_feature (framebuffer->context,
+  if (!_cogl_has_private_feature (cogl_framebuffer_get_context (framebuffer),
                                   COGL_PRIVATE_FEATURE_DIRTY_EVENTS))
     _cogl_onscreen_queue_full_dirty (COGL_ONSCREEN (framebuffer));
 }
@@ -550,7 +557,7 @@ cogl_onscreen_set_resizable (CoglOnscreen *onscreen,
   onscreen->resizable = resizable;
 
   framebuffer = COGL_FRAMEBUFFER (onscreen);
-  if (framebuffer->allocated)
+  if (cogl_framebuffer_is_allocated (framebuffer))
     {
       winsys = _cogl_framebuffer_get_winsys (COGL_FRAMEBUFFER (onscreen));
 
diff --git a/cogl/cogl/cogl-onscreen.h b/cogl/cogl/cogl-onscreen.h
index 824672f5efb835267c21475eae7a4300a1c96ab9..66f8c82f6104d668d97884507c280fadfff623f5 100644
--- a/cogl/cogl/cogl-onscreen.h
+++ b/cogl/cogl/cogl-onscreen.h
@@ -47,19 +47,14 @@
 
 G_BEGIN_DECLS
 
-typedef struct _CoglOnscreen CoglOnscreen;
-#define COGL_ONSCREEN(X) ((CoglOnscreen *)(X))
+#define COGL_TYPE_ONSCREEN (cogl_onscreen_get_type ())
+COGL_EXPORT
+G_DECLARE_FINAL_TYPE (CoglOnscreen, cogl_onscreen,
+                      COGL, ONSCREEN,
+                      CoglFramebuffer)
 
 typedef struct _CoglScanout CoglScanout;
 
-/**
- * cogl_onscreen_get_gtype:
- *
- * Returns: a #GType that can be used with the GLib type system.
- */
-COGL_EXPORT
-GType cogl_onscreen_get_gtype (void);
-
 /**
  * cogl_onscreen_new: (constructor) (skip)
  * @context: A #CoglContext
@@ -750,20 +745,6 @@ COGL_EXPORT void
 cogl_onscreen_remove_dirty_callback (CoglOnscreen *onscreen,
                                      CoglOnscreenDirtyClosure *closure);
 
-/**
- * cogl_is_onscreen:
- * @object: A #CoglObject pointer
- *
- * Gets whether the given object references a #CoglOnscreen.
- *
- * Return value: %TRUE if the object references a #CoglOnscreen
- *   and %FALSE otherwise.
- * Since: 1.10
- * Stability: unstable
- */
-COGL_EXPORT gboolean
-cogl_is_onscreen (void *object);
-
 /**
  * cogl_onscreen_get_frame_counter:
  *
diff --git a/cogl/cogl/cogl-primitives.c b/cogl/cogl/cogl-primitives.c
index 71a7ca5d20b12df467a066e60c4874d84dde2fe0..03e1d54c490c2f6a2862771155807264faa7e7d2 100644
--- a/cogl/cogl/cogl-primitives.c
+++ b/cogl/cogl/cogl-primitives.c
@@ -123,7 +123,7 @@ log_quad_sub_textures_cb (CoglTexture *texture,
   else
     texture_override = texture;
 
-  _cogl_journal_log_quad (framebuffer->journal,
+  _cogl_journal_log_quad (cogl_framebuffer_get_journal (framebuffer),
                           quad_coords,
                           state->pipeline,
                           1, /* one layer */
@@ -458,7 +458,7 @@ _cogl_multitexture_quad_single_primitive (CoglFramebuffer *framebuffer,
   if (state.override_pipeline)
     pipeline = state.override_pipeline;
 
-  _cogl_journal_log_quad (framebuffer->journal,
+  _cogl_journal_log_quad (cogl_framebuffer_get_journal (framebuffer),
                           position,
                           pipeline,
                           n_layers,
@@ -631,7 +631,7 @@ _cogl_framebuffer_draw_multitextured_rectangles (
                                         CoglMultiTexturedRect *rects,
                                         int n_rects)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglPipeline *original_pipeline;
   ValidateLayerState state;
   int i;
@@ -714,7 +714,7 @@ cogl_2d_primitives_immediate (CoglFramebuffer *framebuffer,
                               const CoglVertexP2 *vertices,
                               unsigned int n_vertices)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglAttributeBuffer *attribute_buffer;
   CoglAttribute *attributes[1];
   size_t vertices_size = sizeof (CoglVertexP2) * n_vertices;
diff --git a/cogl/cogl/cogl-texture.c b/cogl/cogl/cogl-texture.c
index f69dfc161456e5bbb93dd17668dd5b4ade6e2065..8a7ec49b29870a62b5dafecb32ae3340f3d346d0 100644
--- a/cogl/cogl/cogl-texture.c
+++ b/cogl/cogl/cogl-texture.c
@@ -579,7 +579,7 @@ get_texture_bits_via_offscreen (CoglTexture *meta_texture,
 
   cogl_object_unref (bitmap);
 
-  cogl_object_unref (framebuffer);
+  g_object_unref (framebuffer);
 
   return ret;
 }
@@ -892,31 +892,23 @@ cogl_texture_get_data (CoglTexture *texture,
 }
 
 static void
-_cogl_texture_framebuffer_destroy_cb (void *user_data,
-                                      void *instance)
+on_framebuffer_destroy (CoglFramebuffer *framebuffer,
+                        CoglTexture     *texture)
 {
-  CoglTexture *tex = user_data;
-  CoglFramebuffer *framebuffer = instance;
-
-  tex->framebuffers = g_list_remove (tex->framebuffers, framebuffer);
+  texture->framebuffers = g_list_remove (texture->framebuffers, framebuffer);
 }
 
 void
 _cogl_texture_associate_framebuffer (CoglTexture *texture,
                                      CoglFramebuffer *framebuffer)
 {
-  static CoglUserDataKey framebuffer_destroy_notify_key;
-
   /* Note: we don't take a reference on the framebuffer here because
    * that would introduce a circular reference. */
   texture->framebuffers = g_list_prepend (texture->framebuffers, framebuffer);
 
-  /* Since we haven't taken a reference on the framebuffer we setup
-    * some private data so we will be notified if it is destroyed... */
-  _cogl_object_set_user_data (COGL_OBJECT (framebuffer),
-                              &framebuffer_destroy_notify_key,
-                              texture,
-                              _cogl_texture_framebuffer_destroy_cb);
+  g_signal_connect (framebuffer, "destroy",
+                    G_CALLBACK (on_framebuffer_destroy),
+                    texture);
 }
 
 const GList *
diff --git a/cogl/cogl/cogl-types.h b/cogl/cogl/cogl-types.h
index d6856bd2e9657aeb176d450210ee84bff387b390..30c908b64040d4296403279bcb764d502045df61 100644
--- a/cogl/cogl/cogl-types.h
+++ b/cogl/cogl/cogl-types.h
@@ -86,6 +86,8 @@ typedef void * CoglHandle;
 COGL_EXPORT GType
 cogl_handle_get_type (void) G_GNUC_CONST;
 
+typedef struct _CoglFramebuffer CoglFramebuffer;
+
 /**
  * CoglAngle:
  *
diff --git a/cogl/cogl/deprecated/cogl-type-casts.h b/cogl/cogl/deprecated/cogl-type-casts.h
index c35ea056beff8547974dbf8abaefa0c2527c9a9e..4ea811011335b5f443e43d8666216e4facc68520 100644
--- a/cogl/cogl/deprecated/cogl-type-casts.h
+++ b/cogl/cogl/deprecated/cogl-type-casts.h
@@ -45,7 +45,6 @@
  */
 
 #if !defined(COGL_ENABLE_MUTTER_API) && !defined(COGL_GIR_SCANNING)
-#define COGL_FRAMEBUFFER(X) (X)
 #define COGL_BUFFER(X) (X)
 #define COGL_TEXTURE(X) (X)
 #define COGL_META_TEXTURE(X) (X)
diff --git a/cogl/cogl/driver/gl/cogl-attribute-gl.c b/cogl/cogl/driver/gl/cogl-attribute-gl.c
index 620992dfb1f8572ee6c056bd6b2e3e6978ddcc36..3475569ffa26144f32dd6cb9a8809b5011cc6908 100644
--- a/cogl/cogl/driver/gl/cogl-attribute-gl.c
+++ b/cogl/cogl/driver/gl/cogl-attribute-gl.c
@@ -186,7 +186,7 @@ _cogl_gl_flush_attributes_state (CoglFramebuffer *framebuffer,
                                  CoglAttribute **attributes,
                                  int n_attributes)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   int i;
   gboolean with_color_attrib = FALSE;
   gboolean unknown_color_alpha = FALSE;
diff --git a/cogl/cogl/driver/gl/cogl-clip-stack-gl.c b/cogl/cogl/driver/gl/cogl-clip-stack-gl.c
index c528365979f355b86e9078502fd6cf484a5e5f88..3f2b98ba1aeb32e2ad7c1e693f1becabc76eff48 100644
--- a/cogl/cogl/driver/gl/cogl-clip-stack-gl.c
+++ b/cogl/cogl/driver/gl/cogl-clip-stack-gl.c
@@ -153,14 +153,14 @@ add_stencil_clip_region (CoglFramebuffer *framebuffer,
    * the default [-1, -1, 1, 1] range.
    */
   graphene_point3d_init (&p,
-                         - framebuffer->viewport_x,
-                         - framebuffer->viewport_y,
+                         - cogl_framebuffer_get_viewport_x (framebuffer),
+                         - cogl_framebuffer_get_viewport_y (framebuffer),
                          0);
 
   graphene_matrix_init_translate (&matrix, &p);
   graphene_matrix_scale (&matrix,
-                         2.0 / framebuffer->viewport_width,
-                         - 2.0 / framebuffer->viewport_height,
+                         2.0 / cogl_framebuffer_get_viewport_width (framebuffer),
+                         - 2.0 / cogl_framebuffer_get_viewport_height (framebuffer),
                          1);
   graphene_matrix_translate (&matrix, &GRAPHENE_POINT3D_INIT (-1.f, 1.f, 0.f));
 
@@ -398,7 +398,7 @@ void
 _cogl_clip_stack_gl_flush (CoglClipStack *stack,
                            CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   gboolean using_stencil_buffer = FALSE;
   int scissor_x0;
   int scissor_y0;
@@ -453,7 +453,7 @@ _cogl_clip_stack_gl_flush (CoglClipStack *stack,
        * down so in this case no conversion is needed.
        */
 
-      if (cogl_is_offscreen (framebuffer))
+      if (COGL_IS_OFFSCREEN (framebuffer))
         scissor_y_start = scissor_y0;
       else
         {
diff --git a/cogl/cogl/driver/gl/cogl-framebuffer-gl.c b/cogl/cogl/driver/gl/cogl-framebuffer-gl.c
index 520beaf17eac7d33b26ba7e0b4b09502ef52db66..a95991d67785895e4f2663aaf675c58bd0b55597 100644
--- a/cogl/cogl/driver/gl/cogl-framebuffer-gl.c
+++ b/cogl/cogl/driver/gl/cogl-framebuffer-gl.c
@@ -33,6 +33,7 @@
 
 #include "cogl-context-private.h"
 #include "cogl-framebuffer-private.h"
+#include "cogl-framebuffer.h"
 #include "cogl-texture-private.h"
 #include "driver/gl/cogl-util-gl-private.h"
 #include "driver/gl/cogl-framebuffer-gl-private.h"
@@ -126,82 +127,100 @@
 #define GL_STENCIL 0x1802
 #endif
 
+typedef struct _CoglFramebufferGl
+{
+  gboolean dirty_bitmasks;
+  CoglFramebufferBits bits;
+} CoglFramebufferGl;
 
 static void
 _cogl_framebuffer_gl_flush_viewport_state (CoglFramebuffer *framebuffer)
 {
+  float viewport_x, viewport_y, viewport_width, viewport_height;
   float gl_viewport_y;
 
-  g_return_if_fail (framebuffer->viewport_width >= 0);
-  g_return_if_fail (framebuffer->viewport_height >= 0);
+  cogl_framebuffer_get_viewport4f (framebuffer,
+                                   &viewport_x,
+                                   &viewport_y,
+                                   &viewport_width,
+                                   &viewport_height);
+
+  g_return_if_fail (viewport_width >= 0);
+  g_return_if_fail (viewport_height >= 0);
 
   /* Convert the Cogl viewport y offset to an OpenGL viewport y offset
    * NB: OpenGL defines its window and viewport origins to be bottom
    * left, while Cogl defines them to be top left.
    * NB: We render upside down to offscreen framebuffers so we don't
    * need to convert the y offset in this case. */
-  if (cogl_is_offscreen (framebuffer))
-    gl_viewport_y = framebuffer->viewport_y;
+  if (COGL_IS_OFFSCREEN (framebuffer))
+    gl_viewport_y = viewport_y;
   else
-    gl_viewport_y = framebuffer->height -
-      (framebuffer->viewport_y + framebuffer->viewport_height);
+    gl_viewport_y =
+      cogl_framebuffer_get_height (framebuffer) -
+      (viewport_y + viewport_height);
 
   COGL_NOTE (OPENGL, "Calling glViewport(%f, %f, %f, %f)",
-             framebuffer->viewport_x,
+             viewport_x,
              gl_viewport_y,
-             framebuffer->viewport_width,
-             framebuffer->viewport_height);
+             viewport_width,
+             viewport_height);
 
-  GE (framebuffer->context,
-      glViewport (framebuffer->viewport_x,
+  GE (cogl_framebuffer_get_context (framebuffer),
+      glViewport (viewport_x,
                   gl_viewport_y,
-                  framebuffer->viewport_width,
-                  framebuffer->viewport_height));
+                  viewport_width,
+                  viewport_height));
 }
 
 static void
 _cogl_framebuffer_gl_flush_clip_state (CoglFramebuffer *framebuffer)
 {
-  _cogl_clip_stack_flush (framebuffer->clip_stack, framebuffer);
+  _cogl_clip_stack_flush (_cogl_framebuffer_get_clip_stack (framebuffer),
+                          framebuffer);
 }
 
 static void
 _cogl_framebuffer_gl_flush_dither_state (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
+  gboolean is_dither_enabled =
+    cogl_framebuffer_get_dither_enabled (framebuffer);
 
-  if (ctx->current_gl_dither_enabled != framebuffer->dither_enabled)
+  if (ctx->current_gl_dither_enabled != is_dither_enabled)
     {
-      if (framebuffer->dither_enabled)
+      if (is_dither_enabled)
         GE (ctx, glEnable (GL_DITHER));
       else
         GE (ctx, glDisable (GL_DITHER));
-      ctx->current_gl_dither_enabled = framebuffer->dither_enabled;
+      ctx->current_gl_dither_enabled = is_dither_enabled;
     }
 }
 
 static void
 _cogl_framebuffer_gl_flush_modelview_state (CoglFramebuffer *framebuffer)
 {
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglMatrixEntry *modelview_entry =
     _cogl_framebuffer_get_modelview_entry (framebuffer);
-  _cogl_context_set_current_modelview_entry (framebuffer->context,
-                                             modelview_entry);
+
+  _cogl_context_set_current_modelview_entry (ctx, modelview_entry);
 }
 
 static void
 _cogl_framebuffer_gl_flush_projection_state (CoglFramebuffer *framebuffer)
 {
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglMatrixEntry *projection_entry =
     _cogl_framebuffer_get_projection_entry (framebuffer);
-  _cogl_context_set_current_projection_entry (framebuffer->context,
-                                             projection_entry);
+
+  _cogl_context_set_current_projection_entry (ctx, projection_entry);
 }
 
 static void
 _cogl_framebuffer_gl_flush_front_face_winding_state (CoglFramebuffer *framebuffer)
 {
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglPipelineCullFaceMode mode;
 
   /* NB: The face winding state is actually owned by the current
@@ -233,10 +252,10 @@ _cogl_framebuffer_gl_flush_front_face_winding_state (CoglFramebuffer *framebuffe
 static void
 _cogl_framebuffer_gl_flush_stereo_mode_state (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   GLenum draw_buffer = GL_BACK;
 
-  if (framebuffer->type == COGL_FRAMEBUFFER_TYPE_OFFSCREEN)
+  if (COGL_IS_OFFSCREEN (framebuffer))
     return;
 
   if (!ctx->glDrawBuffer)
@@ -246,7 +265,7 @@ _cogl_framebuffer_gl_flush_stereo_mode_state (CoglFramebuffer *framebuffer)
    * must have already happened. If not it would override what we set here. */
   g_assert (ctx->was_bound_to_onscreen);
 
-  switch (framebuffer->stereo_mode)
+  switch (cogl_framebuffer_get_stereo_mode (framebuffer))
     {
     case COGL_STEREO_BOTH:
       draw_buffer = GL_BACK;
@@ -269,9 +288,9 @@ _cogl_framebuffer_gl_flush_stereo_mode_state (CoglFramebuffer *framebuffer)
 void
 _cogl_framebuffer_gl_bind (CoglFramebuffer *framebuffer, GLenum target)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
-  if (framebuffer->type == COGL_FRAMEBUFFER_TYPE_OFFSCREEN)
+  if (COGL_IS_OFFSCREEN (framebuffer))
     {
       CoglOffscreen *offscreen = COGL_OFFSCREEN (framebuffer);
       GE (ctx, glBindFramebuffer (target,
@@ -320,7 +339,7 @@ _cogl_framebuffer_gl_flush_state (CoglFramebuffer *draw_buffer,
                                   CoglFramebuffer *read_buffer,
                                   CoglFramebufferState state)
 {
-  CoglContext *ctx = draw_buffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (draw_buffer);
   unsigned long differences;
   int bit;
 
@@ -372,9 +391,9 @@ _cogl_framebuffer_gl_flush_state (CoglFramebuffer *draw_buffer,
     return;
 
   /* Lazily ensure the framebuffers have been allocated */
-  if (G_UNLIKELY (!draw_buffer->allocated))
+  if (G_UNLIKELY (!cogl_framebuffer_is_allocated (draw_buffer)))
     cogl_framebuffer_allocate (draw_buffer, NULL);
-  if (G_UNLIKELY (!read_buffer->allocated))
+  if (G_UNLIKELY (!cogl_framebuffer_is_allocated (read_buffer)))
     cogl_framebuffer_allocate (read_buffer, NULL);
 
   /* We handle buffer binding separately since the method depends on whether
@@ -617,15 +636,15 @@ delete_renderbuffers (CoglContext *ctx, GList *renderbuffers)
  * modify anything in
  */
 static gboolean
-try_creating_fbo (CoglContext *ctx,
-                  CoglTexture *texture,
-                  int texture_level,
-                  int texture_level_width,
-                  int texture_level_height,
-                  CoglTexture *depth_texture,
-                  CoglFramebufferConfig *config,
-                  CoglOffscreenAllocateFlags flags,
-                  CoglGLFramebuffer *gl_framebuffer)
+try_creating_fbo (CoglContext                 *ctx,
+                  CoglTexture                 *texture,
+                  int                          texture_level,
+                  int                          texture_level_width,
+                  int                          texture_level_height,
+                  CoglTexture                 *depth_texture,
+                  const CoglFramebufferConfig *config,
+                  CoglOffscreenAllocateFlags   flags,
+                  CoglGLFramebuffer           *gl_framebuffer)
 {
   GLuint tex_gl_handle;
   GLenum tex_gl_target;
@@ -734,10 +753,11 @@ gboolean
 _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                              GError **error)
 {
-  CoglFramebuffer *fb = COGL_FRAMEBUFFER (offscreen);
-  CoglContext *ctx = fb->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (offscreen);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglOffscreenAllocateFlags flags;
   CoglGLFramebuffer *gl_framebuffer = &offscreen->gl_framebuffer;
+  const CoglFramebufferConfig *config;
   int level_width;
   int level_height;
 
@@ -764,6 +784,8 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
   _cogl_texture_gl_flush_legacy_texobj_filters (offscreen->texture,
                                                 GL_NEAREST, GL_NEAREST);
 
+  config = cogl_framebuffer_get_config (framebuffer);
+
   if (((offscreen->create_flags & COGL_OFFSCREEN_DISABLE_DEPTH_AND_STENCIL) &&
        try_creating_fbo (ctx,
                          offscreen->texture,
@@ -771,7 +793,7 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                          level_width,
                          level_height,
                          offscreen->depth_texture,
-                         &fb->config,
+                         config,
                          flags = 0,
                          gl_framebuffer)) ||
 
@@ -782,7 +804,7 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                          level_width,
                          level_height,
                          offscreen->depth_texture,
-                         &fb->config,
+                         config,
                          flags = ctx->last_offscreen_allocate_flags,
                          gl_framebuffer)) ||
 
@@ -799,7 +821,7 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                          level_width,
                          level_height,
                          offscreen->depth_texture,
-                         &fb->config,
+                         config,
                          flags = COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH_STENCIL,
                          gl_framebuffer)) ||
 
@@ -809,7 +831,7 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                         level_width,
                         level_height,
                         offscreen->depth_texture,
-                        &fb->config,
+                        config,
                         flags = COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH |
                         COGL_OFFSCREEN_ALLOCATE_FLAG_STENCIL,
                         gl_framebuffer) ||
@@ -820,7 +842,7 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                         level_width,
                         level_height,
                         offscreen->depth_texture,
-                        &fb->config,
+                        config,
                         flags = COGL_OFFSCREEN_ALLOCATE_FLAG_STENCIL,
                         gl_framebuffer) ||
 
@@ -830,7 +852,7 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                         level_width,
                         level_height,
                         offscreen->depth_texture,
-                        &fb->config,
+                        config,
                         flags = COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH,
                         gl_framebuffer) ||
 
@@ -840,11 +862,12 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
                         level_width,
                         level_height,
                         offscreen->depth_texture,
-                        &fb->config,
+                        config,
                         flags = 0,
                         gl_framebuffer))
     {
-      fb->samples_per_pixel = gl_framebuffer->samples_per_pixel;
+      cogl_framebuffer_update_samples_per_pixel (framebuffer,
+                                                 gl_framebuffer->samples_per_pixel);
 
       if (!(offscreen->create_flags & COGL_OFFSCREEN_DISABLE_DEPTH_AND_STENCIL))
         {
@@ -873,7 +896,8 @@ _cogl_offscreen_gl_allocate (CoglOffscreen *offscreen,
 void
 _cogl_offscreen_gl_free (CoglOffscreen *offscreen)
 {
-  CoglContext *ctx = COGL_FRAMEBUFFER (offscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (offscreen);
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
   delete_renderbuffers (ctx, offscreen->gl_framebuffer.renderbuffers);
 
@@ -888,7 +912,7 @@ _cogl_framebuffer_gl_clear (CoglFramebuffer *framebuffer,
                             float blue,
                             float alpha)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   GLbitfield gl_buffers = 0;
 
   if (buffers & COGL_BUFFER_BIT_COLOR)
@@ -899,13 +923,17 @@ _cogl_framebuffer_gl_clear (CoglFramebuffer *framebuffer,
 
   if (buffers & COGL_BUFFER_BIT_DEPTH)
     {
+      gboolean is_depth_writing_enabled;
+
       gl_buffers |= GL_DEPTH_BUFFER_BIT;
 
-      if (ctx->depth_writing_enabled_cache != framebuffer->depth_writing_enabled)
+      is_depth_writing_enabled =
+        cogl_framebuffer_get_depth_write_enabled (framebuffer);
+      if (ctx->depth_writing_enabled_cache != is_depth_writing_enabled)
         {
-          GE( ctx, glDepthMask (framebuffer->depth_writing_enabled));
+          GE( ctx, glDepthMask (is_depth_writing_enabled));
 
-          ctx->depth_writing_enabled_cache = framebuffer->depth_writing_enabled;
+          ctx->depth_writing_enabled_cache = is_depth_writing_enabled;
 
           /* Make sure the DepthMask is updated when the next primitive is drawn */
           ctx->current_pipeline_changes_since_flush |=
@@ -921,12 +949,33 @@ _cogl_framebuffer_gl_clear (CoglFramebuffer *framebuffer,
   GE (ctx, glClear (gl_buffers));
 }
 
+static CoglFramebufferGl *
+ensure_framebuffer_gl (CoglFramebuffer *framebuffer)
+{
+  CoglFramebufferGl *framebuffer_gl;
+
+  framebuffer_gl = cogl_framebuffer_get_driver_private (framebuffer);
+  if (!framebuffer_gl)
+    {
+      framebuffer_gl = g_new0 (CoglFramebufferGl, 1);
+      cogl_framebuffer_set_driver_private (framebuffer,
+                                           framebuffer_gl,
+                                           g_free);
+      framebuffer_gl->dirty_bitmasks = TRUE;
+    }
+
+  return framebuffer_gl;
+}
+
 static inline void
 _cogl_framebuffer_init_bits (CoglFramebuffer *framebuffer)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
+  CoglFramebufferGl *framebuffer_gl;
 
-  if (G_LIKELY (!framebuffer->dirty_bitmasks))
+  framebuffer_gl = ensure_framebuffer_gl (framebuffer);
+
+  if (!framebuffer_gl->dirty_bitmasks)
     return;
 
   cogl_framebuffer_allocate (framebuffer, NULL);
@@ -937,11 +986,11 @@ _cogl_framebuffer_init_bits (CoglFramebuffer *framebuffer)
 
 #ifdef HAVE_COGL_GL
   if ((ctx->driver == COGL_DRIVER_GL3 &&
-       framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN) ||
+       COGL_IS_ONSCREEN (framebuffer)) ||
       (_cogl_has_private_feature (ctx, COGL_PRIVATE_FEATURE_QUERY_FRAMEBUFFER_BITS) &&
-       framebuffer->type == COGL_FRAMEBUFFER_TYPE_OFFSCREEN))
+       COGL_IS_OFFSCREEN (framebuffer)))
     {
-      gboolean is_offscreen = framebuffer->type == COGL_FRAMEBUFFER_TYPE_OFFSCREEN;
+      gboolean is_offscreen = COGL_IS_OFFSCREEN (framebuffer);
       const struct {
         GLenum attachment, pname;
         size_t offset;
@@ -970,7 +1019,7 @@ _cogl_framebuffer_init_bits (CoglFramebuffer *framebuffer)
       for (i = 0; i < G_N_ELEMENTS (params); i++)
         {
           int *value =
-            (int *) ((uint8_t *) &framebuffer->bits + params[i].offset);
+            (int *) ((uint8_t *) &framebuffer_gl->bits + params[i].offset);
           GE( ctx, glGetFramebufferAttachmentParameteriv (GL_FRAMEBUFFER,
                                                           params[i].attachment,
                                                           params[i].pname,
@@ -980,75 +1029,76 @@ _cogl_framebuffer_init_bits (CoglFramebuffer *framebuffer)
   else
 #endif /* HAVE_COGL_GL */
     {
-      GE( ctx, glGetIntegerv (GL_RED_BITS,   &framebuffer->bits.red)   );
-      GE( ctx, glGetIntegerv (GL_GREEN_BITS, &framebuffer->bits.green) );
-      GE( ctx, glGetIntegerv (GL_BLUE_BITS,  &framebuffer->bits.blue)  );
-      GE( ctx, glGetIntegerv (GL_ALPHA_BITS, &framebuffer->bits.alpha) );
-      GE( ctx, glGetIntegerv (GL_DEPTH_BITS, &framebuffer->bits.depth) );
-      GE( ctx, glGetIntegerv (GL_STENCIL_BITS, &framebuffer->bits.stencil) );
+      GE( ctx, glGetIntegerv (GL_RED_BITS,   &framebuffer_gl->bits.red)   );
+      GE( ctx, glGetIntegerv (GL_GREEN_BITS, &framebuffer_gl->bits.green) );
+      GE( ctx, glGetIntegerv (GL_BLUE_BITS,  &framebuffer_gl->bits.blue)  );
+      GE( ctx, glGetIntegerv (GL_ALPHA_BITS, &framebuffer_gl->bits.alpha) );
+      GE( ctx, glGetIntegerv (GL_DEPTH_BITS, &framebuffer_gl->bits.depth) );
+      GE( ctx, glGetIntegerv (GL_STENCIL_BITS, &framebuffer_gl->bits.stencil) );
     }
 
   /* If we don't have alpha textures then the alpha bits are actually
    * stored in the red component */
   if (!_cogl_has_private_feature (ctx, COGL_PRIVATE_FEATURE_ALPHA_TEXTURES) &&
-      framebuffer->type == COGL_FRAMEBUFFER_TYPE_OFFSCREEN &&
-      framebuffer->internal_format == COGL_PIXEL_FORMAT_A_8)
+      COGL_IS_OFFSCREEN (framebuffer) &&
+      cogl_framebuffer_get_internal_format (framebuffer) == COGL_PIXEL_FORMAT_A_8)
     {
-      framebuffer->bits.alpha = framebuffer->bits.red;
-      framebuffer->bits.red = 0;
+      framebuffer_gl->bits.alpha = framebuffer_gl->bits.red;
+      framebuffer_gl->bits.red = 0;
     }
 
   COGL_NOTE (OFFSCREEN,
              "RGBA/D/S Bits for framebuffer[%p, %s]: %d, %d, %d, %d, %d, %d",
              framebuffer,
-             framebuffer->type == COGL_FRAMEBUFFER_TYPE_OFFSCREEN
-               ? "offscreen"
-               : "onscreen",
-             framebuffer->bits.red,
-             framebuffer->bits.blue,
-             framebuffer->bits.green,
-             framebuffer->bits.alpha,
-             framebuffer->bits.depth,
-             framebuffer->bits.stencil);
-
-  framebuffer->dirty_bitmasks = FALSE;
+             COGL_IS_OFFSCREEN (framebuffer) ? "offscreen" : "onscreen",
+             framebuffer_gl->bits.red,
+             framebuffer_gl->bits.blue,
+             framebuffer_gl->bits.green,
+             framebuffer_gl->bits.alpha,
+             framebuffer_gl->bits.depth,
+             framebuffer_gl->bits.stencil);
+
+  framebuffer_gl->dirty_bitmasks = FALSE;
 }
 
 void
 _cogl_framebuffer_gl_query_bits (CoglFramebuffer *framebuffer,
                                  CoglFramebufferBits *bits)
 {
+  CoglFramebufferGl *framebuffer_gl;
+
   _cogl_framebuffer_init_bits (framebuffer);
 
   /* TODO: cache these in some driver specific location not
    * directly as part of CoglFramebuffer. */
-  *bits = framebuffer->bits;
+  framebuffer_gl = ensure_framebuffer_gl (framebuffer);
+  *bits = framebuffer_gl->bits;
 }
 
 void
 _cogl_framebuffer_gl_finish (CoglFramebuffer *framebuffer)
 {
-  GE (framebuffer->context, glFinish ());
+  GE (cogl_framebuffer_get_context (framebuffer), glFinish ());
 }
 
 void
 _cogl_framebuffer_gl_flush (CoglFramebuffer *framebuffer)
 {
-  GE (framebuffer->context, glFlush ());
+  GE (cogl_framebuffer_get_context (framebuffer), glFlush ());
 }
 
 void
 _cogl_framebuffer_gl_discard_buffers (CoglFramebuffer *framebuffer,
                                       unsigned long buffers)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
   if (ctx->glDiscardFramebuffer)
     {
       GLenum attachments[3];
       int i = 0;
 
-      if (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN)
+      if (COGL_IS_ONSCREEN (framebuffer))
         {
           if (buffers & COGL_BUFFER_BIT_COLOR)
             attachments[i++] = GL_COLOR;
@@ -1087,7 +1137,7 @@ _cogl_framebuffer_gl_draw_attributes (CoglFramebuffer *framebuffer,
   _cogl_flush_attributes_state (framebuffer, pipeline, flags,
                                 attributes, n_attributes);
 
-  GE (framebuffer->context,
+  GE (cogl_framebuffer_get_context (framebuffer),
       glDrawArrays ((GLenum)mode, first_vertex, n_vertices));
 }
 
@@ -1151,7 +1201,7 @@ _cogl_framebuffer_gl_draw_indexed_attributes (CoglFramebuffer *framebuffer,
       break;
     }
 
-  GE (framebuffer->context,
+  GE (cogl_framebuffer_get_context (framebuffer),
       glDrawElements ((GLenum)mode,
                       n_vertices,
                       indices_gl_type,
@@ -1168,11 +1218,13 @@ _cogl_framebuffer_gl_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
                                               CoglBitmap *bitmap,
                                               GError **error)
 {
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   int framebuffer_height = cogl_framebuffer_get_height (framebuffer);
   int width = cogl_bitmap_get_width (bitmap);
   int height = cogl_bitmap_get_height (bitmap);
   CoglPixelFormat format = cogl_bitmap_get_format (bitmap);
+  CoglPixelFormat internal_format =
+    cogl_framebuffer_get_internal_format (framebuffer);
   CoglPixelFormat required_format;
   GLenum gl_intformat;
   GLenum gl_format;
@@ -1193,7 +1245,7 @@ _cogl_framebuffer_gl_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
    * NB: all offscreen rendering is done upside down so no conversion
    * is necissary in this case.
    */
-  if (!cogl_is_offscreen (framebuffer))
+  if (!COGL_IS_OFFSCREEN (framebuffer))
     y = framebuffer_height - y - height;
 
   required_format = ctx->driver_vtable->pixel_format_to_gl (ctx,
@@ -1206,7 +1258,7 @@ _cogl_framebuffer_gl_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
    * to flip in this case... */
   if (_cogl_has_private_feature (ctx, COGL_PRIVATE_FEATURE_MESA_PACK_INVERT) &&
       (source & COGL_READ_PIXELS_NO_FLIP) == 0 &&
-      !cogl_is_offscreen (framebuffer))
+      !COGL_IS_OFFSCREEN (framebuffer))
     {
       if (ctx->driver == COGL_DRIVER_GLES2)
         gl_pack_enum = GL_PACK_REVERSE_ROW_ORDER_ANGLE;
@@ -1252,8 +1304,10 @@ _cogl_framebuffer_gl_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
         }
 
       if (COGL_PIXEL_FORMAT_CAN_HAVE_PREMULT (read_format))
-        read_format = ((read_format & ~COGL_PREMULT_BIT) |
-                       (framebuffer->internal_format & COGL_PREMULT_BIT));
+        {
+          read_format = ((read_format & ~COGL_PREMULT_BIT) |
+                         (internal_format & COGL_PREMULT_BIT));
+        }
 
       tmp_bmp = _cogl_bitmap_new_with_malloc_buffer (ctx,
                                                      width, height,
@@ -1307,7 +1361,7 @@ _cogl_framebuffer_gl_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
        * converted to the right format below */
       if (COGL_PIXEL_FORMAT_CAN_HAVE_PREMULT (format))
         bmp_format = ((format & ~COGL_PREMULT_BIT) |
-                      (framebuffer->internal_format & COGL_PREMULT_BIT));
+                      (internal_format & COGL_PREMULT_BIT));
       else
         bmp_format = format;
 
@@ -1361,7 +1415,7 @@ _cogl_framebuffer_gl_read_pixels_into_bitmap (CoglFramebuffer *framebuffer,
 
   /* NB: All offscreen rendering is done upside down so there is no need
    * to flip in this case... */
-  if (!cogl_is_offscreen (framebuffer) &&
+  if (!COGL_IS_OFFSCREEN (framebuffer) &&
       (source & COGL_READ_PIXELS_NO_FLIP) == 0 &&
       !pack_invert_set)
     {
diff --git a/cogl/cogl/driver/gl/cogl-pipeline-opengl.c b/cogl/cogl/driver/gl/cogl-pipeline-opengl.c
index b99b74efea54a0da999579a6d04ab8edb35a9480..802dd07feec2975c6374f83f1c520c6d89407ac4 100644
--- a/cogl/cogl/driver/gl/cogl-pipeline-opengl.c
+++ b/cogl/cogl/driver/gl/cogl-pipeline-opengl.c
@@ -259,7 +259,10 @@ flush_depth_state (CoglContext *ctx,
   gboolean depth_writing_enabled = depth_state->write_enabled;
 
   if (ctx->current_draw_buffer)
-    depth_writing_enabled &= ctx->current_draw_buffer->depth_writing_enabled;
+    {
+      depth_writing_enabled &=
+        cogl_framebuffer_get_depth_write_enabled (ctx->current_draw_buffer);
+    }
 
   if (ctx->depth_test_enabled_cache != depth_state->test_enabled)
     {
@@ -267,7 +270,7 @@ flush_depth_state (CoglContext *ctx,
         {
           GE (ctx, glEnable (GL_DEPTH_TEST));
           if (ctx->current_draw_buffer)
-            ctx->current_draw_buffer->depth_buffer_clear_needed = TRUE;
+            cogl_framebuffer_set_depth_buffer_clear_needed (ctx->current_draw_buffer);
         }
       else
         GE (ctx, glDisable (GL_DEPTH_TEST));
@@ -425,7 +428,7 @@ _cogl_pipeline_flush_color_blend_alpha_depth_state (
           /* If we are painting to an offscreen framebuffer then we
              need to invert the winding of the front face because
              everything is painted upside down */
-          invert_winding = cogl_is_offscreen (ctx->current_draw_buffer);
+          invert_winding = COGL_IS_OFFSCREEN (ctx->current_draw_buffer);
 
           switch (cull_face_state->front_winding)
             {
diff --git a/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c b/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c
index 88c0adc7702cb6025e596a3942b235d43f24d705..3064fc4daed7d3ebee9951dac414bcf015ac06c4 100644
--- a/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c
+++ b/cogl/cogl/driver/gl/cogl-pipeline-progend-glsl.c
@@ -1016,7 +1016,7 @@ _cogl_pipeline_progend_glsl_pre_paint (CoglPipeline *pipeline,
   if (modelview_entry == NULL || projection_entry == NULL)
     return;
 
-  needs_flip = cogl_is_offscreen (ctx->current_draw_buffer);
+  needs_flip = COGL_IS_OFFSCREEN (ctx->current_draw_buffer);
 
   projection_changed =
     _cogl_matrix_entry_cache_maybe_update (&program_state->projection_cache,
diff --git a/cogl/cogl/winsys/cogl-winsys-egl-private.h b/cogl/cogl/winsys/cogl-winsys-egl-private.h
index 8aea7c92bbc90998e5a63883b463f969fb44b203..b004cb8728083273a4b16aa5dd4618f96e10a60e 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl-private.h
+++ b/cogl/cogl/winsys/cogl-winsys-egl-private.h
@@ -87,9 +87,9 @@ typedef struct _CoglWinsysEGLVtable
   (* onscreen_deinit) (CoglOnscreen *onscreen);
 
   int
-  (* add_config_attributes) (CoglDisplay *display,
-                             CoglFramebufferConfig *config,
-                             EGLint *attributes);
+  (* add_config_attributes) (CoglDisplay                 *display,
+                             const CoglFramebufferConfig *config,
+                             EGLint                      *attributes);
   gboolean
   (* choose_config) (CoglDisplay *display,
                      EGLint *attributes,
diff --git a/cogl/cogl/winsys/cogl-winsys-egl-x11.c b/cogl/cogl/winsys/cogl-winsys-egl-x11.c
index aad6a12ca707d333703ab516647bca6f4a18ab8a..9ce1fa1085a844eaa1bbbc85692ccbe9577c4336 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl-x11.c
+++ b/cogl/cogl/winsys/cogl-winsys-egl-x11.c
@@ -81,7 +81,7 @@ find_onscreen_for_xid (CoglContext *context, uint32_t xid)
       CoglOnscreenEGL *egl_onscreen;
       CoglOnscreenXlib *xlib_onscreen;
 
-      if (framebuffer->type != COGL_FRAMEBUFFER_TYPE_ONSCREEN)
+      if (!COGL_IS_ONSCREEN (framebuffer))
         continue;
 
       egl_onscreen = COGL_ONSCREEN (framebuffer)->winsys;
@@ -99,7 +99,7 @@ flush_pending_resize_notifications_cb (void *data,
 {
   CoglFramebuffer *framebuffer = data;
 
-  if (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN)
+  if (COGL_IS_ONSCREEN (framebuffer))
     {
       CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
       CoglOnscreenEGL *egl_onscreen = onscreen->winsys;
@@ -319,9 +319,9 @@ error:
 }
 
 static int
-_cogl_winsys_egl_add_config_attributes (CoglDisplay *display,
-                                        CoglFramebufferConfig *config,
-                                        EGLint *attributes)
+_cogl_winsys_egl_add_config_attributes (CoglDisplay                 *display,
+                                        const CoglFramebufferConfig *config,
+                                        EGLint                      *attributes)
 {
   int i = 0;
 
@@ -413,7 +413,7 @@ _cogl_winsys_egl_onscreen_init (CoglOnscreen *onscreen,
                                 GError **error)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *display = context->display;
   CoglRenderer *renderer = display->renderer;
   CoglRendererEGL *egl_renderer = renderer->winsys;
@@ -513,7 +513,7 @@ static void
 _cogl_winsys_egl_onscreen_deinit (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *renderer = context->display->renderer;
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (renderer);
@@ -544,7 +544,8 @@ static void
 _cogl_winsys_onscreen_set_visibility (CoglOnscreen *onscreen,
                                       gboolean visibility)
 {
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *renderer = context->display->renderer;
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (renderer);
@@ -562,7 +563,7 @@ _cogl_winsys_onscreen_set_resizable (CoglOnscreen *onscreen,
                                      gboolean resizable)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (context->display->renderer);
   CoglOnscreenEGL *egl_onscreen = onscreen->winsys;
diff --git a/cogl/cogl/winsys/cogl-winsys-egl.c b/cogl/cogl/winsys/cogl-winsys-egl.c
index 6aaac8ef87b31378ef54b3027035ed68a56722d0..6b56d215165d63da68a2b246aead96e8ebd137a0 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl.c
+++ b/cogl/cogl/winsys/cogl-winsys-egl.c
@@ -195,9 +195,9 @@ _cogl_winsys_renderer_connect (CoglRenderer *renderer,
 }
 
 static void
-egl_attributes_from_framebuffer_config (CoglDisplay *display,
-                                        CoglFramebufferConfig *config,
-                                        EGLint *attributes)
+egl_attributes_from_framebuffer_config (CoglDisplay                 *display,
+                                        const CoglFramebufferConfig *config,
+                                        EGLint                      *attributes)
 {
   CoglRenderer *renderer = display->renderer;
   CoglRendererEGL *egl_renderer = renderer->winsys;
@@ -548,11 +548,12 @@ _cogl_winsys_onscreen_init (CoglOnscreen *onscreen,
                             GError **error)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *display = context->display;
   CoglDisplayEGL *egl_display = display->winsys;
   CoglRenderer *renderer = display->renderer;
   CoglRendererEGL *egl_renderer = renderer->winsys;
+  const CoglFramebufferConfig *config;
   EGLint attributes[MAX_EGL_CONFIG_ATTRIBS];
   EGLConfig egl_config;
   EGLint config_count = 0;
@@ -560,9 +561,8 @@ _cogl_winsys_onscreen_init (CoglOnscreen *onscreen,
 
   g_return_val_if_fail (egl_display->egl_context, FALSE);
 
-  egl_attributes_from_framebuffer_config (display,
-                                          &framebuffer->config,
-                                          attributes);
+  config = cogl_framebuffer_get_config (framebuffer);
+  egl_attributes_from_framebuffer_config (display, config, attributes);
 
   status = eglChooseConfig (egl_renderer->edpy,
                             attributes,
@@ -578,14 +578,14 @@ _cogl_winsys_onscreen_init (CoglOnscreen *onscreen,
 
   /* Update the real number of samples_per_pixel now that we have
    * found an egl_config... */
-  if (framebuffer->config.samples_per_pixel)
+  if (config->samples_per_pixel)
     {
       EGLint samples;
       status = eglGetConfigAttrib (egl_renderer->edpy,
                                    egl_config,
                                    EGL_SAMPLES, &samples);
       g_return_val_if_fail (status == EGL_TRUE, TRUE);
-      framebuffer->samples_per_pixel = samples;
+      cogl_framebuffer_update_samples_per_pixel (framebuffer, samples);
     }
 
   onscreen->winsys = g_slice_new0 (CoglOnscreenEGL);
@@ -606,7 +606,7 @@ static void
 _cogl_winsys_onscreen_deinit (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplayEGL *egl_display = context->display->winsys;
   CoglRenderer *renderer = context->display->renderer;
   CoglRendererEGL *egl_renderer = renderer->winsys;
@@ -650,8 +650,8 @@ static gboolean
 bind_onscreen_with_context (CoglOnscreen *onscreen,
                             EGLContext egl_context)
 {
-  CoglFramebuffer *fb = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = fb->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglOnscreenEGL *egl_onscreen = onscreen->winsys;
 
   gboolean status = _cogl_winsys_egl_make_current (context->display,
@@ -672,8 +672,8 @@ bind_onscreen_with_context (CoglOnscreen *onscreen,
 static gboolean
 bind_onscreen (CoglOnscreen *onscreen)
 {
-  CoglFramebuffer *fb = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = fb->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplayEGL *egl_display = context->display->winsys;
 
   return bind_onscreen_with_context (onscreen, egl_display->egl_context);
@@ -692,7 +692,8 @@ _cogl_winsys_onscreen_bind (CoglOnscreen *onscreen)
 static int
 _cogl_winsys_onscreen_get_buffer_age (CoglOnscreen *onscreen)
 {
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *renderer = context->display->renderer;
   CoglRendererEGL *egl_renderer = renderer->winsys;
   CoglOnscreenEGL *egl_onscreen = onscreen->winsys;
@@ -729,11 +730,11 @@ _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
                                    int n_rectangles,
                                    CoglFrameInfo *info)
 {
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *renderer = context->display->renderer;
   CoglRendererEGL *egl_renderer = renderer->winsys;
   CoglOnscreenEGL *egl_onscreen = onscreen->winsys;
-  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   int framebuffer_height  = cogl_framebuffer_get_height (framebuffer);
   int *rectangles = g_alloca (sizeof (int) * n_rectangles * 4);
   int i;
@@ -769,7 +770,8 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                                 int n_rectangles,
                                                 CoglFrameInfo *info)
 {
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *renderer = context->display->renderer;
   CoglRendererEGL *egl_renderer = renderer->winsys;
   CoglOnscreenEGL *egl_onscreen = onscreen->winsys;
@@ -788,7 +790,7 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
 
   if (n_rectangles && egl_renderer->pf_eglSwapBuffersWithDamage)
     {
-      CoglFramebuffer *fb = COGL_FRAMEBUFFER (onscreen);
+      CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
       size_t size = n_rectangles * sizeof (int) * 4;
       int *flipped = alloca (size);
       int i;
@@ -798,7 +800,9 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
         {
           const int *rect = rectangles + 4 * i;
           int *flip_rect = flipped + 4 * i;
-          flip_rect[1] = fb->height - rect[1] - rect[3];
+
+          flip_rect[1] =
+            cogl_framebuffer_get_height (framebuffer) - rect[1] - rect[3];
         }
 
       if (egl_renderer->pf_eglSwapBuffersWithDamage (egl_renderer->edpy,
diff --git a/cogl/cogl/winsys/cogl-winsys-glx.c b/cogl/cogl/winsys/cogl-winsys-glx.c
index 00e70ade670c9da8749e9686847087136f5fcec1..759a15c715a44e25f3f649071abf97d3afd45018 100644
--- a/cogl/cogl/winsys/cogl-winsys-glx.c
+++ b/cogl/cogl/winsys/cogl-winsys-glx.c
@@ -178,7 +178,7 @@ find_onscreen_for_xid (CoglContext *context, uint32_t xid)
       CoglFramebuffer *framebuffer = l->data;
       CoglOnscreenXlib *xlib_onscreen;
 
-      if (framebuffer->type != COGL_FRAMEBUFFER_TYPE_ONSCREEN)
+      if (!COGL_IS_ONSCREEN (framebuffer))
         continue;
 
       /* Does the GLXEvent have the GLXDrawable or the X Window? */
@@ -331,7 +331,7 @@ flush_pending_notifications_cb (void *data,
 {
   CoglFramebuffer *framebuffer = data;
 
-  if (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN)
+  if (COGL_IS_ONSCREEN (framebuffer))
     {
       CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
       CoglOnscreenGLX *glx_onscreen = onscreen->winsys;
@@ -389,7 +389,8 @@ static void
 set_sync_pending (CoglOnscreen *onscreen)
 {
   CoglOnscreenGLX *glx_onscreen = onscreen->winsys;
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *renderer = context->display->renderer;
   CoglGLXRenderer *glx_renderer = renderer->winsys;
 
@@ -412,7 +413,8 @@ static void
 set_complete_pending (CoglOnscreen *onscreen)
 {
   CoglOnscreenGLX *glx_onscreen = onscreen->winsys;
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *renderer = context->display->renderer;
   CoglGLXRenderer *glx_renderer = renderer->winsys;
 
@@ -464,7 +466,7 @@ update_output (CoglOnscreen *onscreen)
 {
   CoglOnscreenXlib *xlib_onscreen = onscreen->winsys;
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *display = context->display;
   CoglOutput *output;
   int width, height;
@@ -631,7 +633,7 @@ update_all_outputs (CoglRenderer *renderer)
     {
       CoglFramebuffer *framebuffer = l->data;
 
-      if (framebuffer->type != COGL_FRAMEBUFFER_TYPE_ONSCREEN)
+      if (!COGL_IS_ONSCREEN (framebuffer))
         continue;
 
       update_output (COGL_ONSCREEN (framebuffer));
@@ -855,9 +857,9 @@ update_winsys_features (CoglContext *context, GError **error)
 }
 
 static void
-glx_attributes_from_framebuffer_config (CoglDisplay *display,
-                                        CoglFramebufferConfig *config,
-                                        int *attributes)
+glx_attributes_from_framebuffer_config (CoglDisplay                 *display,
+                                        const CoglFramebufferConfig *config,
+                                        int                         *attributes)
 {
   CoglGLXRenderer *glx_renderer = display->renderer->winsys;
   int i = 0;
@@ -907,10 +909,10 @@ glx_attributes_from_framebuffer_config (CoglDisplay *display,
  * we could overload as an indication of error, so we have to return
  * an explicit boolean status. */
 static gboolean
-find_fbconfig (CoglDisplay *display,
-               CoglFramebufferConfig *config,
-               GLXFBConfig *config_ret,
-               GError **error)
+find_fbconfig (CoglDisplay                  *display,
+               const CoglFramebufferConfig  *config,
+               GLXFBConfig                  *config_ret,
+               GError                      **error)
 {
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (display->renderer);
@@ -1235,7 +1237,7 @@ _cogl_winsys_onscreen_init (CoglOnscreen *onscreen,
                             GError **error)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *display = context->display;
   CoglGLXDisplay *glx_display = display->winsys;
   CoglXlibRenderer *xlib_renderer =
@@ -1244,12 +1246,14 @@ _cogl_winsys_onscreen_init (CoglOnscreen *onscreen,
   Window xwin;
   CoglOnscreenXlib *xlib_onscreen;
   CoglOnscreenGLX *glx_onscreen;
+  const CoglFramebufferConfig *config;
   GLXFBConfig fbconfig;
   GError *fbconfig_error = NULL;
 
   g_return_val_if_fail (glx_display->glx_context, FALSE);
 
-  if (!find_fbconfig (display, &framebuffer->config,
+  config = cogl_framebuffer_get_config (framebuffer);
+  if (!find_fbconfig (display, config,
                       &fbconfig,
                       &fbconfig_error))
     {
@@ -1263,7 +1267,7 @@ _cogl_winsys_onscreen_init (CoglOnscreen *onscreen,
 
   /* Update the real number of samples_per_pixel now that we have
    * found an fbconfig... */
-  if (framebuffer->config.samples_per_pixel)
+  if (config->samples_per_pixel)
     {
       int samples;
       int status = glx_renderer->glXGetFBConfigAttrib (xlib_renderer->xdpy,
@@ -1271,7 +1275,7 @@ _cogl_winsys_onscreen_init (CoglOnscreen *onscreen,
                                                        GLX_SAMPLES,
                                                        &samples);
       g_return_val_if_fail (status == Success, TRUE);
-      framebuffer->samples_per_pixel = samples;
+      cogl_framebuffer_update_samples_per_pixel (framebuffer, samples);
     }
 
   /* FIXME: We need to explicitly Select for ConfigureNotify events.
@@ -1384,7 +1388,7 @@ static void
 _cogl_winsys_onscreen_deinit (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglContextGLX *glx_context = context->winsys;
   CoglGLXDisplay *glx_display = context->display->winsys;
   CoglXlibRenderer *xlib_renderer =
@@ -1455,7 +1459,8 @@ _cogl_winsys_onscreen_deinit (CoglOnscreen *onscreen)
 static void
 _cogl_winsys_onscreen_bind (CoglOnscreen *onscreen)
 {
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglContextGLX *glx_context = context->winsys;
   CoglGLXDisplay *glx_display = context->display->winsys;
   CoglXlibRenderer *xlib_renderer =
@@ -1526,7 +1531,7 @@ static void
 _cogl_winsys_wait_for_gpu (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
 
   ctx->glFinish ();
 }
@@ -1535,7 +1540,7 @@ static void
 _cogl_winsys_wait_for_vblank (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *ctx = framebuffer->context;
+  CoglContext *ctx = cogl_framebuffer_get_context (framebuffer);
   CoglGLXRenderer *glx_renderer;
   CoglXlibRenderer *xlib_renderer;
   CoglGLXDisplay *glx_display;
@@ -1598,7 +1603,7 @@ static int
 _cogl_winsys_onscreen_get_buffer_age (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglXlibRenderer *xlib_renderer = _cogl_xlib_renderer_get_data (context->display->renderer);
   CoglGLXRenderer *glx_renderer = context->display->renderer->winsys;
   CoglOnscreenGLX *glx_onscreen = onscreen->winsys;
@@ -1635,7 +1640,7 @@ _cogl_winsys_onscreen_swap_region (CoglOnscreen *onscreen,
                                    CoglFrameInfo *info)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (context->display->renderer);
   CoglGLXRenderer *glx_renderer = context->display->renderer->winsys;
@@ -1842,7 +1847,7 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                                 CoglFrameInfo *info)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (context->display->renderer);
   CoglGLXRenderer *glx_renderer = context->display->renderer->winsys;
@@ -1924,7 +1929,8 @@ static void
 _cogl_winsys_onscreen_set_visibility (CoglOnscreen *onscreen,
                                       gboolean visibility)
 {
-  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (context->display->renderer);
   CoglOnscreenXlib *xlib_onscreen = onscreen->winsys;
@@ -1940,7 +1946,7 @@ _cogl_winsys_onscreen_set_resizable (CoglOnscreen *onscreen,
                                      gboolean resizable)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *context = framebuffer->context;
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglXlibRenderer *xlib_renderer =
     _cogl_xlib_renderer_get_data (context->display->renderer);
   CoglOnscreenXlib *xlib_onscreen = onscreen->winsys;
diff --git a/cogl/test-fixtures/test-utils.c b/cogl/test-fixtures/test-utils.c
index a59160f09e588dfec577e392bd98cc832bb417ef..597519d8f10b54f804c02e9e1fad71dfdb1733fa 100644
--- a/cogl/test-fixtures/test-utils.c
+++ b/cogl/test-fixtures/test-utils.c
@@ -164,7 +164,7 @@ void
 test_utils_fini (void)
 {
   if (test_fb)
-    cogl_object_unref (test_fb);
+    g_object_unref (test_fb);
 
   if (test_ctx)
     cogl_object_unref (test_ctx);
diff --git a/cogl/tests/conform/test-backface-culling.c b/cogl/tests/conform/test-backface-culling.c
index 24cce4b946f3addb05df4d65fa97484c3f5e3788..508d2da912911ab4342ccecfe17d11d2f05d43c5 100644
--- a/cogl/tests/conform/test-backface-culling.c
+++ b/cogl/tests/conform/test-backface-culling.c
@@ -303,12 +303,12 @@ test_backface_culling (void)
                                           state.width, state.height,
                                           TEST_UTILS_TEXTURE_NO_SLICING,
                                           COGL_TEXTURE_COMPONENTS_RGBA);
-  state.offscreen = cogl_offscreen_new_with_texture (tex);
+  state.offscreen = COGL_FRAMEBUFFER (cogl_offscreen_new_with_texture (tex));
   state.offscreen_tex = tex;
 
   paint (&state);
 
-  cogl_object_unref (state.offscreen);
+  g_object_unref (state.offscreen);
   cogl_object_unref (state.offscreen_tex);
   cogl_object_unref (state.texture);
 
diff --git a/cogl/tests/conform/test-framebuffer-get-bits.c b/cogl/tests/conform/test-framebuffer-get-bits.c
index d03f91b992be18c233858c3b715903c94cc9ccf0..208b711e84856e4b11b01e8b46a95333de595daf 100644
--- a/cogl/tests/conform/test-framebuffer-get-bits.c
+++ b/cogl/tests/conform/test-framebuffer-get-bits.c
@@ -11,13 +11,13 @@ test_framebuffer_get_bits (void)
                                    16, 16); /* width/height */
   CoglOffscreen *offscreen_a =
     cogl_offscreen_new_with_texture (tex_a);
-  CoglFramebuffer *fb_a = offscreen_a;
+  CoglFramebuffer *fb_a = COGL_FRAMEBUFFER (offscreen_a);
   CoglTexture2D *tex_rgba =
     cogl_texture_2d_new_with_size (test_ctx,
                                    16, 16); /* width/height */
   CoglOffscreen *offscreen_rgba =
     cogl_offscreen_new_with_texture (tex_rgba);
-  CoglFramebuffer *fb_rgba = offscreen_rgba;
+  CoglFramebuffer *fb_rgba = COGL_FRAMEBUFFER (offscreen_rgba);
 
   cogl_texture_set_components (tex_a,
                                COGL_TEXTURE_COMPONENTS_A);
@@ -34,8 +34,8 @@ test_framebuffer_get_bits (void)
   g_assert_cmpint (cogl_framebuffer_get_blue_bits (fb_rgba), >=, 1);
   g_assert_cmpint (cogl_framebuffer_get_alpha_bits (fb_rgba), >=, 1);
 
-  cogl_object_unref (fb_rgba);
+  g_object_unref (fb_rgba);
   cogl_object_unref (tex_rgba);
-  cogl_object_unref (fb_a);
+  g_object_unref (fb_a);
   cogl_object_unref (tex_a);
 }
diff --git a/cogl/tests/conform/test-offscreen.c b/cogl/tests/conform/test-offscreen.c
index a5de870e5515f6c7463a8bbf2b89d564c7e87f38..5dfe17e41877348c3d1e1d1de64a1254722e76ee 100644
--- a/cogl/tests/conform/test-offscreen.c
+++ b/cogl/tests/conform/test-offscreen.c
@@ -44,6 +44,7 @@ test_paint (TestState *state)
   CoglTexture2D *tex_2d;
   CoglTexture *tex;
   CoglOffscreen *offscreen;
+  CoglFramebuffer *framebuffer;
   CoglPipeline *opaque_pipeline;
   CoglPipeline *texture_pipeline;
 
@@ -53,6 +54,7 @@ test_paint (TestState *state)
   tex = tex_2d;
 
   offscreen = cogl_offscreen_new_with_texture (tex);
+  framebuffer = COGL_FRAMEBUFFER (offscreen);
 
   /* Set a scale and translate transform on the window framebuffer
    * before switching to the offscreen framebuffer so we can verify it
@@ -76,20 +78,24 @@ test_paint (TestState *state)
   opaque_pipeline = cogl_pipeline_new (test_ctx);
   /* red, top left */
   cogl_pipeline_set_color4ub (opaque_pipeline, 0xff, 0x00, 0x00, 0xff);
-  cogl_framebuffer_draw_rectangle (offscreen, opaque_pipeline, -0.5, 0.5, 0, 0);
+  cogl_framebuffer_draw_rectangle (framebuffer, opaque_pipeline,
+                                   -0.5, 0.5, 0, 0);
   /* green, top right */
   cogl_pipeline_set_color4ub (opaque_pipeline, 0x00, 0xff, 0x00, 0xff);
-  cogl_framebuffer_draw_rectangle (offscreen, opaque_pipeline, 0, 0.5, 0.5, 0);
+  cogl_framebuffer_draw_rectangle (framebuffer, opaque_pipeline,
+                                   0, 0.5, 0.5, 0);
   /* blue, bottom left */
   cogl_pipeline_set_color4ub (opaque_pipeline, 0x00, 0x00, 0xff, 0xff);
-  cogl_framebuffer_draw_rectangle (offscreen, opaque_pipeline, -0.5, 0, 0, -0.5);
+  cogl_framebuffer_draw_rectangle (framebuffer, opaque_pipeline,
+                                   -0.5, 0, 0, -0.5);
   /* white, bottom right */
   cogl_pipeline_set_color4ub (opaque_pipeline, 0xff, 0xff, 0xff, 0xff);
-  cogl_framebuffer_draw_rectangle (offscreen, opaque_pipeline, 0, 0, 0.5, -0.5);
+  cogl_framebuffer_draw_rectangle (framebuffer, opaque_pipeline,
+                                   0, 0, 0.5, -0.5);
 
   /* Cogl should release the last reference when we call cogl_pop_framebuffer()
    */
-  cogl_object_unref (offscreen);
+  g_object_unref (offscreen);
 
   texture_pipeline = cogl_pipeline_new (test_ctx);
   cogl_pipeline_set_layer_texture (texture_pipeline, 0, tex);
@@ -121,6 +127,7 @@ test_flush (TestState *state)
   CoglTexture2D *tex_2d;
   CoglTexture *tex;
   CoglOffscreen *offscreen;
+  CoglFramebuffer *framebuffer;
   CoglColor clear_color;
   int i;
 
@@ -138,15 +145,16 @@ test_flush (TestState *state)
       tex = tex_2d;
 
       offscreen = cogl_offscreen_new_with_texture (tex);
+      framebuffer = COGL_FRAMEBUFFER (offscreen);
 
       cogl_color_init_from_4ub (&clear_color, 0, 0, 0, 255);
-      cogl_framebuffer_clear (offscreen, COGL_BUFFER_BIT_COLOR, &clear_color);
+      cogl_framebuffer_clear (framebuffer, COGL_BUFFER_BIT_COLOR, &clear_color);
 
-      cogl_framebuffer_draw_rectangle (offscreen, pipeline, -1, -1, 1, 1);
+      cogl_framebuffer_draw_rectangle (framebuffer, pipeline, -1, -1, 1, 1);
 
       if (i == 0)
         /* First time check using read pixels on the offscreen */
-        test_utils_check_region (offscreen,
+        test_utils_check_region (framebuffer,
                                  1, 1, 15, 15, 0xff0000ff);
       else if (i == 1)
         {
@@ -178,7 +186,7 @@ test_flush (TestState *state)
         }
 
       cogl_object_unref (tex_2d);
-      cogl_object_unref (offscreen);
+      g_object_unref (offscreen);
     }
 
   cogl_object_unref (pipeline);
diff --git a/cogl/tests/conform/test-pipeline-shader-state.c b/cogl/tests/conform/test-pipeline-shader-state.c
index 7bf0e72e65328222507a4d2ab109e3f4d51ffbcc..69e6526f6787402ecd7284bc10f938f59fe8c85e 100644
--- a/cogl/tests/conform/test-pipeline-shader-state.c
+++ b/cogl/tests/conform/test-pipeline-shader-state.c
@@ -25,9 +25,9 @@ test_pipeline_shader_state (void)
 
   tex = cogl_texture_2d_new_with_size (test_ctx, 128, 128);
   offscreen = cogl_offscreen_new_with_texture (tex);
-  fb = offscreen;
+  fb = COGL_FRAMEBUFFER (offscreen);
   cogl_framebuffer_clear4f (fb, COGL_BUFFER_BIT_COLOR, 0, 0, 0, 1);
-  cogl_object_unref (offscreen);
+  g_object_unref (offscreen);
 
   cogl_framebuffer_clear4f (test_fb, COGL_BUFFER_BIT_COLOR, 1, 1, 0, 1);
 
diff --git a/cogl/tests/conform/test-readpixels.c b/cogl/tests/conform/test-readpixels.c
index 64824b0aa987cd3f0c53a522af4acc52796c5b93..8e23ad6183adb9d511832f54f2769fd1fb4cd49a 100644
--- a/cogl/tests/conform/test-readpixels.c
+++ b/cogl/tests/conform/test-readpixels.c
@@ -83,7 +83,7 @@ on_paint (ClutterActor        *actor,
   g_free (pixels);
 
   cogl_pop_framebuffer ();
-  cogl_object_unref (offscreen);
+  g_object_unref (offscreen);
 
   /* Now verify reading back from an onscreen framebuffer...
    */
diff --git a/cogl/tests/conform/test-viewport.c b/cogl/tests/conform/test-viewport.c
index 3b58a2351f4d209657bac389bbccfb2f1b1bf873..d2961fdff58467b041952ee779b887a591fedc96 100644
--- a/cogl/tests/conform/test-viewport.c
+++ b/cogl/tests/conform/test-viewport.c
@@ -337,7 +337,7 @@ on_paint (ClutterActor        *actor,
   cogl_set_viewport (0, 0, 10, 10);
 
   cogl_pop_framebuffer ();
-  cogl_object_unref (offscreen);
+  g_object_unref (offscreen);
 
   /*
    * Verify that the previous onscreen framebuffer's viewport was restored
diff --git a/src/backends/meta-screen-cast-stream-src.c b/src/backends/meta-screen-cast-stream-src.c
index e0aec911523de5683159ac001684de206404e2f9..cc08bccdbe52e05b612090305d4b391d097ad402 100644
--- a/src/backends/meta-screen-cast-stream-src.c
+++ b/src/backends/meta-screen-cast-stream-src.c
@@ -214,7 +214,7 @@ draw_cursor_sprite_via_offscreen (MetaScreenCastStreamSrc  *src,
   cogl_object_unref (bitmap_texture);
   if (!cogl_framebuffer_allocate (fb, error))
     {
-      cogl_object_unref (fb);
+      g_object_unref (fb);
       return FALSE;
     }
 
@@ -234,7 +234,7 @@ draw_cursor_sprite_via_offscreen (MetaScreenCastStreamSrc  *src,
                                 bitmap_width, bitmap_height,
                                 COGL_PIXEL_FORMAT_RGBA_8888_PRE,
                                 bitmap_data);
-  cogl_object_unref (fb);
+  g_object_unref (fb);
 
   return TRUE;
 }
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 87a690532b70437c1bcbb9851f0961ff274237ba..d28a81f6de0acff3d3b0fef11f03d903eb53909f 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -807,9 +807,9 @@ fail:
 }
 
 static int
-meta_renderer_native_add_egl_config_attributes (CoglDisplay           *cogl_display,
-                                                CoglFramebufferConfig *config,
-                                                EGLint                *attributes)
+meta_renderer_native_add_egl_config_attributes (CoglDisplay                 *cogl_display,
+                                                const CoglFramebufferConfig *config,
+                                                EGLint                      *attributes)
 {
   CoglRendererEGL *cogl_renderer_egl = cogl_display->renderer->winsys;
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
@@ -1278,7 +1278,7 @@ queue_dummy_power_save_page_flip (CoglOnscreen *onscreen)
 
   renderer_native->power_save_page_flip_onscreens =
     g_list_prepend (renderer_native->power_save_page_flip_onscreens,
-                    cogl_object_ref (onscreen));
+                    g_object_ref (onscreen));
 }
 
 static void
@@ -1635,7 +1635,7 @@ create_dma_buf_framebuffer (MetaRendererNative  *renderer_native,
 
   if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (cogl_fbo), error))
     {
-      cogl_object_unref (cogl_fbo);
+      g_object_unref (cogl_fbo);
       return NULL;
     }
 
@@ -1706,11 +1706,11 @@ copy_shared_framebuffer_primary_gpu (CoglOnscreen                        *onscre
                               dumb_fb->height,
                               &error))
     {
-      cogl_object_unref (dmabuf_fb);
+      g_object_unref (dmabuf_fb);
       return FALSE;
     }
 
-  cogl_object_unref (dmabuf_fb);
+  g_object_unref (dmabuf_fb);
 
   g_clear_object (&secondary_gpu_state->gbm.next_fb);
   buffer_dumb = meta_drm_buffer_dumb_new (dumb_fb->fb_id);
@@ -1726,7 +1726,7 @@ copy_shared_framebuffer_cpu (CoglOnscreen                        *onscreen,
                              MetaRendererNativeGpuData           *renderer_gpu_data)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *cogl_context = framebuffer->context;
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   MetaDumbBuffer *dumb_fb;
   CoglBitmap *dumb_bitmap;
   CoglPixelFormat cogl_format;
@@ -1869,7 +1869,8 @@ ensure_crtc_modes (CoglOnscreen  *onscreen,
 {
   CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
   MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
-  CoglContext *cogl_context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *cogl_renderer = cogl_context->display->renderer;
   CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
@@ -1897,7 +1898,8 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
                                                int            n_rectangles,
                                                CoglFrameInfo *frame_info)
 {
-  CoglContext *cogl_context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
   CoglRenderer *cogl_renderer = cogl_context->display->renderer;
   CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
@@ -2049,7 +2051,7 @@ meta_renderer_native_create_dma_buf (CoglRenderer  *cogl_renderer,
                                    width, height, stride, offset, bpp,
                                    new_bo,
                                    (GDestroyNotify) gbm_bo_destroy);
-        cogl_object_unref (dmabuf_fb);
+        g_object_unref (dmabuf_fb);
         return dmabuf_handle;
       }
       break;
@@ -2118,7 +2120,8 @@ meta_onscreen_native_direct_scanout (CoglOnscreen   *onscreen,
   CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
   MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
-  CoglContext *cogl_context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   CoglRenderer *cogl_renderer = cogl_context->display->renderer;
   CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
@@ -2217,7 +2220,7 @@ meta_renderer_native_create_surface_gbm (CoglOnscreen        *onscreen,
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
   MetaEgl *egl = meta_onscreen_native_get_egl (onscreen_native);
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *cogl_context = framebuffer->context;
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *cogl_display = cogl_context->display;
   CoglDisplayEGL *cogl_display_egl = cogl_display->winsys;
   CoglRenderer *cogl_renderer = cogl_display->renderer;
@@ -2305,7 +2308,7 @@ meta_renderer_native_create_surface_egl_device (CoglOnscreen  *onscreen,
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
   MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
-  CoglContext *cogl_context = framebuffer->context;
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *cogl_display = cogl_context->display;
   CoglDisplayEGL *cogl_display_egl = cogl_display->winsys;
   CoglRenderer *cogl_renderer = cogl_display->renderer;
@@ -2538,7 +2541,7 @@ meta_renderer_native_init_onscreen (CoglOnscreen *onscreen,
                                     GError      **error)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *cogl_context = framebuffer->context;
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *cogl_display = cogl_context->display;
   CoglDisplayEGL *cogl_display_egl = cogl_display->winsys;
   CoglOnscreenEGL *onscreen_egl;
@@ -2644,7 +2647,7 @@ destroy_egl_surface (CoglOnscreen *onscreen)
       MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
       MetaEgl *egl = meta_onscreen_native_get_egl (onscreen_native);
       CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-      CoglContext *cogl_context = framebuffer->context;
+      CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
       CoglRenderer *cogl_renderer = cogl_context->display->renderer;
       CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
 
@@ -2660,7 +2663,7 @@ static void
 meta_renderer_native_release_onscreen (CoglOnscreen *onscreen)
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *cogl_context = framebuffer->context;
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
   CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
   CoglDisplayEGL *cogl_display_egl = cogl_display->winsys;
   CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
@@ -2787,7 +2790,7 @@ meta_renderer_native_create_onscreen (MetaRendererNative   *renderer_native,
 
   if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (onscreen), error))
     {
-      cogl_object_unref (onscreen);
+      g_object_unref (onscreen);
       return NULL;
     }
 
@@ -2802,7 +2805,7 @@ meta_renderer_native_create_onscreen (MetaRendererNative   *renderer_native,
     {
       if (!init_secondary_gpu_state (renderer_native, onscreen, error))
         {
-          cogl_object_unref (onscreen);
+          g_object_unref (onscreen);
           return NULL;
         }
     }
@@ -2833,7 +2836,7 @@ meta_renderer_native_create_offscreen (MetaRendererNative    *renderer,
   cogl_object_unref (tex);
   if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (fb), error))
     {
-      cogl_object_unref (fb);
+      g_object_unref (fb);
       return FALSE;
     }
 
@@ -3072,20 +3075,20 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
                        "transform", view_transform,
                        "refresh-rate", crtc_mode_info->refresh_rate,
                        NULL);
-  g_clear_pointer (&offscreen, cogl_object_unref);
+  g_clear_object (&offscreen);
 
   meta_onscreen_native_set_view (onscreen, view);
 
   if (!meta_onscreen_native_allocate (onscreen, &error))
     {
       g_warning ("Could not create onscreen: %s", error->message);
-      cogl_object_unref (onscreen);
+      g_object_unref (onscreen);
       g_object_unref (view);
       g_error_free (error);
       return NULL;
     }
 
-  cogl_object_unref (onscreen);
+  g_object_unref (onscreen);
 
   /* Ensure we don't point to stale surfaces when creating the offscreen */
   onscreen_egl = onscreen->winsys;
@@ -3854,7 +3857,7 @@ meta_renderer_native_finalize (GObject *object)
   if (renderer_native->power_save_page_flip_onscreens)
     {
       g_list_free_full (renderer_native->power_save_page_flip_onscreens,
-                        (GDestroyNotify) cogl_object_unref);
+                        g_object_unref);
       g_clear_handle_id (&renderer_native->power_save_page_flip_source_id,
                          g_source_remove);
     }
diff --git a/src/backends/x11/meta-stage-x11.c b/src/backends/x11/meta-stage-x11.c
index 684b711b7141c812e5683eabf35ac2625bbab409..18c64b6ca2b3e5add45469cd21ee804d6c7d58c9 100644
--- a/src/backends/x11/meta-stage-x11.c
+++ b/src/backends/x11/meta-stage-x11.c
@@ -251,7 +251,7 @@ meta_stage_x11_unrealize (ClutterStageWindow *stage_window)
 
   clutter_stage_window_parent_iface->unrealize (stage_window);
 
-  g_clear_pointer (&stage_x11->onscreen, cogl_object_unref);
+  g_clear_object (&stage_x11->onscreen);
 }
 
 static gboolean
@@ -289,7 +289,7 @@ meta_stage_x11_realize (ClutterStageWindow *stage_window)
     {
       g_warning ("Failed to allocate stage: %s", error->message);
       g_error_free (error);
-      cogl_object_unref (stage_x11->onscreen);
+      g_object_unref (stage_x11->onscreen);
       abort();
     }
 
diff --git a/src/compositor/meta-background.c b/src/compositor/meta-background.c
index 71eca7a95eb952e3772106de341050c239701c47..1a677fe187a11b13c145c8b7d7862e6daf6ac4e6 100644
--- a/src/compositor/meta-background.c
+++ b/src/compositor/meta-background.c
@@ -94,37 +94,22 @@ free_fbos (MetaBackground *self)
   for (i = 0; i < self->n_monitors; i++)
     {
       MetaBackgroundMonitor *monitor = &self->monitors[i];
-      if (monitor->fbo)
-        {
-          cogl_object_unref (monitor->fbo);
-          monitor->fbo = NULL;
-        }
-      if (monitor->texture)
-        {
-          cogl_object_unref (monitor->texture);
-          monitor->texture = NULL;
-        }
+
+      g_clear_object (&monitor->fbo);
+      cogl_clear_object (&monitor->texture);
     }
 }
 
 static void
 free_color_texture (MetaBackground *self)
 {
-  if (self->color_texture != NULL)
-    {
-      cogl_object_unref (self->color_texture);
-      self->color_texture = NULL;
-    }
+  cogl_clear_object (&self->color_texture);
 }
 
 static void
 free_wallpaper_texture (MetaBackground *self)
 {
-  if (self->wallpaper_texture != NULL)
-    {
-      cogl_object_unref (self->wallpaper_texture);
-      self->wallpaper_texture = NULL;
-    }
+  cogl_clear_object (&self->wallpaper_texture);
 
   self->wallpaper_allocation_failed = FALSE;
 }
@@ -133,8 +118,7 @@ static void
 invalidate_monitor_backgrounds (MetaBackground *self)
 {
   free_fbos (self);
-  g_free (self->monitors);
-  self->monitors = NULL;
+  g_clear_pointer (&self->monitors, g_free);
   self->n_monitors = 0;
 
   if (self->display)
@@ -263,8 +247,7 @@ set_file (MetaBackground       *self,
           g_signal_handlers_disconnect_by_func (*imagep,
                                                 (gpointer)on_background_loaded,
                                                 self);
-          g_object_unref (*imagep);
-          *imagep = NULL;
+          g_clear_object (imagep);
         }
 
       g_set_object (filep, file);
@@ -696,9 +679,8 @@ ensure_wallpaper_texture (MetaBackground *self,
            */
           g_error_free (catch_error);
 
-          cogl_object_unref (self->wallpaper_texture);
-          self->wallpaper_texture = NULL;
-          cogl_object_unref (fbo);
+          cogl_clear_object (&self->wallpaper_texture);
+          g_object_unref (fbo);
 
           self->wallpaper_allocation_failed = TRUE;
           return FALSE;
@@ -723,7 +705,7 @@ ensure_wallpaper_texture (MetaBackground *self,
           cogl_object_unref (pipeline);
         }
 
-      cogl_object_unref (fbo);
+      g_object_unref (fbo);
     }
 
   return self->wallpaper_texture != NULL;
@@ -858,10 +840,8 @@ meta_background_get_texture (MetaBackground         *self,
            * we'll try again the next time this is called. (MetaBackgroundActor
            * caches the result, so user might be left without a background.)
            */
-          cogl_object_unref (monitor->texture);
-          monitor->texture = NULL;
-          cogl_object_unref (monitor->fbo);
-          monitor->fbo = NULL;
+          cogl_clear_object (&monitor->texture);
+          g_clear_object (&monitor->fbo);
 
           g_error_free (catch_error);
           return NULL;
diff --git a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
index 92b0aedf9cd3dea940e7bc5ad3e38b6c4ff9c32d..00f66b70d4297d8dcecb4689774b4e0036e1c193 100644
--- a/src/compositor/meta-compositor-native.c
+++ b/src/compositor/meta-compositor-native.c
@@ -98,7 +98,7 @@ maybe_assign_primary_plane (MetaCompositor *compositor)
     return;
 
   framebuffer = clutter_stage_view_get_framebuffer (CLUTTER_STAGE_VIEW (view));
-  if (!cogl_is_onscreen (framebuffer))
+  if (!COGL_IS_ONSCREEN (framebuffer))
     return;
 
   surface_actor = meta_window_actor_get_surface (window_actor);
diff --git a/src/compositor/meta-shaped-texture.c b/src/compositor/meta-shaped-texture.c
index 2637a63fe4590b0d683d09c832f5609ee7d97dfd..6271142f2b271bdae7c917d053d73e19866ad0e3 100644
--- a/src/compositor/meta-shaped-texture.c
+++ b/src/compositor/meta-shaped-texture.c
@@ -1402,7 +1402,7 @@ get_image_via_offscreen (MetaShapedTexture     *stex,
   if (!cogl_framebuffer_allocate (fb, &error))
     {
       g_error_free (error);
-      cogl_object_unref (fb);
+      g_object_unref (fb);
       return FALSE;
     }
 
@@ -1445,7 +1445,7 @@ get_image_via_offscreen (MetaShapedTexture     *stex,
                                 clip->width, clip->height,
                                 CLUTTER_CAIRO_FORMAT_ARGB32,
                                 cairo_image_surface_get_data (surface));
-  cogl_object_unref (fb);
+  g_object_unref (fb);
 
   cairo_surface_mark_dirty (surface);
 
diff --git a/src/compositor/meta-texture-tower.c b/src/compositor/meta-texture-tower.c
index cb7b997262a1dceaf5c6f43b1964fef64ab373d8..2571c7e3c048d9d898dc4cfaab5003d81cbbe783 100644
--- a/src/compositor/meta-texture-tower.c
+++ b/src/compositor/meta-texture-tower.c
@@ -126,17 +126,8 @@ meta_texture_tower_set_base_texture (MetaTextureTower *tower,
     {
       for (i = 1; i < tower->n_levels; i++)
         {
-          if (tower->textures[i] != NULL)
-            {
-              cogl_object_unref (tower->textures[i]);
-              tower->textures[i] = NULL;
-            }
-
-          if (tower->fbos[i] != NULL)
-            {
-              cogl_object_unref (tower->fbos[i]);
-              tower->fbos[i] = NULL;
-            }
+          cogl_clear_object (&tower->textures[i]);
+          g_clear_object (&tower->fbos[i]);
         }
 
       cogl_object_unref (tower->textures[0]);
diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index 523fff8fb16b6cf37f00f56633c93b0b72a1d7fc..5eb37a9e92cfde81481cb021ddc0770eb61f948e 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -1486,7 +1486,7 @@ meta_window_actor_get_image (MetaWindowActor *self,
     {
       g_warning ("Failed to allocate framebuffer for screenshot: %s",
                  error->message);
-      cogl_object_unref (framebuffer);
+      g_object_unref (framebuffer);
       cogl_object_unref (texture);
       goto out;
     }
@@ -1533,7 +1533,7 @@ meta_window_actor_get_image (MetaWindowActor *self,
                                 CLUTTER_CAIRO_FORMAT_ARGB32,
                                 cairo_image_surface_get_data (surface));
 
-  cogl_object_unref (framebuffer);
+  g_object_unref (framebuffer);
 
   cairo_surface_mark_dirty (surface);
 
diff --git a/src/tests/clutter/interactive/test-cogl-offscreen.c b/src/tests/clutter/interactive/test-cogl-offscreen.c
index 5d80899447e8d658abd289304fb13e3299fa51cc..4f2e6bddb178d38b619db4c8e2678afc1da3d4ef 100644
--- a/src/tests/clutter/interactive/test-cogl-offscreen.c
+++ b/src/tests/clutter/interactive/test-cogl-offscreen.c
@@ -73,7 +73,7 @@ struct _TestCoglboxPrivate
 {
   CoglHandle texhand_id;
   CoglHandle texture_id;
-  CoglHandle offscreen_id;
+  CoglFramebuffer *framebuffer;
 };
 
 G_DEFINE_TYPE_WITH_PRIVATE (TestCoglbox, test_coglbox, CLUTTER_TYPE_ACTOR);
@@ -111,11 +111,11 @@ test_coglbox_paint (ClutterActor        *self,
 
   pipeline = cogl_pipeline_new (ctx);
   cogl_pipeline_set_color4ub (pipeline, 0xff, 0, 0, 0xff);
-  cogl_framebuffer_draw_rectangle (priv->offscreen_id, pipeline,
+  cogl_framebuffer_draw_rectangle (priv->framebuffer, pipeline,
                                    20, 20, 20 + 100, 20 + 100);
 
   cogl_pipeline_set_color4ub (pipeline, 0, 0xff, 0, 0xff);
-  cogl_framebuffer_draw_rectangle (priv->offscreen_id, pipeline,
+  cogl_framebuffer_draw_rectangle (priv->framebuffer, pipeline,
                                    80, 80, 80 + 100, 80 + 100);
   cogl_object_unref (pipeline);
 
@@ -146,7 +146,7 @@ test_coglbox_dispose (GObject *object)
   priv = TEST_COGLBOX_GET_PRIVATE (object);
 
   cogl_object_unref (priv->texture_id);
-  cogl_object_unref (priv->offscreen_id);
+  g_object_unref (priv->framebuffer);
 
   G_OBJECT_CLASS (test_coglbox_parent_class)->dispose (object);
 }
@@ -252,24 +252,28 @@ test_coglbox_map (ClutterActor *actor)
   ClutterPerspective perspective;
   float stage_width;
   float stage_height;
+  GError *error = NULL;
 
   CLUTTER_ACTOR_CLASS (test_coglbox_parent_class)->map (actor);
 
   printf ("Creating offscreen\n");
-  priv->offscreen_id = cogl_offscreen_new_to_texture (priv->texture_id);
+  priv->framebuffer =
+    COGL_FRAMEBUFFER (cogl_offscreen_new_with_texture (priv->texture_id));
+  if (!cogl_framebuffer_allocate (priv->framebuffer, &error))
+    g_error ("Failed to allocate framebuffer: %s", error->message);
 
   stage = clutter_actor_get_stage (actor);
   clutter_stage_get_perspective (CLUTTER_STAGE (stage), &perspective);
   clutter_actor_get_size (stage, &stage_width, &stage_height);
 
-  setup_viewport (priv->offscreen_id,
+  setup_viewport (priv->framebuffer,
                   stage_width, stage_height,
                   perspective.fovy,
                   perspective.aspect,
                   perspective.z_near,
                   perspective.z_far);
 
-  if (priv->offscreen_id == NULL)
+  if (!priv->framebuffer)
     printf ("Failed creating offscreen to texture!\n");
 }
 
