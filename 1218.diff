diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index caab97b4e2b9729154c44e98a51f4a5843f383e1..b647093ffeab91cadf81229d97851e5b4cad03ec 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -21076,6 +21076,23 @@ clutter_actor_has_mapped_clones (ClutterActor *self)
   return FALSE;
 }
 
+gboolean
+clutter_actor_has_ancestor_mapped_clones (ClutterActor *self)
+{
+  ClutterActor *actor;
+
+  actor = CLUTTER_ACTOR (self);
+  do
+    {
+      if (clutter_actor_has_mapped_clones (actor))
+        return TRUE;
+      actor = clutter_actor_get_parent (actor);
+    }
+  while (actor);
+
+  return FALSE;
+}
+
 static void
 clutter_actor_child_model__items_changed (GListModel *model,
                                           guint       position,
diff --git a/clutter/clutter/clutter-master-clock-default.c b/clutter/clutter/clutter-master-clock-default.c
index 8d50ab8f3a8514ca0a6739d04b989f2c73c94d62..a34454a3a015c330085036f181eba3f02c27dc53 100644
--- a/clutter/clutter/clutter-master-clock-default.c
+++ b/clutter/clutter/clutter-master-clock-default.c
@@ -199,7 +199,7 @@ master_clock_schedule_stage_updates (ClutterMasterClockDefault *master_clock)
   stages = clutter_stage_manager_peek_stages (stage_manager);
 
   for (l = stages; l != NULL; l = l->next)
-    _clutter_stage_schedule_update (l->data);
+    clutter_stage_schedule_update (l->data);
 }
 
 static GSList *
@@ -252,7 +252,7 @@ master_clock_reschedule_stage_updates (ClutterMasterClockDefault *master_clock,
       if (master_clock->timelines ||
           _clutter_stage_has_queued_events (l->data) ||
           _clutter_stage_needs_update (l->data))
-        _clutter_stage_schedule_update (l->data);
+        clutter_stage_schedule_update (l->data);
     }
 }
 
diff --git a/clutter/clutter/clutter-mutter.h b/clutter/clutter/clutter-mutter.h
index d5dbf89e6c9dc2563fcb6141803db4ee3015d6a4..6823140943aaf286110f9584ac67ba3e81134e17 100644
--- a/clutter/clutter/clutter-mutter.h
+++ b/clutter/clutter/clutter-mutter.h
@@ -87,6 +87,9 @@ gboolean clutter_actor_has_damage (ClutterActor *actor);
 CLUTTER_EXPORT
 gboolean clutter_actor_has_transitions (ClutterActor *actor);
 
+CLUTTER_EXPORT
+gboolean clutter_actor_has_ancestor_mapped_clones (ClutterActor *self);
+
 #undef __CLUTTER_H_INSIDE__
 
 #endif /* __CLUTTER_MUTTER_H__ */
diff --git a/clutter/clutter/clutter-stage-private.h b/clutter/clutter/clutter-stage-private.h
index db2ee4baf1ef25df0d85d36e17feef37c24d4f99..2c5a2a50ee1afd6fac8ea298eb7a49c942ba3ae0 100644
--- a/clutter/clutter/clutter-stage-private.h
+++ b/clutter/clutter/clutter-stage-private.h
@@ -74,7 +74,6 @@ void     _clutter_stage_queue_event                       (ClutterStage *stage,
 gboolean _clutter_stage_has_queued_events                 (ClutterStage *stage);
 void     _clutter_stage_process_queued_events             (ClutterStage *stage);
 void     _clutter_stage_update_input_devices              (ClutterStage *stage);
-void     _clutter_stage_schedule_update                   (ClutterStage *stage);
 gint64    _clutter_stage_get_update_time                  (ClutterStage *stage);
 void     _clutter_stage_clear_update_time                 (ClutterStage *stage);
 gboolean _clutter_stage_has_full_redraw_queued            (ClutterStage *stage);
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index d656ec2e995d3fd551e55b001b72a11abb066df8..7328542d42e53328c3961d200375ac3e88995bc7 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -142,6 +142,8 @@ struct _ClutterStagePrivate
 
   int update_freeze_count;
 
+  gboolean needs_update;
+
   int64_t last_update_time;

   guint redraw_pending         : 1;
@@ -1170,7 +1172,7 @@ _clutter_stage_queue_event (ClutterStage *stage,
     {
       ClutterMasterClock *master_clock = _clutter_master_clock_get_default ();
       _clutter_master_clock_start_running (master_clock);
-      _clutter_stage_schedule_update (stage);
+      clutter_stage_schedule_update (stage);
     }
 }
 
@@ -1302,7 +1304,9 @@ _clutter_stage_needs_update (ClutterStage *stage)
 
   priv = stage->priv;
 
-  return priv->redraw_pending || g_hash_table_size (priv->pending_relayouts) > 0;
+  return (priv->redraw_pending ||
+          priv->needs_update ||
+          g_hash_table_size (priv->pending_relayouts) > 0);
 }
 
 void
@@ -1312,7 +1316,7 @@ clutter_stage_queue_actor_relayout (ClutterStage *stage,
   ClutterStagePrivate *priv = stage->priv;
 
   if (g_hash_table_size (priv->pending_relayouts) == 0)
-    _clutter_stage_schedule_update (stage);
+    clutter_stage_schedule_update (stage);
 
   g_hash_table_add (priv->pending_relayouts, g_object_ref (actor));
   priv->pending_relayouts_version++;
@@ -1494,6 +1498,8 @@ _clutter_stage_do_update (ClutterStage *stage)
 
   priv->stage_was_relayout = FALSE;
 
+  stage->priv->needs_update = FALSE;
+
   /* if the stage is being destroyed, or if the destruction already
    * happened and we don't have an StageWindow any more, then we
    * should bail out
@@ -3209,7 +3215,7 @@ clutter_stage_ensure_redraw (ClutterStage *stage)
   priv = stage->priv;
 
   if (!_clutter_stage_needs_update (stage))
-    _clutter_stage_schedule_update (stage);
+    clutter_stage_schedule_update (stage);
 
   priv->redraw_pending = TRUE;
 
@@ -3437,13 +3443,13 @@ clutter_stage_get_minimum_size (ClutterStage *stage,
 }
 
 /**
- * _clutter_stage_schedule_update:
- * @window: a #ClutterStage actor
+ * clutter_stage_schedule_update:
+ * @stage: a #ClutterStage actor
  *
  * Schedules a redraw of the #ClutterStage at the next optimal timestamp.
  */
 void
-_clutter_stage_schedule_update (ClutterStage *stage)
+clutter_stage_schedule_update (ClutterStage *stage)
 {
   ClutterStageWindow *stage_window;
 
@@ -3454,6 +3460,8 @@ _clutter_stage_schedule_update (ClutterStage *stage)
   if (stage_window == NULL)
     return;
 
+  stage->priv->needs_update = TRUE;
+
   return _clutter_stage_window_schedule_update (stage_window,
                                                 stage->priv->sync_delay);
 }
@@ -3463,7 +3471,7 @@ _clutter_stage_schedule_update (ClutterStage *stage)
  * @stage: a #ClutterStage actor
  *
  * Returns the earliest time in which the stage is ready to update. The update
- * time is set when _clutter_stage_schedule_update() is called. This can then
+ * time is set when clutter_stage_schedule_update() is called. This can then
  * be used by e.g. the #ClutterMasterClock to know when the stage needs to be
  * redrawn.
  *
@@ -3573,7 +3581,7 @@ _clutter_stage_queue_actor_redraw (ClutterStage                 *stage,
 
       CLUTTER_NOTE (PAINT, "First redraw request");
 
-      _clutter_stage_schedule_update (stage);
+      clutter_stage_schedule_update (stage);
       priv->redraw_pending = TRUE;
 
       master_clock = _clutter_master_clock_get_default ();
diff --git a/clutter/clutter/clutter-stage.h b/clutter/clutter/clutter-stage.h
index d89f7c8d7c115cc21c576ed6f1ca53f494071a96..5d0c1b4159fefaf5db052f351ce28926bc752a3e 100644
--- a/clutter/clutter/clutter-stage.h
+++ b/clutter/clutter/clutter-stage.h
@@ -209,6 +209,9 @@ CLUTTER_EXPORT
 void            clutter_stage_skip_sync_delay                   (ClutterStage          *stage);
 #endif
 
+CLUTTER_EXPORT
+void clutter_stage_schedule_update (ClutterStage *stage);
+
 CLUTTER_EXPORT
 gboolean clutter_stage_get_capture_final_size (ClutterStage          *stage,
                                                cairo_rectangle_int_t *rect,
diff --git a/src/backends/meta-backend-private.h b/src/backends/meta-backend-private.h
index 4678f7768a278e282f91c5673d87cdda63320b2a..5b0c849ec700e005a6f8f95a34a675203ced534f 100644
--- a/src/backends/meta-backend-private.h
+++ b/src/backends/meta-backend-private.h
@@ -108,6 +108,14 @@ struct _MetaBackendClass
 
 void meta_init_backend (GType backend_gtype);
 
+#ifdef HAVE_WAYLAND
+MetaWaylandCompositor * meta_backend_get_wayland_compositor (MetaBackend *backend);
+
+void meta_backend_init_wayland_display (MetaBackend *backend);
+
+void meta_backend_init_wayland (MetaBackend *backend);
+#endif
+
 ClutterBackend * meta_backend_get_clutter_backend (MetaBackend *backend);
 
 MetaIdleMonitor * meta_backend_get_idle_monitor (MetaBackend        *backend,
diff --git a/src/backends/meta-backend-types.h b/src/backends/meta-backend-types.h
index 98cac8b9e2a92f53b23c0e612b66284b9983a241..2961a8b206b2626b67fa4ccadbb9f1998c610fb6 100644
--- a/src/backends/meta-backend-types.h
+++ b/src/backends/meta-backend-types.h
@@ -54,4 +54,6 @@ typedef struct _MetaScreenCast MetaScreenCast;
 typedef struct _MetaScreenCastSession MetaScreenCastSession;
 typedef struct _MetaScreenCastStream MetaScreenCastStream;
 
+typedef struct _MetaWaylandCompositor MetaWaylandCompositor;
+
 #endif /* META_BACKEND_TYPE_H */
diff --git a/src/backends/meta-backend.c b/src/backends/meta-backend.c
index 1c6a6783a61337eb90d79ae1f3a194d2506d328a..f57a785801c36f49a0f385e32b2e71ff2cd17be5 100644
--- a/src/backends/meta-backend.c
+++ b/src/backends/meta-backend.c
@@ -81,6 +81,10 @@
 #include "backends/native/meta-backend-native.h"
 #endif
 
+#ifdef HAVE_WAYLAND
+#include "wayland/meta-wayland.h"
+#endif
+
 enum
 {
   KEYMAP_CHANGED,
@@ -130,6 +134,10 @@ struct _MetaBackendPrivate
   MetaRemoteDesktop *remote_desktop;
 #endif
 
+#ifdef HAVE_WAYLAND
+  MetaWaylandCompositor *wayland_compositor;
+#endif
+
 #ifdef HAVE_PROFILER
   MetaProfiler *profiler;
 #endif
@@ -864,6 +872,120 @@ system_bus_gotten_cb (GObject      *object,
                                         NULL);
 }
 
+#ifdef HAVE_WAYLAND
+MetaWaylandCompositor *
+meta_backend_get_wayland_compositor (MetaBackend *backend)
+{
+  MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
+
+  return priv->wayland_compositor;
+}
+
+void
+meta_backend_init_wayland_display (MetaBackend *backend)
+{
+  MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
+
+  priv->wayland_compositor = meta_wayland_compositor_new (backend);
+}
+
+void
+meta_backend_init_wayland (MetaBackend *backend)
+{
+  MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
+
+  meta_wayland_compositor_setup (priv->wayland_compositor);
+}
+#endif
+
+/* Mutter is responsible for pulling events off the X queue, so Clutter
+ * doesn't need (and shouldn't) run its normal event source which polls
+ * the X fd, but we do have to deal with dispatching events that accumulate
+ * in the clutter queue. This happens, for example, when clutter generate
+ * enter/leave events on mouse motion - several events are queued in the
+ * clutter queue but only one dispatched. It could also happen because of
+ * explicit calls to clutter_event_put(). We add a very simple custom
+ * event loop source which is simply responsible for pulling events off
+ * of the queue and dispatching them before we block for new events.
+ */
+
+static gboolean
+clutter_source_prepare (GSource *source,
+                        int     *timeout)
+{
+  *timeout = -1;
+
+  return clutter_events_pending ();
+}
+
+static gboolean
+clutter_source_check (GSource *source)
+{
+  return clutter_events_pending ();
+}
+
+static gboolean
+clutter_source_dispatch (GSource     *source,
+                         GSourceFunc  callback,
+                         gpointer     user_data)
+{
+  ClutterEvent *event = clutter_event_get ();
+
+  if (event)
+    {
+      clutter_do_event (event);
+      clutter_event_free (event);
+    }
+
+  return TRUE;
+}
+
+static GSourceFuncs clutter_source_funcs = {
+  clutter_source_prepare,
+  clutter_source_check,
+  clutter_source_dispatch
+};
+
+static ClutterBackend *
+meta_get_clutter_backend (void)
+{
+  MetaBackend *backend = meta_get_backend ();
+
+  return meta_backend_get_clutter_backend (backend);
+}
+
+static gboolean
+init_clutter (MetaBackend  *backend,
+              GError      **error)
+{
+  GSource *source;
+
+  clutter_set_custom_backend_func (meta_get_clutter_backend);
+
+  if (clutter_init (NULL, NULL) != CLUTTER_INIT_SUCCESS)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Unable to initialize Clutter");
+      return FALSE;
+    }
+
+  source = g_source_new (&clutter_source_funcs, sizeof (GSource));
+  g_source_attach (source, NULL);
+  g_source_unref (source);
+
+  return TRUE;
+}
+
+static void
+meta_backend_post_init (MetaBackend *backend)
+{
+  MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
+
+  META_BACKEND_GET_CLASS (backend)->post_init (backend);
+
+  meta_settings_post_init (priv->settings);
+}
+
 static gboolean
 meta_backend_initable_init (GInitable     *initable,
                             GCancellable  *cancellable,
@@ -902,6 +1024,11 @@ meta_backend_initable_init (GInitable     *initable,
   priv->profiler = meta_profiler_new ();
 #endif
 
+  if (!init_clutter (backend, error))
+    return FALSE;
+
+  meta_backend_post_init (backend);
+
   return TRUE;
 }
 
@@ -917,16 +1044,6 @@ meta_backend_init (MetaBackend *backend)
   _backend = backend;
 }
 
-static void
-meta_backend_post_init (MetaBackend *backend)
-{
-  MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
-
-  META_BACKEND_GET_CLASS (backend)->post_init (backend);
-
-  meta_settings_post_init (priv->settings);
-}
-
 /**
  * meta_backend_get_idle_monitor: (skip)
  */
@@ -1258,54 +1375,6 @@ meta_backend_set_client_pointer_constraint (MetaBackend           *backend,
     priv->client_pointer_constraint = g_object_ref (constraint);
 }
 
-/* Mutter is responsible for pulling events off the X queue, so Clutter
- * doesn't need (and shouldn't) run its normal event source which polls
- * the X fd, but we do have to deal with dispatching events that accumulate
- * in the clutter queue. This happens, for example, when clutter generate
- * enter/leave events on mouse motion - several events are queued in the
- * clutter queue but only one dispatched. It could also happen because of
- * explicit calls to clutter_event_put(). We add a very simple custom
- * event loop source which is simply responsible for pulling events off
- * of the queue and dispatching them before we block for new events.
- */
-
-static gboolean
-event_prepare (GSource    *source,
-               gint       *timeout_)
-{
-  *timeout_ = -1;
-
-  return clutter_events_pending ();
-}
-
-static gboolean
-event_check (GSource *source)
-{
-  return clutter_events_pending ();
-}
-
-static gboolean
-event_dispatch (GSource    *source,
-                GSourceFunc callback,
-                gpointer    user_data)
-{
-  ClutterEvent *event = clutter_event_get ();
-
-  if (event)
-    {
-      clutter_do_event (event);
-      clutter_event_free (event);
-    }
-
-  return TRUE;
-}
-
-static GSourceFuncs event_funcs = {
-  event_prepare,
-  event_check,
-  event_dispatch
-};
-
 ClutterBackend *
 meta_backend_get_clutter_backend (MetaBackend *backend)
 {
@@ -1320,14 +1389,6 @@ meta_backend_get_clutter_backend (MetaBackend *backend)
   return priv->clutter_backend;
 }
 
-static ClutterBackend *
-meta_get_clutter_backend (void)
-{
-  MetaBackend *backend = meta_get_backend ();
-
-  return meta_backend_get_clutter_backend (backend);
-}
-
 void
 meta_init_backend (GType backend_gtype)
 {
@@ -1344,29 +1405,6 @@ meta_init_backend (GType backend_gtype)
     }
 }
 
-/**
- * meta_clutter_init: (skip)
- */
-void
-meta_clutter_init (void)
-{
-  GSource *source;
-
-  clutter_set_custom_backend_func (meta_get_clutter_backend);
-
-  if (clutter_init (NULL, NULL) != CLUTTER_INIT_SUCCESS)
-    {
-      g_warning ("Unable to initialize Clutter.\n");
-      exit (1);
-    }
-
-  source = g_source_new (&event_funcs, sizeof (GSource));
-  g_source_attach (source, NULL);
-  g_source_unref (source);
-
-  meta_backend_post_init (_backend);
-}
-
 /**
  * meta_is_stage_views_enabled:
  *
diff --git a/src/backends/native/meta-backend-native.c b/src/backends/native/meta-backend-native.c
index 6c4a474e2dd14db90ac6d3ff0822e02aa12f9305..e5a16f3374ffd1da97b47b3bd0b3439933d418e0 100644
--- a/src/backends/native/meta-backend-native.c
+++ b/src/backends/native/meta-backend-native.c
@@ -366,5 +366,9 @@ meta_backend_native_post_init (MetaBackend *backend)
       if (retval != 0)
         g_warning ("Failed to set RT scheduler: %m");
     }
+
+#ifdef HAVE_WAYLAND
+  meta_backend_init_wayland (backend);
+#endif

 #ifdef HAVE_REMOTE_DESKTOP
@@ -647,6 +651,10 @@ meta_backend_native_initable_init (GInitable     *initable,
   if (!native->launcher)
     return FALSE;
 
+#ifdef HAVE_WAYLAND
+  meta_backend_init_wayland_display (META_BACKEND (native));
+#endif
+
   native->udev = meta_udev_new (native);
   native->barrier_manager = meta_barrier_manager_native_new ();
 
diff --git a/src/backends/x11/nested/meta-backend-x11-nested.c b/src/backends/x11/nested/meta-backend-x11-nested.c
index b9e7ff3b86e6843789304733f0c08e1c18e15b30..def74bb749b3af61be27d76d66c0481a708704ed 100644
--- a/src/backends/x11/nested/meta-backend-x11-nested.c
+++ b/src/backends/x11/nested/meta-backend-x11-nested.c
@@ -33,8 +33,16 @@ typedef struct _MetaBackendX11NestedPrivate
   MetaGpu *gpu;
 } MetaBackendX11NestedPrivate;
 
-G_DEFINE_TYPE_WITH_PRIVATE (MetaBackendX11Nested, meta_backend_x11_nested,
-                            META_TYPE_BACKEND_X11)
+static GInitableIface *initable_parent_iface;
+
+static void
+initable_iface_init (GInitableIface *initable_iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaBackendX11Nested, meta_backend_x11_nested,
+                         META_TYPE_BACKEND_X11,
+                         G_ADD_PRIVATE (MetaBackendX11Nested)
+                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+                                                initable_iface_init));
 
 static MetaRenderer *
 meta_backend_x11_nested_create_renderer (MetaBackend *backend,
@@ -201,6 +209,39 @@ meta_backend_x11_nested_real_init_gpus (MetaBackendX11Nested *backend_x11_nested
   meta_backend_add_gpu (META_BACKEND (backend_x11_nested), priv->gpu);
 }
 
+static void
+meta_backend_x11_nested_post_init (MetaBackend *backend)
+{
+  MetaBackendClass *backend_class =
+    META_BACKEND_CLASS (meta_backend_x11_nested_parent_class);
+
+  backend_class->post_init (backend);
+
+#ifdef HAVE_WAYLAND
+  meta_backend_init_wayland (backend);
+#endif
+}
+
+static gboolean
+meta_backend_x11_nested_initable_init (GInitable     *initable,
+                                       GCancellable  *cancellable,
+                                       GError       **error)
+{
+#ifdef HAVE_WAYLAND
+  meta_backend_init_wayland_display (META_BACKEND (initable));
+#endif
+
+  return initable_parent_iface->init (initable, cancellable, error);
+}
+
+static void
+initable_iface_init (GInitableIface *initable_iface)
+{
+  initable_parent_iface = g_type_interface_peek_parent (initable_iface);
+
+  initable_iface->init = meta_backend_x11_nested_initable_init;
+}
+
 static void
 meta_backend_x11_nested_constructed (GObject *object)
 {
@@ -229,6 +270,7 @@ meta_backend_x11_nested_class_init (MetaBackendX11NestedClass *klass)
 
   object_class->constructed = meta_backend_x11_nested_constructed;
 
+  backend_class->post_init = meta_backend_x11_nested_post_init;
   backend_class->create_renderer = meta_backend_x11_nested_create_renderer;
   backend_class->create_monitor_manager = meta_backend_x11_nested_create_monitor_manager;
   backend_class->create_cursor_renderer = meta_backend_x11_nested_create_cursor_renderer;
diff --git a/src/compositor/compositor.c b/src/compositor/compositor.c
index 338817127ebd07b49618502b835afcb33415f9a0..d45d507432a5c05ac009dbc6ffda3d08a9e9cbbe 100644
--- a/src/compositor/compositor.c
+++ b/src/compositor/compositor.c
@@ -502,11 +502,6 @@ after_stage_paint (ClutterStage *stage,
 
   for (l = priv->windows; l; l = l->next)
     meta_window_actor_post_paint (l->data);
-
-#ifdef HAVE_WAYLAND
-  if (meta_is_wayland_compositor ())
-    meta_wayland_compositor_paint_finished (meta_wayland_compositor_get_default ());
-#endif
 }
 
 static void
@@ -1154,6 +1149,11 @@ meta_compositor_real_post_paint (MetaCompositor *compositor)
     meta_compositor_get_instance_private (compositor);
   CoglGraphicsResetStatus status;
 
+#ifdef HAVE_WAYLAND
+  if (meta_is_wayland_compositor ())
+    meta_wayland_compositor_paint_finished (meta_wayland_compositor_get_default ());
+#endif
+
   status = cogl_get_graphics_reset_status (priv->context);
   switch (status)
     {
diff --git a/src/compositor/meta-surface-actor-wayland.c b/src/compositor/meta-surface-actor-wayland.c
index d63d8a7f9935dbbef344b46ee5c9a2112bf04da6..ce50da16200dbe6baeeb501c9232d9b540643758 100644
--- a/src/compositor/meta-surface-actor-wayland.c
+++ b/src/compositor/meta-surface-actor-wayland.c
@@ -42,7 +42,6 @@ struct _MetaSurfaceActorWayland
   MetaSurfaceActor parent;
 
   MetaWaylandSurface *surface;
-  struct wl_list frame_callback_list;
 };
 
 G_DEFINE_TYPE (MetaSurfaceActorWayland,
@@ -56,6 +55,7 @@ meta_surface_actor_wayland_process_damage (MetaSurfaceActor *actor,
                                            int               width,
                                            int               height)
 {
+  meta_surface_actor_update_area (actor, x, y, width, height);
 }
 
 static void
@@ -63,14 +63,6 @@ meta_surface_actor_wayland_pre_paint (MetaSurfaceActor *actor)
 {
 }
 
-static gboolean
-meta_surface_actor_wayland_is_visible (MetaSurfaceActor *actor)
-{
-  /* TODO: ensure that the buffer isn't NULL, implement
-   * wayland mapping semantics */
-  return TRUE;
-}
-
 static gboolean
 meta_surface_actor_wayland_is_opaque (MetaSurfaceActor *actor)
 {
@@ -79,23 +71,6 @@ meta_surface_actor_wayland_is_opaque (MetaSurfaceActor *actor)
   return meta_shaped_texture_is_opaque (stex);
 }
 
-static void
-queue_frame_callbacks (MetaSurfaceActorWayland *self)
-{
-  MetaWaylandCompositor *wayland_compositor;
-
-  if (!self->surface)
-    return;
-
-  if (meta_surface_actor_is_obscured (META_SURFACE_ACTOR (self)))
-    return;
-
-  wayland_compositor = self->surface->compositor;
-  wl_list_insert_list (&wayland_compositor->frame_callbacks,
-                       &self->frame_callback_list);
-  wl_list_init (&self->frame_callback_list);
-}
-
 CoglScanout *
 meta_surface_actor_wayland_try_acquire_scanout (MetaSurfaceActorWayland *self,
                                                 CoglOnscreen            *onscreen)
@@ -108,35 +83,13 @@ meta_surface_actor_wayland_try_acquire_scanout (MetaSurfaceActorWayland *self,
   if (!scanout)
     return NULL;
 
-  queue_frame_callbacks (self);
-
   return scanout;
 }
 
-void
-meta_surface_actor_wayland_add_frame_callbacks (MetaSurfaceActorWayland *self,
-                                                struct wl_list *frame_callbacks)
-{
-  wl_list_insert_list (&self->frame_callback_list, frame_callbacks);
-}
-
-static void
-meta_surface_actor_wayland_paint (ClutterActor        *actor,
-                                  ClutterPaintContext *paint_context)
-{
-  MetaSurfaceActorWayland *self = META_SURFACE_ACTOR_WAYLAND (actor);
-
-  queue_frame_callbacks (self);
-
-  CLUTTER_ACTOR_CLASS (meta_surface_actor_wayland_parent_class)->paint (actor,
-                                                                        paint_context);
-}
-
 static void
 meta_surface_actor_wayland_dispose (GObject *object)
 {
   MetaSurfaceActorWayland *self = META_SURFACE_ACTOR_WAYLAND (object);
-  MetaWaylandFrameCallback *cb, *next;
   MetaShapedTexture *stex;
 
   stex = meta_surface_actor_get_texture (META_SURFACE_ACTOR (self));
@@ -150,9 +103,6 @@ meta_surface_actor_wayland_dispose (GObject *object)
       self->surface = NULL;
     }
 
-  wl_list_for_each_safe (cb, next, &self->frame_callback_list, link)
-    wl_resource_destroy (cb->resource);
-
   G_OBJECT_CLASS (meta_surface_actor_wayland_parent_class)->dispose (object);
 }
 
@@ -160,14 +110,10 @@ static void
 meta_surface_actor_wayland_class_init (MetaSurfaceActorWaylandClass *klass)
 {
   MetaSurfaceActorClass *surface_actor_class = META_SURFACE_ACTOR_CLASS (klass);
-  ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass);
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
-  actor_class->paint = meta_surface_actor_wayland_paint;
-
   surface_actor_class->process_damage = meta_surface_actor_wayland_process_damage;
   surface_actor_class->pre_paint = meta_surface_actor_wayland_pre_paint;
-  surface_actor_class->is_visible = meta_surface_actor_wayland_is_visible;
   surface_actor_class->is_opaque = meta_surface_actor_wayland_is_opaque;
 
   object_class->dispose = meta_surface_actor_wayland_dispose;
@@ -185,7 +131,6 @@ meta_surface_actor_wayland_new (MetaWaylandSurface *surface)
 
   g_assert (meta_is_wayland_compositor ());
 
-  wl_list_init (&self->frame_callback_list);
   self->surface = surface;
   g_object_add_weak_pointer (G_OBJECT (self->surface),
                              (gpointer *) &self->surface);
diff --git a/src/compositor/meta-surface-actor-x11.c b/src/compositor/meta-surface-actor-x11.c
index 5d8eae9054ef76974ba29e8f9208bde3c733e014..3b1a250d944bc1ceefab58e7464ec61bc3a7752c 100644
--- a/src/compositor/meta-surface-actor-x11.c
+++ b/src/compositor/meta-surface-actor-x11.c
@@ -181,8 +181,8 @@ update_pixmap (MetaSurfaceActorX11 *self)
     }
 }
 
-static gboolean
-is_visible (MetaSurfaceActorX11 *self)
+gboolean
+meta_surface_actor_x11_is_visible (MetaSurfaceActorX11 *self)
 {
   return (self->pixmap != None) && !self->unredirected;
 }
@@ -212,11 +212,12 @@ meta_surface_actor_x11_process_damage (MetaSurfaceActor *actor,
         self->does_full_damage = TRUE;
     }
 
-  if (!is_visible (self))
+  if (!meta_surface_actor_x11_is_visible (self))
     return;
 
   cogl_texture_pixmap_x11_update_area (COGL_TEXTURE_PIXMAP_X11 (self->texture),
                                        x, y, width, height);
+  meta_surface_actor_update_area (actor, x, y, width, height);
 }
 
 static void
@@ -238,13 +239,6 @@ meta_surface_actor_x11_pre_paint (MetaSurfaceActor *actor)
   update_pixmap (self);
 }
 
-static gboolean
-meta_surface_actor_x11_is_visible (MetaSurfaceActor *actor)
-{
-  MetaSurfaceActorX11 *self = META_SURFACE_ACTOR_X11 (actor);
-  return is_visible (self);
-}
-
 static gboolean
 meta_surface_actor_x11_is_opaque (MetaSurfaceActor *actor)
 {
@@ -339,7 +333,6 @@ meta_surface_actor_x11_class_init (MetaSurfaceActorX11Class *klass)
 
   surface_actor_class->process_damage = meta_surface_actor_x11_process_damage;
   surface_actor_class->pre_paint = meta_surface_actor_x11_pre_paint;
-  surface_actor_class->is_visible = meta_surface_actor_x11_is_visible;
   surface_actor_class->is_opaque = meta_surface_actor_x11_is_opaque;
 }
 
diff --git a/src/compositor/meta-surface-actor-x11.h b/src/compositor/meta-surface-actor-x11.h
index 4360065cffb01e23864e4d526edf2c9d1c2ef90c..9fd703bfe073a07dfa9bcd8f42ccbbc481fb7667 100644
--- a/src/compositor/meta-surface-actor-x11.h
+++ b/src/compositor/meta-surface-actor-x11.h
@@ -53,6 +53,8 @@ void meta_surface_actor_x11_set_unredirected (MetaSurfaceActorX11 *self,
 
 gboolean meta_surface_actor_x11_is_unredirected (MetaSurfaceActorX11 *self);
 
+gboolean meta_surface_actor_x11_is_visible (MetaSurfaceActorX11 *self);
+
 G_END_DECLS
 
 #endif /* __META_SURFACE_ACTOR_X11_H__ */
diff --git a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
index c328fab7340cfd996dfc4490f39f68044d1705c1..3e7a9e7161d49c2fc464e41f4d3dd8df6bd11671 100644
--- a/src/compositor/meta-surface-actor.c
+++ b/src/compositor/meta-surface-actor.c
@@ -63,17 +63,9 @@ effective_unobscured_region (MetaSurfaceActor *surface_actor)
 {
   MetaSurfaceActorPrivate *priv =
     meta_surface_actor_get_instance_private (surface_actor);
-  ClutterActor *actor;
 
-  /* Fail if we have any mapped clones. */
-  actor = CLUTTER_ACTOR (surface_actor);
-  do
-    {
-      if (clutter_actor_has_mapped_clones (actor))
-        return NULL;
-      actor = clutter_actor_get_parent (actor);
-    }
-  while (actor != NULL);
+  if (clutter_actor_has_ancestor_mapped_clones (CLUTTER_ACTOR (surface_actor)))
+    return NULL;
 
   return priv->unobscured_region;
 }
@@ -419,9 +411,12 @@ meta_surface_actor_get_texture (MetaSurfaceActor *self)
   return priv->texture;
 }
 
-static void
+void
 meta_surface_actor_update_area (MetaSurfaceActor *self,
-                                int x, int y, int width, int height)
+                                int               x,
+                                int               y,
+                                int               width,
+                                int               height)
 {
   MetaSurfaceActorPrivate *priv =
     meta_surface_actor_get_instance_private (self);
@@ -546,9 +541,6 @@ meta_surface_actor_process_damage (MetaSurfaceActor *self,
     }
 
   META_SURFACE_ACTOR_GET_CLASS (self)->process_damage (self, x, y, width, height);
-
-  if (meta_surface_actor_is_visible (self))
-    meta_surface_actor_update_area (self, x, y, width, height);
 }
 
 void
@@ -557,12 +549,6 @@ meta_surface_actor_pre_paint (MetaSurfaceActor *self)
   META_SURFACE_ACTOR_GET_CLASS (self)->pre_paint (self);
 }
 
-gboolean
-meta_surface_actor_is_visible (MetaSurfaceActor *self)
-{
-  return META_SURFACE_ACTOR_GET_CLASS (self)->is_visible (self);
-}
-
 void
 meta_surface_actor_set_frozen (MetaSurfaceActor *self,
                                gboolean          frozen)
diff --git a/src/compositor/meta-surface-actor.h b/src/compositor/meta-surface-actor.h
index f136b7561723eeadfeda0616d337ff39b848a8de..d8b7365b29e6a0fe8de51cf411734168863bb351 100644
--- a/src/compositor/meta-surface-actor.h
+++ b/src/compositor/meta-surface-actor.h
@@ -25,7 +25,6 @@ struct _MetaSurfaceActorClass
   void     (* process_damage)    (MetaSurfaceActor *actor,
                                   int x, int y, int width, int height);
   void     (* pre_paint)         (MetaSurfaceActor *actor);
-  gboolean (* is_visible)        (MetaSurfaceActor *actor);
   gboolean (* is_opaque)         (MetaSurfaceActor *actor);
 };
 
@@ -34,6 +33,12 @@ cairo_surface_t *meta_surface_actor_get_image (MetaSurfaceActor      *self,
 
 MetaShapedTexture *meta_surface_actor_get_texture (MetaSurfaceActor *self);
 
+void meta_surface_actor_update_area (MetaSurfaceActor *self,
+                                     int               x,
+                                     int               y,
+                                     int               width,
+                                     int               height);
+
 gboolean meta_surface_actor_is_obscured (MetaSurfaceActor *self);
 
 void meta_surface_actor_set_input_region (MetaSurfaceActor *self,
@@ -45,7 +50,6 @@ cairo_region_t * meta_surface_actor_get_opaque_region (MetaSurfaceActor *self);
 void meta_surface_actor_process_damage (MetaSurfaceActor *actor,
                                         int x, int y, int width, int height);
 void meta_surface_actor_pre_paint (MetaSurfaceActor *actor);
-gboolean meta_surface_actor_is_visible (MetaSurfaceActor *actor);
 gboolean meta_surface_actor_is_opaque (MetaSurfaceActor *actor);
 
 gboolean meta_surface_actor_is_frozen (MetaSurfaceActor *actor);
diff --git a/src/compositor/meta-window-actor-x11.c b/src/compositor/meta-window-actor-x11.c
index 622edc415904e5e26faafa6a466aee6474979602..482e5ddaccdc4ac667c6be4ea7adf3127f97e5d6 100644
--- a/src/compositor/meta-window-actor-x11.c
+++ b/src/compositor/meta-window-actor-x11.c
@@ -1211,7 +1211,8 @@ handle_updates (MetaWindowActorX11 *actor_x11)
 
   meta_surface_actor_pre_paint (surface);
 
-  if (!meta_surface_actor_is_visible (surface))
+  if (!META_IS_SURFACE_ACTOR_X11 (surface) ||
+      !meta_surface_actor_x11_is_visible (META_SURFACE_ACTOR_X11 (surface)))
     return;
 
   update_frame_bounds (actor_x11);
diff --git a/src/core/main.c b/src/core/main.c
index 16aa8736abeccadf138a78d2b8012dab941a5646..16ab6e81f0ccbb0e4b85e3d63b0cdf15d9d13e7e 100644
--- a/src/core/main.c
+++ b/src/core/main.c
@@ -586,11 +586,6 @@ meta_init (void)
   g_irepository_prepend_search_path (MUTTER_PKGLIBDIR);
 #endif
 
-#ifdef HAVE_WAYLAND
-  if (meta_is_wayland_compositor ())
-    meta_wayland_pre_clutter_init ();
-#endif
-
   /* NB: When running as a hybrid wayland compositor we run our own headless X
    * server so the user can't control the X display to connect too. */
   if (!meta_is_wayland_compositor ())
@@ -598,14 +593,6 @@ meta_init (void)
 
   meta_init_backend (backend_gtype);
 
-  meta_clutter_init ();
-
-#ifdef HAVE_WAYLAND
-  /* Bring up Wayland. This also launches Xwayland and sets DISPLAY as well... */
-  if (meta_is_wayland_compositor ())
-    meta_wayland_init ();
-#endif
-
   meta_set_syncing (opt_sync || (g_getenv ("MUTTER_SYNC") != NULL));
 
   if (opt_replace_wm)
diff --git a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
index faf170067083f5d98714daac91f4c4af96e9614d..00f33a0faf3d5b94653ad59c414ee70fa3274371 100644
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -104,9 +104,15 @@ meta_wayland_actor_surface_assigned (MetaWaylandSurfaceRole *surface_role)
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
 
-  meta_surface_actor_wayland_add_frame_callbacks (META_SURFACE_ACTOR_WAYLAND (priv->actor),
-                                                  &surface->pending_frame_callback_list);
-  wl_list_init (&surface->pending_frame_callback_list);
+  if (wl_list_empty (&surface->unassigned.pending_frame_callback_list))
+    return;
+
+  wl_list_insert_list (priv->frame_callback_list.prev,
+                       &surface->unassigned.pending_frame_callback_list);
+  wl_list_init (&surface->unassigned.pending_frame_callback_list);
+
+  meta_wayland_compositor_add_frame_callback_surface (surface->compositor,
+                                                      surface);
 }
 
 void
@@ -115,18 +121,37 @@ meta_wayland_actor_surface_queue_frame_callbacks (MetaWaylandActorSurface *actor
 {
   MetaWaylandActorSurfacePrivate *priv =
     meta_wayland_actor_surface_get_instance_private (actor_surface);
-  MetaSurfaceActorWayland *surface_actor_wayland =
-    META_SURFACE_ACTOR_WAYLAND (priv->actor);
+  MetaWaylandSurfaceRole *surface_role =
+    META_WAYLAND_SURFACE_ROLE (actor_surface);
+  MetaWaylandSurface *surface =
+    meta_wayland_surface_role_get_surface (surface_role);
 
-  if (!priv->actor)
+  if (wl_list_empty (&pending->frame_callback_list))
     return;
 
-  meta_surface_actor_wayland_add_frame_callbacks (surface_actor_wayland,
-                                                  &priv->frame_callback_list);
-  wl_list_init (&priv->frame_callback_list);
-  meta_surface_actor_wayland_add_frame_callbacks (surface_actor_wayland,
-                                                  &pending->frame_callback_list);
+  wl_list_insert_list (priv->frame_callback_list.prev,
+                       &pending->frame_callback_list);
   wl_list_init (&pending->frame_callback_list);
+
+  meta_wayland_compositor_add_frame_callback_surface (surface->compositor,
+                                                      surface);
+}
+
+void
+meta_wayland_actor_surface_emit_frame_callbacks (MetaWaylandActorSurface *actor_surface,
+                                                 uint32_t                 timestamp_ms)
+{
+  MetaWaylandActorSurfacePrivate *priv =
+    meta_wayland_actor_surface_get_instance_private (actor_surface);
+
+  while (!wl_list_empty (&priv->frame_callback_list))
+    {
+      MetaWaylandFrameCallback *callback =
+        wl_container_of (priv->frame_callback_list.next, callback, link);
+
+      wl_callback_send_done (callback->resource, timestamp_ms);
+      wl_resource_destroy (callback->resource);
+    }
 }
 
 double
@@ -262,18 +287,17 @@ meta_wayland_actor_surface_apply_state (MetaWaylandSurfaceRole  *surface_role,
   MetaWaylandActorSurfacePrivate *priv =
     meta_wayland_actor_surface_get_instance_private (actor_surface);
 
-  if (!priv->actor)
+  if (!wl_list_empty (&pending->frame_callback_list) &&
+      priv->actor &&
+      !meta_surface_actor_is_obscured (priv->actor))
     {
-      wl_list_insert_list (&priv->frame_callback_list,
-                           &pending->frame_callback_list);
-      wl_list_init (&pending->frame_callback_list);
-      return;
-    }
+      MetaWaylandSurface *surface =
+        meta_wayland_surface_role_get_surface (surface_role);
+      MetaBackend *backend = surface->compositor->backend;
+      ClutterActor *stage = meta_backend_get_stage (backend);
 
-  if (!wl_list_empty (&pending->frame_callback_list) &&
-      cairo_region_is_empty (pending->surface_damage) &&
-      cairo_region_is_empty (pending->buffer_damage))
-    clutter_actor_queue_redraw (CLUTTER_ACTOR (priv->actor));
+      clutter_stage_schedule_update (CLUTTER_STAGE (stage));
+    }
 
   meta_wayland_actor_surface_queue_frame_callbacks (actor_surface, pending);
 
diff --git a/src/wayland/meta-wayland-actor-surface.h b/src/wayland/meta-wayland-actor-surface.h
index caa3cbe3197275a5ce61f4f7035736ae0c4e7f3b..bd0cca275373ca77052831de2a3be6416046c63e 100644
--- a/src/wayland/meta-wayland-actor-surface.h
+++ b/src/wayland/meta-wayland-actor-surface.h
@@ -48,4 +48,7 @@ void meta_wayland_actor_surface_reset_actor (MetaWaylandActorSurface *actor_surf
 void meta_wayland_actor_surface_queue_frame_callbacks (MetaWaylandActorSurface *actor_surface,
                                                        MetaWaylandSurfaceState *pending);
 
+void meta_wayland_actor_surface_emit_frame_callbacks (MetaWaylandActorSurface *actor_surface,
+                                                      uint32_t                 timestamp_ms);
+
 #endif /* META_WAYLAND_ACTOR_SURFACE_H */
diff --git a/src/wayland/meta-wayland-cursor-surface.c b/src/wayland/meta-wayland-cursor-surface.c
index d8ac1413efcc4654eb49eab82f7638148bfd1a5d..95f8186df874544cbc6f8189d2963771d5ec101b 100644
--- a/src/wayland/meta-wayland-cursor-surface.c
+++ b/src/wayland/meta-wayland-cursor-surface.c
@@ -124,8 +124,8 @@ meta_wayland_cursor_surface_assigned (MetaWaylandSurfaceRole *surface_role)
     meta_wayland_cursor_surface_get_instance_private (cursor_surface);
 
   wl_list_insert_list (&priv->frame_callbacks,
-                       &surface->pending_frame_callback_list);
-  wl_list_init (&surface->pending_frame_callback_list);
+                       &surface->unassigned.pending_frame_callback_list);
+  wl_list_init (&surface->unassigned.pending_frame_callback_list);
 }
 
 static void
diff --git a/src/wayland/meta-wayland-dnd-surface.c b/src/wayland/meta-wayland-dnd-surface.c
index b735c138859d4f5bbf0e1606c71881d846615fa3..c3b0f7557b150c2a06aebec3d089b849d1bc56d5 100644
--- a/src/wayland/meta-wayland-dnd-surface.c
+++ b/src/wayland/meta-wayland-dnd-surface.c
@@ -23,6 +23,7 @@
 
 #include "backends/meta-logical-monitor.h"
 #include "compositor/meta-feedback-actor-private.h"
+#include "wayland/meta-wayland.h"
 
 struct _MetaWaylandSurfaceRoleDND
 {
@@ -42,7 +43,11 @@ dnd_surface_assigned (MetaWaylandSurfaceRole *surface_role)
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
 
-  meta_wayland_surface_queue_pending_frame_callbacks (surface);
+  if (wl_list_empty (&surface->unassigned.pending_frame_callback_list))
+    return;
+
+  meta_wayland_compositor_add_frame_callback_surface (surface->compositor,
+                                                      surface);
 }
 
 static void
@@ -56,7 +61,8 @@ dnd_surface_apply_state (MetaWaylandSurfaceRole  *surface_role,
   MetaWaylandSurfaceRoleClass *surface_role_class =
     META_WAYLAND_SURFACE_ROLE_CLASS (meta_wayland_surface_role_dnd_parent_class);
 
-  meta_wayland_surface_queue_pending_state_frame_callbacks (surface, pending);
+  meta_wayland_compositor_add_frame_callback_surface (surface->compositor,
+                                                      surface);
 
   surface_role_dnd->pending_offset_x = pending->dx;
   surface_role_dnd->pending_offset_y = pending->dy;
diff --git a/src/wayland/meta-wayland-legacy-xdg-shell.c b/src/wayland/meta-wayland-legacy-xdg-shell.c
index 9c5b02e1a42dfb38811b48b6f64f8a101d6cc01b..99ccc5652e444f0c1163d1e0a32c667e42ffd0db 100644
--- a/src/wayland/meta-wayland-legacy-xdg-shell.c
+++ b/src/wayland/meta-wayland-legacy-xdg-shell.c
@@ -658,6 +658,8 @@ meta_wayland_zxdg_toplevel_v6_apply_state (MetaWaylandSurfaceRole  *surface_role
     META_WAYLAND_ZXDG_SURFACE_V6 (xdg_toplevel);
   MetaWaylandZxdgSurfaceV6Private *xdg_surface_priv =
     meta_wayland_zxdg_surface_v6_get_instance_private (xdg_surface);
+  MetaWaylandActorSurface *actor_surface =
+    META_WAYLAND_ACTOR_SURFACE (xdg_surface);
   MetaWaylandSurfaceRoleClass *surface_role_class;
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
@@ -668,7 +670,7 @@ meta_wayland_zxdg_toplevel_v6_apply_state (MetaWaylandSurfaceRole  *surface_role
   window = meta_wayland_surface_get_window (surface);
   if (!window)
     {
-      meta_wayland_surface_cache_pending_frame_callbacks (surface, pending);
+      meta_wayland_actor_surface_queue_frame_callbacks (actor_surface, pending);
       return;
     }
 
diff --git a/src/wayland/meta-wayland-private.h b/src/wayland/meta-wayland-private.h
index e28ca06d663ed8c90e1af07211eec1643ef7bbd9..727009b07ea8605ef3b02d432a0dc84cb022905f 100644
--- a/src/wayland/meta-wayland-private.h
+++ b/src/wayland/meta-wayland-private.h
@@ -74,10 +74,12 @@ struct _MetaWaylandCompositor
 {
   GObject parent;
 
+  MetaBackend *backend;
+
   struct wl_display *wayland_display;
   char *display_name;
   GHashTable *outputs;
-  struct wl_list frame_callbacks;
+  GList *frame_callback_surfaces;
 
   MetaXWaylandManager xwayland_manager;
 
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index fa84944bdf3b8e8dbbcea5b1fb07de61d2b623db..9c207f91a94b962e1d6c654c43560cb78c79797a 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -404,15 +404,6 @@ surface_process_damage (MetaWaylandSurface *surface,
   cairo_region_destroy (transformed_region);
 }
 
-void
-meta_wayland_surface_queue_pending_state_frame_callbacks (MetaWaylandSurface      *surface,
-                                                          MetaWaylandSurfaceState *pending)
-{
-  wl_list_insert_list (&surface->compositor->frame_callbacks,
-                       &pending->frame_callback_list);
-  wl_list_init (&pending->frame_callback_list);
-}
-
 MetaWaylandBuffer *
 meta_wayland_surface_get_buffer (MetaWaylandSurface *surface)
 {
@@ -637,9 +628,6 @@ void
 meta_wayland_surface_cache_pending_frame_callbacks (MetaWaylandSurface      *surface,
                                                     MetaWaylandSurfaceState *pending)
 {
-  wl_list_insert_list (&surface->pending_frame_callback_list,
-                       &pending->frame_callback_list);
-  wl_list_init (&pending->frame_callback_list);
 }
 
 static void
@@ -777,7 +765,9 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
     }
   else
     {
-      meta_wayland_surface_cache_pending_frame_callbacks (surface, state);
+      wl_list_insert_list (surface->unassigned.pending_frame_callback_list.prev,
+                           &state->frame_callback_list);
+      wl_list_init (&state->frame_callback_list);
 
       if (state->newly_attached)
         {
@@ -1342,7 +1332,9 @@ wl_surface_destructor (struct wl_resource *resource)
                         surface);
   g_hash_table_unref (surface->outputs_to_destroy_notify_id);
 
-  wl_list_for_each_safe (cb, next, &surface->pending_frame_callback_list, link)
+  wl_list_for_each_safe (cb, next,
+                         &surface->unassigned.pending_frame_callback_list,
+                         link)
     wl_resource_destroy (cb->resource);
 
   if (surface->resource)
@@ -1389,7 +1381,7 @@ meta_wayland_surface_create (MetaWaylandCompositor *compositor,
                                   surface,
                                   wl_surface_destructor);
 
-  wl_list_init (&surface->pending_frame_callback_list);
+  wl_list_init (&surface->unassigned.pending_frame_callback_list);
 
   surface->outputs_to_destroy_notify_id = g_hash_table_new (NULL, NULL);
   surface->shortcut_inhibited_seats = g_hash_table_new (NULL, NULL);
@@ -1849,14 +1841,6 @@ meta_wayland_surface_role_get_surface (MetaWaylandSurfaceRole *role)
   return priv->surface;
 }
 
-void
-meta_wayland_surface_queue_pending_frame_callbacks (MetaWaylandSurface *surface)
-{
-  wl_list_insert_list (&surface->compositor->frame_callbacks,
-                       &surface->pending_frame_callback_list);
-  wl_list_init (&surface->pending_frame_callback_list);
-}
-
 cairo_region_t *
 meta_wayland_surface_calculate_input_region (MetaWaylandSurface *surface)
 {
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 50736758a9a48b9a23bc92409157346fe55b4ffc..25fe1f671c7cb6a7ef374990fb60212574cce599 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -168,13 +168,9 @@ struct _MetaWaylandSurface
   /* Buffer renderer state. */
   gboolean buffer_held;
 
-  /* List of pending frame callbacks that needs to stay queued longer than one
-   * commit sequence, such as when it has not yet been assigned a role.
-   */
-  struct wl_list pending_frame_callback_list;
-
   /* Intermediate state for when no role has been assigned. */
   struct {
+    struct wl_list pending_frame_callback_list;
     MetaWaylandBuffer *buffer;
   } unassigned;
 
diff --git a/src/wayland/meta-wayland-xdg-shell.c b/src/wayland/meta-wayland-xdg-shell.c
index ecad04e120519cc8a42e096912da070cc313900c..b229bf0f0970fa811a5995a78117d030b5ed4220 100644
--- a/src/wayland/meta-wayland-xdg-shell.c
+++ b/src/wayland/meta-wayland-xdg-shell.c
@@ -740,6 +740,8 @@ meta_wayland_xdg_toplevel_apply_state (MetaWaylandSurfaceRole  *surface_role,
   MetaWaylandXdgSurface *xdg_surface = META_WAYLAND_XDG_SURFACE (xdg_toplevel);
   MetaWaylandXdgSurfacePrivate *xdg_surface_priv =
     meta_wayland_xdg_surface_get_instance_private (xdg_surface);
+  MetaWaylandActorSurface *actor_surface =
+    META_WAYLAND_ACTOR_SURFACE (xdg_toplevel);
   MetaWaylandSurfaceRoleClass *surface_role_class;
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
@@ -750,15 +752,12 @@ meta_wayland_xdg_toplevel_apply_state (MetaWaylandSurfaceRole  *surface_role,
   window = meta_wayland_surface_get_window (surface);
   if (!window)
     {
-      meta_wayland_surface_cache_pending_frame_callbacks (surface, pending);
+      meta_wayland_actor_surface_queue_frame_callbacks (actor_surface, pending);
       return;
     }
 
   if (!surface->buffer_ref->buffer && xdg_surface_priv->first_buffer_attached)
     {
-      MetaWaylandActorSurface *actor_surface =
-        META_WAYLAND_ACTOR_SURFACE (xdg_toplevel);
-
       meta_wayland_xdg_surface_reset (xdg_surface);
       meta_wayland_actor_surface_queue_frame_callbacks (actor_surface,
                                                         pending);
@@ -1089,6 +1088,8 @@ meta_wayland_xdg_popup_apply_state (MetaWaylandSurfaceRole  *surface_role,
   MetaWaylandXdgSurface *xdg_surface = META_WAYLAND_XDG_SURFACE (surface_role);
   MetaWaylandXdgSurfacePrivate *xdg_surface_priv =
     meta_wayland_xdg_surface_get_instance_private (xdg_surface);
+  MetaWaylandActorSurface *actor_surface =
+    META_WAYLAND_ACTOR_SURFACE (xdg_popup);
   MetaWaylandSurfaceRoleClass *surface_role_class;
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
@@ -1103,7 +1104,7 @@ meta_wayland_xdg_popup_apply_state (MetaWaylandSurfaceRole  *surface_role,
   if (!surface->buffer_ref->buffer && xdg_surface_priv->first_buffer_attached)
     {
       meta_wayland_xdg_surface_reset (xdg_surface);
-      meta_wayland_surface_cache_pending_frame_callbacks (surface, pending);
+      meta_wayland_actor_surface_queue_frame_callbacks (actor_surface, pending);
       return;
     }
 
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index 86ad781d14d1545f62d763c30c2385b872e11af7..3626f6417aabb0abb6a15fbf723e7a6bb6bebb8e 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -47,7 +47,6 @@
 #include "wayland/meta-xwayland-private.h"
 #include "wayland/meta-xwayland.h"
 
-static MetaWaylandCompositor *_meta_wayland_compositor = NULL;
 static char *_display_name_override;
 
 G_DEFINE_TYPE (MetaWaylandCompositor, meta_wayland_compositor, G_TYPE_OBJECT)
@@ -55,9 +54,14 @@ G_DEFINE_TYPE (MetaWaylandCompositor, meta_wayland_compositor, G_TYPE_OBJECT)
 MetaWaylandCompositor *
 meta_wayland_compositor_get_default (void)
 {
-  g_assert (_meta_wayland_compositor);
+  MetaBackend *backend;
+  MetaWaylandCompositor *wayland_compositor;
 
-  return _meta_wayland_compositor;
+  backend = meta_get_backend ();
+  wayland_compositor = meta_backend_get_wayland_compositor (backend);
+  g_assert (wayland_compositor);
+
+  return wayland_compositor;
 }
 
 typedef struct
@@ -193,15 +197,35 @@ meta_wayland_compositor_update (MetaWaylandCompositor *compositor,
 void
 meta_wayland_compositor_paint_finished (MetaWaylandCompositor *compositor)
 {
-  gint64 current_time = g_get_monotonic_time ();
+  GList *l;
+  int64_t now_us;
+
+  now_us = g_get_monotonic_time ();
 
-  while (!wl_list_empty (&compositor->frame_callbacks))
+  l = compositor->frame_callback_surfaces;
+  while (l)
     {
-      MetaWaylandFrameCallback *callback =
-        wl_container_of (compositor->frame_callbacks.next, callback, link);
+      GList *l_cur = l;
+      MetaWaylandSurface *surface = l->data;
+      MetaSurfaceActor *actor;
+      MetaWaylandActorSurface *actor_surface;
+
+      l = l->next;
+
+      actor = meta_wayland_surface_get_actor (surface);
+      if (!actor)
+        continue;
+
+      if (!clutter_actor_has_ancestor_mapped_clones (CLUTTER_ACTOR (actor)) &&
+          meta_surface_actor_is_obscured (actor))
+        continue;
 
-      wl_callback_send_done (callback->resource, current_time / 1000);
-      wl_resource_destroy (callback->resource);
+      actor_surface = META_WAYLAND_ACTOR_SURFACE (surface->role);
+      meta_wayland_actor_surface_emit_frame_callbacks (actor_surface,
+                                                       now_us / 1000);
+
+      compositor->frame_callback_surfaces =
+        g_list_delete_link (compositor->frame_callback_surfaces, l_cur);
     }
 }
 
@@ -247,17 +271,23 @@ meta_wayland_compositor_update_key_state (MetaWaylandCompositor *compositor,
                                           key_vector, key_vector_len, offset);
 }
 
+void
+meta_wayland_compositor_add_frame_callback_surface (MetaWaylandCompositor *compositor,
+                                                    MetaWaylandSurface    *surface)
+{
+  if (g_list_find (compositor->frame_callback_surfaces, surface))
+    return;
+
+  compositor->frame_callback_surfaces =
+    g_list_prepend (compositor->frame_callback_surfaces, surface);
+}
+
 void
 meta_wayland_compositor_destroy_frame_callbacks (MetaWaylandCompositor *compositor,
                                                  MetaWaylandSurface    *surface)
 {
-  MetaWaylandFrameCallback *callback, *next;
-
-  wl_list_for_each_safe (callback, next, &compositor->frame_callbacks, link)
-    {
-      if (callback->surface == surface)
-        wl_resource_destroy (callback->resource);
-    }
+  compositor->frame_callback_surfaces =
+    g_list_remove (compositor->frame_callback_surfaces, surface);
 }
 
 static void
@@ -309,8 +339,6 @@ meta_wayland_log_func (const char *fmt,
 static void
 meta_wayland_compositor_init (MetaWaylandCompositor *compositor)
 {
-  wl_list_init (&compositor->frame_callbacks);
-
   compositor->scheduled_surface_associations = g_hash_table_new (NULL, NULL);
 
   wl_log_set_handler_server (meta_wayland_log_func);
@@ -318,6 +346,8 @@ meta_wayland_compositor_init (MetaWaylandCompositor *compositor)
   compositor->wayland_display = wl_display_create ();
   if (compositor->wayland_display == NULL)
     g_error ("Failed to create the global wl_display");
+
+  clutter_wayland_set_compositor_display (compositor->wayland_display);
 }
 
 static void
@@ -325,19 +355,6 @@ meta_wayland_compositor_class_init (MetaWaylandCompositorClass *klass)
 {
 }
 
-void
-meta_wayland_pre_clutter_init (void)
-{
-  MetaWaylandCompositor *compositor;
-
-  g_assert (!_meta_wayland_compositor);
-
-  compositor = g_object_new (META_TYPE_WAYLAND_COMPOSITOR, NULL);
-  clutter_wayland_set_compositor_display (compositor->wayland_display);
-
-  _meta_wayland_compositor = compositor;
-}
-
 static bool
 meta_xwayland_global_filter (const struct wl_client *client,
                              const struct wl_global *global,
@@ -368,8 +385,19 @@ meta_wayland_get_xwayland_auth_file (MetaWaylandCompositor *compositor)
   return compositor->xwayland_manager.auth_file;
 }
 
+MetaWaylandCompositor *
+meta_wayland_compositor_new (MetaBackend *backend)
+{
+  MetaWaylandCompositor *compositor;
+
+  compositor = g_object_new (META_TYPE_WAYLAND_COMPOSITOR, NULL);
+  compositor->backend = backend;
+
+  return compositor;
+}
+
 void
-meta_wayland_init (void)
+meta_wayland_compositor_setup (MetaWaylandCompositor *wayland_compositor)
 {
   MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
   GSource *wayland_event_source;
diff --git a/src/wayland/meta-wayland.h b/src/wayland/meta-wayland.h
index c5690c34ec46c0b21259f43e1580b512464a217a..679a5c99a3dcb1e09645635d57bb0de2988c8686 100644
--- a/src/wayland/meta-wayland.h
+++ b/src/wayland/meta-wayland.h
@@ -37,8 +37,10 @@ void                    meta_wayland_init                       (void);
 
 void                    meta_wayland_finalize                   (void);
 
-/* We maintain a singleton MetaWaylandCompositor which can be got at via this
- * API after meta_wayland_init() has been called. */
+MetaWaylandCompositor * meta_wayland_compositor_new             (MetaBackend *backend);
+
+void                    meta_wayland_compositor_setup           (MetaWaylandCompositor *compositor);
+
 META_EXPORT_TEST
 MetaWaylandCompositor  *meta_wayland_compositor_get_default     (void);
 
@@ -60,6 +62,9 @@ void                    meta_wayland_compositor_set_input_focus (MetaWaylandComp
 
 void                    meta_wayland_compositor_paint_finished  (MetaWaylandCompositor *compositor);
 
+void                    meta_wayland_compositor_add_frame_callback_surface (MetaWaylandCompositor *compositor,
+                                                                            MetaWaylandSurface    *surface);
+
 void                    meta_wayland_compositor_destroy_frame_callbacks (MetaWaylandCompositor *compositor,
                                                                          MetaWaylandSurface    *surface);
 
